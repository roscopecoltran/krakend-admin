syntax = "proto3";

import "google/protobuf/empty.proto";

import "google/api/annotations.proto";

package amazonworkdocs;

message GetApiV1ActivitiesRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeActivitiesRequest body = 10;
}

message PostApiV1DocumentsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    InitiateDocumentVersionUploadRequest body = 10;
}

message GetApiV1DocumentsDocumentIdPathRequest {
    string Action = 1;
    string DocumentId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    GetDocumentPathRequest body = 11;
}

message GetApiV1DocumentsDocumentIdVersionsRequest {
    string Action = 1;
    string DocumentId = 2;
    // Pagination limit
    string Limit = 3;
    // Pagination token
    string Marker = 4;
    string Version = 5;
    string X_Amz_Algorithm = 6;
    string X_Amz_Content_Sha256 = 7;
    string X_Amz_Credential = 8;
    string X_Amz_Date = 9;
    string X_Amz_Security_Token = 10;
    string X_Amz_Signature = 11;
    string X_Amz_SignedHeaders = 12;
    DescribeDocumentVersionsRequest body = 13;
}

message PostApiV1DocumentsDocumentIdVersionsVersionIdCommentRequest {
    string Action = 1;
    string DocumentId = 2;
    string Version = 3;
    string VersionId = 4;
    string X_Amz_Algorithm = 5;
    string X_Amz_Content_Sha256 = 6;
    string X_Amz_Credential = 7;
    string X_Amz_Date = 8;
    string X_Amz_Security_Token = 9;
    string X_Amz_Signature = 10;
    string X_Amz_SignedHeaders = 11;
    CreateCommentRequest body = 12;
}

message DeleteApiV1DocumentsDocumentIdVersionsVersionIdCommentCommentIdRequest {
    string Action = 1;
    string CommentId = 2;
    string DocumentId = 3;
    string Version = 4;
    string VersionId = 5;
    string X_Amz_Algorithm = 6;
    string X_Amz_Content_Sha256 = 7;
    string X_Amz_Credential = 8;
    string X_Amz_Date = 9;
    string X_Amz_Security_Token = 10;
    string X_Amz_Signature = 11;
    string X_Amz_SignedHeaders = 12;
    DeleteCommentRequest body = 13;
}

message GetApiV1DocumentsDocumentIdVersionsVersionIdCommentsRequest {
    string Action = 1;
    string DocumentId = 2;
    string Version = 3;
    string VersionId = 4;
    string X_Amz_Algorithm = 5;
    string X_Amz_Content_Sha256 = 6;
    string X_Amz_Credential = 7;
    string X_Amz_Date = 8;
    string X_Amz_Security_Token = 9;
    string X_Amz_Signature = 10;
    string X_Amz_SignedHeaders = 11;
    DescribeCommentsRequest body = 12;
}

message PostApiV1FoldersRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateFolderRequest body = 10;
}

message GetApiV1FoldersFolderIdContentsRequest {
    string Action = 1;
    string FolderId = 2;
    // Pagination limit
    string Limit = 3;
    // Pagination token
    string Marker = 4;
    string Version = 5;
    string X_Amz_Algorithm = 6;
    string X_Amz_Content_Sha256 = 7;
    string X_Amz_Credential = 8;
    string X_Amz_Date = 9;
    string X_Amz_Security_Token = 10;
    string X_Amz_Signature = 11;
    string X_Amz_SignedHeaders = 12;
    DescribeFolderContentsRequest body = 13;
}

message GetApiV1FoldersFolderIdPathRequest {
    string Action = 1;
    string FolderId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    GetFolderPathRequest body = 11;
}

message GetApiV1MeRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    GetCurrentUserRequest body = 10;
}

message GetApiV1MeRootRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeRootFoldersRequest body = 10;
}

message GetApiV1OrganizationsOrganizationIdSubscriptionsRequest {
    string Action = 1;
    string OrganizationId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    DescribeNotificationSubscriptionsRequest body = 11;
}

message DeleteApiV1OrganizationsOrganizationIdSubscriptionsSubscriptionIdRequest {
    string Action = 1;
    string OrganizationId = 2;
    string SubscriptionId = 3;
    string Version = 4;
    string X_Amz_Algorithm = 5;
    string X_Amz_Content_Sha256 = 6;
    string X_Amz_Credential = 7;
    string X_Amz_Date = 8;
    string X_Amz_Security_Token = 9;
    string X_Amz_Signature = 10;
    string X_Amz_SignedHeaders = 11;
    DeleteNotificationSubscriptionRequest body = 12;
}

message DeleteApiV1ResourcesResourceIdCustomMetadataRequest {
    string Action = 1;
    string ResourceId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    DeleteCustomMetadataRequest body = 11;
}

message DeleteApiV1ResourcesResourceIdLabelsRequest {
    string Action = 1;
    string ResourceId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    DeleteLabelsRequest body = 11;
}

message DeleteApiV1ResourcesResourceIdPermissionsRequest {
    string Action = 1;
    string ResourceId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    RemoveAllResourcePermissionsRequest body = 11;
}

message DeleteApiV1ResourcesResourceIdPermissionsPrincipalIdRequest {
    string Action = 1;
    string PrincipalId = 2;
    string ResourceId = 3;
    string Version = 4;
    string X_Amz_Algorithm = 5;
    string X_Amz_Content_Sha256 = 6;
    string X_Amz_Credential = 7;
    string X_Amz_Date = 8;
    string X_Amz_Security_Token = 9;
    string X_Amz_Signature = 10;
    string X_Amz_SignedHeaders = 11;
    RemoveResourcePermissionRequest body = 12;
}

message GetApiV1UsersRequest {
    string Action = 1;
    // Pagination limit
    string Limit = 2;
    // Pagination token
    string Marker = 3;
    string Version = 4;
    string X_Amz_Algorithm = 5;
    string X_Amz_Content_Sha256 = 6;
    string X_Amz_Credential = 7;
    string X_Amz_Date = 8;
    string X_Amz_Security_Token = 9;
    string X_Amz_Signature = 10;
    string X_Amz_SignedHeaders = 11;
    DescribeUsersRequest body = 12;
}

message DeleteApiV1UsersUserIdActivationRequest {
    string Action = 1;
    string UserId = 2;
    string Version = 3;
    string X_Amz_Algorithm = 4;
    string X_Amz_Content_Sha256 = 5;
    string X_Amz_Credential = 6;
    string X_Amz_Date = 7;
    string X_Amz_Security_Token = 8;
    string X_Amz_Signature = 9;
    string X_Amz_SignedHeaders = 10;
    DeactivateUserRequest body = 11;
}

message AbortDocumentVersionUploadRequest {
}

message ActivateUserRequest {
}

message ActivateUserResponse {
    // The user information.
    User User = 1;
}

message Activity {
    // Metadata of the commenting activity. This is an optional field and is filled for commenting activities.
    CommentMetadata CommentMetadata = 1;
    // The user who performed the action.
    UserMetadata Initiator = 2;
    // The ID of the organization.
    string OrganizationId = 3;
    // The original parent of the resource. This is an optional field and is filled for move activities.
    ResourceMetadata OriginalParent = 4;
    // The list of users or groups impacted by this action. This is an optional field and is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED, DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.
    Participants Participants = 5;
    // The metadata of the resource involved in the user action.
    ResourceMetadata ResourceMetadata = 6;
    // The timestamp when the action was performed.
    string TimeStamp = 7;
    // The activity type.
    ActivityType Type = 8;
}

enum ActivityType {
    DOCUMENT_CHECKED_IN = 0;
    DOCUMENT_CHECKED_OUT = 1;
    DOCUMENT_RENAMED = 2;
    DOCUMENT_VERSION_UPLOADED = 3;
    DOCUMENT_VERSION_DELETED = 4;
    DOCUMENT_RECYCLED = 5;
    DOCUMENT_RESTORED = 6;
    DOCUMENT_REVERTED = 7;
    DOCUMENT_SHARED = 8;
    DOCUMENT_UNSHARED = 9;
    DOCUMENT_SHARE_PERMISSION_CHANGED = 10;
    DOCUMENT_SHAREABLE_LINK_CREATED = 11;
    DOCUMENT_SHAREABLE_LINK_REMOVED = 12;
    DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED = 13;
    DOCUMENT_MOVED = 14;
    DOCUMENT_COMMENT_ADDED = 15;
    DOCUMENT_COMMENT_DELETED = 16;
    DOCUMENT_ANNOTATION_ADDED = 17;
    DOCUMENT_ANNOTATION_DELETED = 18;
    FOLDER_CREATED = 19;
    FOLDER_DELETED = 20;
    FOLDER_RENAMED = 21;
    FOLDER_RECYCLED = 22;
    FOLDER_RESTORED = 23;
    FOLDER_SHARED = 24;
    FOLDER_UNSHARED = 25;
    FOLDER_SHARE_PERMISSION_CHANGED = 26;
    FOLDER_SHAREABLE_LINK_CREATED = 27;
    FOLDER_SHAREABLE_LINK_REMOVED = 28;
    FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED = 29;
    FOLDER_MOVED = 30;
}

message AddResourcePermissionsRequest {
    // The users, groups, or organization being granted permission.
    array Principals = 1;
}

message AddResourcePermissionsResponse {
    // The share results.
    array ShareResults = 1;
}

message Comment {
    // The ID of the comment.
    string CommentId = 1;
    // The details of the user who made the comment.
    User Contributor = 2;
    // The time that the comment was created.
    string CreatedTimestamp = 3;
    // The ID of the parent comment.
    string ParentId = 4;
    // If the comment is a reply to another user's comment, this field contains the user ID of the user being replied to.
    string RecipientId = 5;
    // The status of the comment.
    CommentStatusType Status = 6;
    // The text of the comment.
    string Text = 7;
    // The ID of the root comment in the thread.
    string ThreadId = 8;
    // The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
    CommentVisibilityType Visibility = 9;
}



repeated Comment CommentList = 1

message CommentMetadata {
    // The ID of the comment.
    string CommentId = 1;
    CommentStatusType CommentStatus = 2;
    // The user who made the comment.
    User Contributor = 3;
    string CreatedTimestamp = 4;
    // The ID of the user being replied to.
    string RecipientId = 5;
}

enum CommentStatusType {
    DRAFT = 0;
    PUBLISHED = 1;
    DELETED = 2;
}

enum CommentVisibilityType {
    PUBLIC = 0;
    PRIVATE = 1;
}

message ConcurrentModificationException {
    string Message = 1;
}

message CreateCommentRequest {
    // Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
    boolean NotifyCollaborators = 1;
    // The ID of the parent comment.
    string ParentId = 2;
    // The text of the comment.
    string Text = 3;
    // The ID of the root comment in the thread.
    string ThreadId = 4;
    // The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
    CommentVisibilityType Visibility = 5;
}

message CreateCommentResponse {
    // The comment that has been created.
    Comment Comment = 1;
}

message CreateCustomMetadataRequest {
    // Custom metadata in the form of name-value pairs.
    array CustomMetadata = 1;
}

message CreateCustomMetadataResponse {
}

message CreateFolderRequest {
    // The name of the new folder.
    string Name = 1;
    // The ID of the parent folder.
    string ParentFolderId = 2;
}

message CreateFolderResponse {
    // The metadata of the folder.
    FolderMetadata Metadata = 1;
}

message CreateLabelsRequest {
    // List of labels to add to the resource.
    array Labels = 1;
}

message CreateLabelsResponse {
}

message CreateNotificationSubscriptionRequest {
    // The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with "https://".
    string Endpoint = 1;
    // The protocol to use. The supported value is https, which delivers JSON-encoded messasges using HTTPS POST.
    SubscriptionProtocolType Protocol = 2;
    // The notification type.
    SubscriptionType SubscriptionType = 3;
}

message CreateNotificationSubscriptionResponse {
    // The subscription.
    Subscription Subscription = 1;
}

message CreateUserRequest {
    // The email address of the user.
    string EmailAddress = 1;
    // The given name of the user.
    string GivenName = 2;
    // The ID of the organization.
    string OrganizationId = 3;
    // The password of the user.
    string Password = 4;
    // The amount of storage for the user.
    StorageRuleType StorageRule = 5;
    // The surname of the user.
    string Surname = 6;
    // The time zone ID of the user.
    string TimeZoneId = 7;
    // The login name of the user.
    string Username = 8;
}

message CreateUserResponse {
    // The user information.
    User User = 1;
}

repeated string CustomMetadataKeyList = 1



message CustomMetadataLimitExceededException {
    string Message = 1;
}

message CustomMetadataMap {
    string key = 1;
    string value = 2;
}
repeated CustomMetadataMap CustomMetadataMap = 1



message DeactivateUserRequest {
}

message DeactivatingLastSystemUserException {
}

message DeleteCommentRequest {
}

message DeleteCustomMetadataRequest {
}

message DeleteCustomMetadataResponse {
}

message DeleteDocumentRequest {
}

message DeleteFolderContentsRequest {
}

message DeleteFolderRequest {
}

message DeleteLabelsRequest {
}

message DeleteLabelsResponse {
}

message DeleteNotificationSubscriptionRequest {
}

message DeleteUserRequest {
}

message DescribeActivitiesRequest {
}

message DescribeActivitiesResponse {
    // The marker for the next set of results.
    string Marker = 1;
    // The list of activities for the specified user and time period.
    array UserActivities = 2;
}

message DescribeCommentsRequest {
}

message DescribeCommentsResponse {
    // The list of comments for the specified document version.
    array Comments = 1;
    // The marker for the next set of results. This marker was received from a previous call.
    string Marker = 2;
}

message DescribeDocumentVersionsRequest {
}

message DescribeDocumentVersionsResponse {
    // The document versions.
    array DocumentVersions = 1;
    // The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    string Marker = 2;
}

message DescribeFolderContentsRequest {
}

message DescribeFolderContentsResponse {
    // The documents in the specified folder.
    array Documents = 1;
    // The subfolders in the specified folder.
    array Folders = 2;
    // The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    string Marker = 3;
}

message DescribeNotificationSubscriptionsRequest {
}

message DescribeNotificationSubscriptionsResponse {
    // The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    string Marker = 1;
    // The subscriptions.
    array Subscriptions = 2;
}

message DescribeResourcePermissionsRequest {
}

message DescribeResourcePermissionsResponse {
    // The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    string Marker = 1;
    // The principals.
    array Principals = 2;
}

message DescribeRootFoldersRequest {
}

message DescribeRootFoldersResponse {
    // The user's special folders.
    array Folders = 1;
    // The marker for the next set of results.
    string Marker = 2;
}

message DescribeUsersRequest {
}

message DescribeUsersResponse {
    // The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    string Marker = 1;
    // The total number of users included in the results.
    integer TotalNumberOfUsers = 2;
    // The users.
    array Users = 3;
}

message DocumentLockedForCommentsException {
    string Message = 1;
}

message DocumentMetadata {
    // The time when the document was created.
    string CreatedTimestamp = 1;
    // The ID of the creator.
    string CreatorId = 2;
    // The ID of the document.
    string Id = 3;
    // List of labels on the document.
    array Labels = 4;
    // The latest version of the document.
    DocumentVersionMetadata LatestVersionMetadata = 5;
    // The time when the document was updated.
    string ModifiedTimestamp = 6;
    // The ID of the parent folder.
    string ParentFolderId = 7;
    // The resource state.
    ResourceStateType ResourceState = 8;
}

repeated DocumentMetadata DocumentMetadataList = 1

enum DocumentSourceType {
    ORIGINAL = 0;
    WITH_COMMENTS = 1;
}

message DocumentSourceUrlMap {
    DocumentSourceType key = 1;
    string value = 2;
}
repeated DocumentSourceUrlMap DocumentSourceUrlMap = 1

enum DocumentStatusType {
    INITIALIZED = 0;
    ACTIVE = 1;
}

enum DocumentThumbnailType {
    SMALL = 0;
    SMALL_HQ = 1;
    LARGE = 2;
}

message DocumentThumbnailUrlMap {
    DocumentThumbnailType key = 1;
    string value = 2;
}
repeated DocumentThumbnailUrlMap DocumentThumbnailUrlMap = 1



message DocumentVersionMetadata {
    // The time stamp when the content of the document was originally created.
    string ContentCreatedTimestamp = 1;
    // The time stamp when the content of the document was modified.
    string ContentModifiedTimestamp = 2;
    // The content type of the document.
    string ContentType = 3;
    // The time stamp when the document was first uploaded.
    string CreatedTimestamp = 4;
    // The ID of the creator.
    string CreatorId = 5;
    // The ID of the version.
    string Id = 6;
    // The time stamp when the document was last uploaded.
    string ModifiedTimestamp = 7;
    // The name of the version.
    string Name = 8;
    // The signature of the document.
    string Signature = 9;
    // The size of the document, in bytes.
    integer Size = 10;
    // The source of the document.
    array Source = 11;
    // The status of the document.
    DocumentStatusType Status = 12;
    // The thumbnail of the document.
    array Thumbnail = 13;
}

repeated DocumentVersionMetadata DocumentVersionMetadataList = 1

enum DocumentVersionStatu {
    ACTIVE = 0;
}

message DraftUploadOutOfSyncException {
    string Message = 1;
}

message EntityAlreadyExistsException {
    string Message = 1;
}

repeated string EntityIdList = 1

message EntityNotExistsException {
    array EntityIds = 1;
    string Message = 2;
}

message FailedDependencyException {
    string Message = 1;
}

enum FolderContentType {
    ALL = 0;
    DOCUMENT = 1;
    FOLDER = 2;
}

message FolderMetadata {
    // The time when the folder was created.
    string CreatedTimestamp = 1;
    // The ID of the creator.
    string CreatorId = 2;
    // The ID of the folder.
    string Id = 3;
    // List of labels on the folder.
    array Labels = 4;
    // The size of the latest version of the folder metadata.
    integer LatestVersionSize = 5;
    // The time when the folder was updated.
    string ModifiedTimestamp = 6;
    // The name of the folder.
    string Name = 7;
    // The ID of the parent folder.
    string ParentFolderId = 8;
    // The resource state of the folder.
    ResourceStateType ResourceState = 9;
    // The unique identifier created from the subfolders and documents of the folder.
    string Signature = 10;
    // The size of the folder metadata.
    integer Size = 11;
}

repeated FolderMetadata FolderMetadataList = 1

message GetCurrentUserRequest {
}

message GetCurrentUserResponse {
    // Metadata of the user.
    User User = 1;
}

message GetDocumentPathRequest {
}

message GetDocumentPathResponse {
    // The path information.
    ResourcePath Path = 1;
}

message GetDocumentRequest {
}

message GetDocumentResponse {
    // The custom metadata on the document.
    array CustomMetadata = 1;
    // The metadata details of the document.
    DocumentMetadata Metadata = 2;
}

message GetDocumentVersionRequest {
}

message GetDocumentVersionResponse {
    // The custom metadata on the document version.
    array CustomMetadata = 1;
    // The version metadata.
    DocumentVersionMetadata Metadata = 2;
}

message GetFolderPathRequest {
}

message GetFolderPathResponse {
    // The path information.
    ResourcePath Path = 1;
}

message GetFolderRequest {
}

message GetFolderResponse {
    // The custom metadata on the folder.
    array CustomMetadata = 1;
    // The metadata of the folder.
    FolderMetadata Metadata = 2;
}

message GroupMetadata {
    // The ID of the user group.
    string Id = 1;
    // The name of the group.
    string Name = 2;
}

repeated GroupMetadata GroupMetadataList = 1











message IllegalUserStateException {
    string Message = 1;
}

message InitiateDocumentVersionUploadRequest {
    // The time stamp when the content of the document was originally created.
    string ContentCreatedTimestamp = 1;
    // The time stamp when the content of the document was modified.
    string ContentModifiedTimestamp = 2;
    // The content type of the document.
    string ContentType = 3;
    // The size of the document, in bytes.
    integer DocumentSizeInBytes = 4;
    // The ID of the document.
    string Id = 5;
    // The name of the document.
    string Name = 6;
    // The ID of the parent folder.
    string ParentFolderId = 7;
}

message InitiateDocumentVersionUploadResponse {
    // The document metadata.
    DocumentMetadata Metadata = 1;
    // The upload metadata.
    UploadMetadata UploadMetadata = 2;
}

message InvalidArgumentException {
    string Message = 1;
}

message InvalidOperationException {
    string Message = 1;
}



repeated string Labels = 1

message LimitExceededException {
    string Message = 1;
}

enum LocaleType {
    EN = 0;
    FR = 1;
    KO = 2;
    DE = 3;
    ES = 4;
    JA = 5;
    RU = 6;
    ZH_CN = 7;
    ZH_TW = 8;
    PT_BR = 9;
    DEFAULT = 10;
}

enum OrderType {
    ASCENDING = 0;
    DESCENDING = 1;
}

repeated User OrganizationUserList = 1



message Participants {
    // The list of user groups.
    array Groups = 1;
    // The list of users.
    array Users = 2;
}

message PermissionInfo {
    // The role of the user.
    RoleType Role = 1;
    // The type of permissions.
    RolePermissionType Type = 2;
}

repeated PermissionInfo PermissionInfoList = 1



message Principal {
    // The ID of the resource.
    string Id = 1;
    // The permission information for the resource.
    array Roles = 2;
    // The type of resource.
    PrincipalType Type = 3;
}

repeated Principal PrincipalList = 1

enum PrincipalType {
    USER = 0;
    GROUP = 1;
    INVITE = 2;
    ANONYMOUS = 3;
    ORGANIZATION = 4;
}

message ProhibitedStateException {
    string Message = 1;
}

message RemoveAllResourcePermissionsRequest {
}

message RemoveResourcePermissionRequest {
}

message ResourceAlreadyCheckedOutException {
    string Message = 1;
}

message ResourceMetadata {
    // The ID of the resource.
    string Id = 1;
    // The name of the resource.
    string Name = 2;
    // The original name of the resource prior to a rename operation.
    string OriginalName = 3;
    // The owner of the resource.
    UserMetadata Owner = 4;
    // The parent ID of the resource before a rename operation.
    string ParentId = 5;
    // The type of resource.
    ResourceType Type = 6;
    // The version ID of the resource. This is an optional field and is filled for action on document version.
    string VersionId = 7;
}

message ResourcePath {
    // The components of the resource path.
    array Components = 1;
}

message ResourcePathComponent {
    // The ID of the resource path.
    string Id = 1;
    // The name of the resource path.
    string Name = 2;
}

repeated ResourcePathComponent ResourcePathComponentList = 1

enum ResourceSortType {
    DATE = 0;
    NAME = 1;
}

enum ResourceStateType {
    ACTIVE = 0;
    RESTORING = 1;
    RECYCLING = 2;
    RECYCLED = 3;
}

enum ResourceType {
    FOLDER = 0;
    DOCUMENT = 1;
}

enum RolePermissionType {
    DIRECT = 0;
    INHERITED = 1;
}

enum RoleType {
    VIEWER = 0;
    CONTRIBUTOR = 1;
    OWNER = 2;
    COOWNER = 3;
}

message ServiceUnavailableException {
    string Message = 1;
}

message SharePrincipal {
    // The ID of the recipient.
    string Id = 1;
    // The role of the recipient.
    RoleType Role = 2;
    // The type of the recipient.
    PrincipalType Type = 3;
}

repeated SharePrincipal SharePrincipalList = 1

message ShareResult {
    // The ID of the principal.
    string PrincipalId = 1;
    // The role.
    RoleType Role = 2;
    // The ID of the resource that was shared.
    string ShareId = 3;
    // The status.
    ShareStatusType Status = 4;
    // The status message.
    string StatusMessage = 5;
}

repeated ShareResult ShareResultsList = 1

enum ShareStatusType {
    SUCCESS = 0;
    FAILURE = 1;
}

message SignedHeaderMap {
    string key = 1;
    string value = 2;
}
repeated SignedHeaderMap SignedHeaderMap = 1



message StorageLimitExceededException {
    string Message = 1;
}

message StorageLimitWillExceedException {
    string Message = 1;
}

message StorageRuleType {
    // The amount of storage allocated, in bytes.
    integer StorageAllocatedInBytes = 1;
    // The type of storage.
    StorageType StorageType = 2;
}

enum StorageType {
    UNLIMITED = 0;
    QUOTA = 1;
}

message Subscription {
    // The endpoint of the subscription.
    string EndPoint = 1;
    // The protocol of the subscription.
    SubscriptionProtocolType Protocol = 2;
    // The ID of the subscription.
    string SubscriptionId = 3;
}



repeated Subscription SubscriptionList = 1

enum SubscriptionProtocolType {
    HTTPS = 0;
}

enum SubscriptionType {
    ALL = 0;
}

message TooManyLabelsException {
    string Message = 1;
}

message TooManySubscriptionsException {
    string Message = 1;
}

message UnauthorizedOperationException {
}

message UnauthorizedResourceAccessException {
    string Message = 1;
}

message UpdateDocumentRequest {
    // The name of the document.
    string Name = 1;
    // The ID of the parent folder.
    string ParentFolderId = 2;
    // The resource state of the document. Note that only ACTIVE and RECYCLED are supported.
    ResourceStateType ResourceState = 3;
}

message UpdateDocumentVersionRequest {
    // The status of the version.
    DocumentVersionStatus VersionStatus = 1;
}

message UpdateFolderRequest {
    // The name of the folder.
    string Name = 1;
    // The ID of the parent folder.
    string ParentFolderId = 2;
    // The resource state of the folder. Note that only ACTIVE and RECYCLED are accepted values from the API.
    ResourceStateType ResourceState = 3;
}

message UpdateUserRequest {
    // The given name of the user.
    string GivenName = 1;
    // The locale of the user.
    LocaleType Locale = 2;
    // The amount of storage for the user.
    StorageRuleType StorageRule = 3;
    // The surname of the user.
    string Surname = 4;
    // The time zone ID of the user.
    string TimeZoneId = 5;
    // The type of the user.
    UserType Type = 6;
}

message UpdateUserResponse {
    // The user information.
    User User = 1;
}

message UploadMetadata {
    // The signed headers.
    array SignedHeaders = 1;
    // The URL of the upload.
    string UploadUrl = 2;
}

message User {
    // The time when the user was created.
    string CreatedTimestamp = 1;
    // The email address of the user.
    string EmailAddress = 2;
    // The given name of the user.
    string GivenName = 3;
    // The ID of the user.
    string Id = 4;
    // The locale of the user.
    LocaleType Locale = 5;
    // The time when the user was modified.
    string ModifiedTimestamp = 6;
    // The ID of the organization.
    string OrganizationId = 7;
    // The ID of the recycle bin folder.
    string RecycleBinFolderId = 8;
    // The ID of the root folder.
    string RootFolderId = 9;
    // The status of the user.
    UserStatusType Status = 10;
    // The storage for the user.
    UserStorageMetadata Storage = 11;
    // The surname of the user.
    string Surname = 12;
    // The time zone ID of the user.
    string TimeZoneId = 13;
    // The type of user.
    UserType Type = 14;
    // The login name of the user.
    string Username = 15;
}

repeated Activity UserActivities = 1



enum UserFilterType {
    ALL = 0;
    ACTIVE_PENDING = 1;
}

message UserMetadata {
    // The email address of the user.
    string EmailAddress = 1;
    // The given name of the user before a rename operation.
    string GivenName = 2;
    // The ID of the user.
    string Id = 3;
    // The surname of the user.
    string Surname = 4;
    // The username of the user.
    string Username = 5;
}

repeated UserMetadata UserMetadataList = 1

enum UserSortType {
    USER_NAME = 0;
    FULL_NAME = 1;
    STORAGE_LIMIT = 2;
    USER_STATUS = 3;
    STORAGE_USED = 4;
}

enum UserStatusType {
    ACTIVE = 0;
    INACTIVE = 1;
    PENDING = 2;
}

message UserStorageMetadata {
    // The storage for a user.
    StorageRuleType StorageRule = 1;
    // The amount of storage utilized, in bytes.
    integer StorageUtilizedInBytes = 2;
}

enum UserType {
    USER = 0;
    ADMIN = 1;
}

service AmazonWorkDocsService {
    // Describes the user activities in a specified time period.
    rpc GetApiV1Activities(GetApiV1ActivitiesRequest) returns (DescribeActivitiesResponse) {
      option (google.api.http) = {
        get: "//api/v1/activities"
        body: "body"
      };
    }
    // <p>Creates a new document object and version object.</p> <p>The client specifies the parent folder ID and name of the document to upload. The ID is optionally specified when creating a new version of an existing document. This is the first step to upload a document. Next, upload the document to the URL returned from the call, and then call <a>UpdateDocumentVersion</a>.</p> <p>To cancel the document upload, call <a>AbortDocumentVersionUpload</a>.</p>
    rpc PostApiV1Documents(PostApiV1DocumentsRequest) returns (InitiateDocumentVersionUploadResponse) {
      option (google.api.http) = {
        post: "//api/v1/documents"
        body: "body"
      };
    }

    // <p>Retrieves the path information (the hierarchy from the root folder) for the requested document.</p> <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the requested document and only includes the IDs of the parent folders in the path. You can limit the maximum number of levels. You can also request the names of the parent folders.</p>
    rpc GetApiV1DocumentsDocumentIdPath(GetApiV1DocumentsDocumentIdPathRequest) returns (GetDocumentPathResponse) {
      option (google.api.http) = {
        get: "//api/v1/documents/{DocumentId}/path"
        body: "body"
      };
    }
    // <p>Retrieves the document versions for the specified document.</p> <p>By default, only active versions are returned.</p>
    rpc GetApiV1DocumentsDocumentIdVersions(GetApiV1DocumentsDocumentIdVersionsRequest) returns (DescribeDocumentVersionsResponse) {
      option (google.api.http) = {
        get: "//api/v1/documents/{DocumentId}/versions"
        body: "body"
      };
    }

    // Adds a new comment to the specified document version.
    rpc PostApiV1DocumentsDocumentIdVersionsVersionIdComment(PostApiV1DocumentsDocumentIdVersionsVersionIdCommentRequest) returns (CreateCommentResponse) {
      option (google.api.http) = {
        post: "//api/v1/documents/{DocumentId}/versions/{VersionId}/comment"
        body: "body"
      };
    }
    // Deletes the specified comment from the document version.
    rpc DeleteApiV1DocumentsDocumentIdVersionsVersionIdCommentCommentId(DeleteApiV1DocumentsDocumentIdVersionsVersionIdCommentCommentIdRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        delete: "//api/v1/documents/{DocumentId}/versions/{VersionId}/comment/{CommentId}"
        body: "body"
      };
    }
    // List all the comments for the specified document version.
    rpc GetApiV1DocumentsDocumentIdVersionsVersionIdComments(GetApiV1DocumentsDocumentIdVersionsVersionIdCommentsRequest) returns (DescribeCommentsResponse) {
      option (google.api.http) = {
        get: "//api/v1/documents/{DocumentId}/versions/{VersionId}/comments"
        body: "body"
      };
    }
    // Creates a folder with the specified name and parent folder.
    rpc PostApiV1Folders(PostApiV1FoldersRequest) returns (CreateFolderResponse) {
      option (google.api.http) = {
        post: "//api/v1/folders"
        body: "body"
      };
    }

    // <p>Describes the contents of the specified folder, including its documents and subfolders.</p> <p>By default, Amazon WorkDocs returns the first 100 active document and folder metadata items. If there are more results, the response includes a marker that you can use to request the next set of results. You can also request initialized documents.</p>
    rpc GetApiV1FoldersFolderIdContents(GetApiV1FoldersFolderIdContentsRequest) returns (DescribeFolderContentsResponse) {
      option (google.api.http) = {
        get: "//api/v1/folders/{FolderId}/contents"
        body: "body"
      };
    }
    // <p>Retrieves the path information (the hierarchy from the root folder) for the specified folder.</p> <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the requested folder and only includes the IDs of the parent folders in the path. You can limit the maximum number of levels. You can also request the parent folder names.</p>
    rpc GetApiV1FoldersFolderIdPath(GetApiV1FoldersFolderIdPathRequest) returns (GetFolderPathResponse) {
      option (google.api.http) = {
        get: "//api/v1/folders/{FolderId}/path"
        body: "body"
      };
    }
    // Retrieves details of the current user for whom the authentication token was generated. This is not a valid action for SigV4 (administrative API) clients.
    rpc GetApiV1Me(GetApiV1MeRequest) returns (GetCurrentUserResponse) {
      option (google.api.http) = {
        get: "//api/v1/me"
        body: "body"
      };
    }
    // Describes the current user's special folders; the <code>RootFolder</code> and the <code>RecyleBin</code>. <code>RootFolder</code> is the root of user's files and folders and <code>RecyleBin</code> is the root of recycled items. This is not a valid action for SigV4 (administrative API) clients.
    rpc GetApiV1MeRoot(GetApiV1MeRootRequest) returns (DescribeRootFoldersResponse) {
      option (google.api.http) = {
        get: "//api/v1/me/root"
        body: "body"
      };
    }
    // Lists the specified notification subscriptions.
    rpc GetApiV1OrganizationsOrganizationIdSubscriptions(GetApiV1OrganizationsOrganizationIdSubscriptionsRequest) returns (DescribeNotificationSubscriptionsResponse) {
      option (google.api.http) = {
        get: "//api/v1/organizations/{OrganizationId}/subscriptions"
        body: "body"
      };
    }
    // Deletes the specified subscription from the specified organization.
    rpc DeleteApiV1OrganizationsOrganizationIdSubscriptionsSubscriptionId(DeleteApiV1OrganizationsOrganizationIdSubscriptionsSubscriptionIdRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        delete: "//api/v1/organizations/{OrganizationId}/subscriptions/{SubscriptionId}"
        body: "body"
      };
    }
    // Deletes custom metadata from the specified resource.
    rpc DeleteApiV1ResourcesResourceIdCustomMetadata(DeleteApiV1ResourcesResourceIdCustomMetadataRequest) returns (DeleteCustomMetadataResponse) {
      option (google.api.http) = {
        delete: "//api/v1/resources/{ResourceId}/customMetadata"
        body: "body"
      };
    }
    // Deletes the specified list of labels from a resource.
    rpc DeleteApiV1ResourcesResourceIdLabels(DeleteApiV1ResourcesResourceIdLabelsRequest) returns (DeleteLabelsResponse) {
      option (google.api.http) = {
        delete: "//api/v1/resources/{ResourceId}/labels"
        body: "body"
      };
    }
    // Removes all the permissions from the specified resource.
    rpc DeleteApiV1ResourcesResourceIdPermissions(DeleteApiV1ResourcesResourceIdPermissionsRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        delete: "//api/v1/resources/{ResourceId}/permissions"
        body: "body"
      };
    }
    // Removes the permission for the specified principal from the specified resource.
    rpc DeleteApiV1ResourcesResourceIdPermissionsPrincipalId(DeleteApiV1ResourcesResourceIdPermissionsPrincipalIdRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        delete: "//api/v1/resources/{ResourceId}/permissions/{PrincipalId}"
        body: "body"
      };
    }
    // <p>Describes the specified users. You can describe all users or filter the results (for example, by status or organization).</p> <p>By default, Amazon WorkDocs returns the first 24 active or pending users. If there are more results, the response includes a marker that you can use to request the next set of results.</p>
    rpc GetApiV1Users(GetApiV1UsersRequest) returns (DescribeUsersResponse) {
      option (google.api.http) = {
        get: "//api/v1/users"
        body: "body"
      };
    }

    // Deactivates the specified user, which revokes the user's access to Amazon WorkDocs.
    rpc DeleteApiV1UsersUserIdActivation(DeleteApiV1UsersUserIdActivationRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        delete: "//api/v1/users/{UserId}/activation"
        body: "body"
      };
    }
}
