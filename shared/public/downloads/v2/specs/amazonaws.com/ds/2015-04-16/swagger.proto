syntax = "proto3";

import "google/api/annotations.proto";

package awsdirectoryservice;

message PostRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    AddIpRoutesRequest body = 10;
}

message Post#AddTagsToResourceRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    AddTagsToResourceRequest body = 10;
}

message Post#CancelSchemaExtensionRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CancelSchemaExtensionRequest body = 10;
}

message Post#ConnectDirectoryRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    ConnectDirectoryRequest body = 10;
}

message Post#CreateAliasRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateAliasRequest body = 10;
}

message Post#CreateComputerRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateComputerRequest body = 10;
}

message Post#CreateConditionalForwarderRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateConditionalForwarderRequest body = 10;
}

message Post#CreateDirectoryRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateDirectoryRequest body = 10;
}

message Post#CreateMicrosoftADRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateMicrosoftADRequest body = 10;
}

message Post#CreateSnapshotRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateSnapshotRequest body = 10;
}

message Post#CreateTrustRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    CreateTrustRequest body = 10;
}

message Post#DeleteConditionalForwarderRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DeleteConditionalForwarderRequest body = 10;
}

message Post#DeleteDirectoryRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DeleteDirectoryRequest body = 10;
}

message Post#DeleteSnapshotRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DeleteSnapshotRequest body = 10;
}

message Post#DeleteTrustRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DeleteTrustRequest body = 10;
}

message Post#DeregisterEventTopicRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DeregisterEventTopicRequest body = 10;
}

message Post#DescribeConditionalForwardersRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeConditionalForwardersRequest body = 10;
}

message Post#DescribeDirectoriesRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeDirectoriesRequest body = 10;
}

message Post#DescribeDomainControllersRequest {
    string Action = 1;
    // Pagination limit
    string Limit = 2;
    // Pagination token
    string NextToken = 3;
    string Version = 4;
    string X_Amz_Algorithm = 5;
    string X_Amz_Content_Sha256 = 6;
    string X_Amz_Credential = 7;
    string X_Amz_Date = 8;
    string X_Amz_Security_Token = 9;
    string X_Amz_Signature = 10;
    string X_Amz_SignedHeaders = 11;
    DescribeDomainControllersRequest body = 12;
}

message Post#DescribeEventTopicsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeEventTopicsRequest body = 10;
}

message Post#DescribeSnapshotsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeSnapshotsRequest body = 10;
}

message Post#DescribeTrustsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DescribeTrustsRequest body = 10;
}

message Post#DisableRadiusRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DisableRadiusRequest body = 10;
}

message Post#DisableSsoRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    DisableSsoRequest body = 10;
}

message Post#EnableRadiusRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    EnableRadiusRequest body = 10;
}

message Post#EnableSsoRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    EnableSsoRequest body = 10;
}

message Post#GetDirectoryLimitsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    GetDirectoryLimitsRequest body = 10;
}

message Post#GetSnapshotLimitsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    GetSnapshotLimitsRequest body = 10;
}

message Post#ListIpRoutesRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    ListIpRoutesRequest body = 10;
}

message Post#ListSchemaExtensionsRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    ListSchemaExtensionsRequest body = 10;
}

message Post#ListTagsForResourceRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    ListTagsForResourceRequest body = 10;
}

message Post#RegisterEventTopicRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    RegisterEventTopicRequest body = 10;
}

message Post#RemoveIpRoutesRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    RemoveIpRoutesRequest body = 10;
}

message Post#RemoveTagsFromResourceRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    RemoveTagsFromResourceRequest body = 10;
}

message Post#RestoreFromSnapshotRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    RestoreFromSnapshotRequest body = 10;
}

message Post#StartSchemaExtensionRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    StartSchemaExtensionRequest body = 10;
}

message Post#UpdateConditionalForwarderRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    UpdateConditionalForwarderRequest body = 10;
}

message Post#UpdateNumberOfDomainControllersRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    UpdateNumberOfDomainControllersRequest body = 10;
}

message Post#UpdateRadiusRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    UpdateRadiusRequest body = 10;
}

message Post#VerifyTrustRequest {
    string Action = 1;
    string Version = 2;
    string X_Amz_Algorithm = 3;
    string X_Amz_Content_Sha256 = 4;
    string X_Amz_Credential = 5;
    string X_Amz_Date = 6;
    string X_Amz_Security_Token = 7;
    string X_Amz_Signature = 8;
    string X_Amz_SignedHeaders = 9;
    VerifyTrustRequest body = 10;
}

message AddIpRoutesRequest {
    // Identifier (ID) of the directory to which to add the address block.
    string DirectoryId = 1;
    // IP address blocks, using CIDR format, of the traffic to route. This is often the IP address block of the DNS server used for your on-premises domain.
    array IpRoutes = 2;
    // <p>If set to true, updates the inbound and outbound rules of the security group that has the description: "AWS created security group for <i>directory ID</i> directory controllers." Following are the new rules: </p> <p>Inbound:</p> <ul> <li> <p>Type: Custom UDP Rule, Protocol: UDP, Range: 88, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom UDP Rule, Protocol: UDP, Range: 123, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom UDP Rule, Protocol: UDP, Range: 138, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom UDP Rule, Protocol: UDP, Range: 389, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom UDP Rule, Protocol: UDP, Range: 464, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom UDP Rule, Protocol: UDP, Range: 445, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 88, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 135, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 445, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 464, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 636, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 1024-65535, Source: 0.0.0.0/0</p> </li> <li> <p>Type: Custom TCP Rule, Protocol: TCP, Range: 3268-33269, Source: 0.0.0.0/0</p> </li> <li> <p>Type: DNS (UDP), Protocol: UDP, Range: 53, Source: 0.0.0.0/0</p> </li> <li> <p>Type: DNS (TCP), Protocol: TCP, Range: 53, Source: 0.0.0.0/0</p> </li> <li> <p>Type: LDAP, Protocol: TCP, Range: 389, Source: 0.0.0.0/0</p> </li> <li> <p>Type: All ICMP, Protocol: All, Range: N/A, Source: 0.0.0.0/0</p> </li> </ul> <p/> <p>Outbound:</p> <ul> <li> <p>Type: All traffic, Protocol: All, Range: All, Destination: 0.0.0.0/0</p> </li> </ul> <p>These security rules impact an internal network interface that is not exposed publicly.</p>
    boolean UpdateSecurityGroupForDirectoryControllers = 3;
}

message AddIpRoutesResult {
}

message AddTagsToResourceRequest {
    // Identifier (ID) for the directory to which to add the tag.
    string ResourceId = 1;
    // The tags to be assigned to the directory.
    array Tags = 2;
}

message AddTagsToResourceResult {
}

message Attribute {
    // The name of the attribute.
    string Name = 1;
    // The value of the attribute.
    string Value = 2;
}





repeated Attribute Attributes = 1

message AuthenticationFailedException {
    // The textual message for the exception.
    string Message = 1;
    // The identifier of the request that caused the exception.
    string RequestId = 2;
}



repeated string AvailabilityZones = 1

message CancelSchemaExtensionRequest {
    // The identifier of the directory whose schema extension will be canceled.
    string DirectoryId = 1;
    // The identifier of the schema extension that will be canceled.
    string SchemaExtensionId = 2;
}

message CancelSchemaExtensionResult {
}



repeated string CidrIps = 1

message ClientException {
    string Message = 1;
    string RequestId = 2;
}

message Computer {
    // An array of <a>Attribute</a> objects containing the LDAP attributes that belong to the computer account.
    array ComputerAttributes = 1;
    // The identifier of the computer.
    string ComputerId = 2;
    // The computer name.
    string ComputerName = 3;
}

message ConditionalForwarder {
    // The IP addresses of the remote DNS server associated with RemoteDomainName. This is the IP address of the DNS server that your conditional forwarder points to.
    array DnsIpAddrs = 1;
    // The fully qualified domain name (FQDN) of the remote domains pointed to by the conditional forwarder.
    string RemoteDomainName = 2;
    // The replication scope of the conditional forwarder. The only allowed value is <code>Domain</code>, which will replicate the conditional forwarder to all of the domain controllers for your AWS directory.
    ReplicationScope ReplicationScope = 3;
}

repeated ConditionalForwarder ConditionalForwarders = 1

message ConnectDirectoryRequest {
    // A <a>DirectoryConnectSettings</a> object that contains additional information for the operation.
    DirectoryConnectSettings ConnectSettings = 1;
    // A textual description for the directory.
    string Description = 2;
    // The fully-qualified name of the on-premises directory, such as <code>corp.example.com</code>.
    string Name = 3;
    // The password for the on-premises user account.
    string Password = 4;
    // The NetBIOS name of the on-premises directory, such as <code>CORP</code>.
    string ShortName = 5;
    // The size of the directory.
    DirectorySize Size = 6;
}

message ConnectDirectoryResult {
    // The identifier of the new directory.
    string DirectoryId = 1;
}

message CreateAliasRequest {
    // <p>The requested alias.</p> <p>The alias must be unique amongst all aliases in AWS. This operation throws an <code>EntityAlreadyExistsException</code> error if the alias already exists.</p>
    string Alias = 1;
    // The identifier of the directory for which to create the alias.
    string DirectoryId = 2;
}

message CreateAliasResult {
    // The alias for the directory.
    string Alias = 1;
    // The identifier of the directory.
    string DirectoryId = 2;
}

message CreateComputerRequest {
    // An array of <a>Attribute</a> objects that contain any LDAP attributes to apply to the computer account.
    array ComputerAttributes = 1;
    // The name of the computer account.
    string ComputerName = 2;
    // The identifier of the directory in which to create the computer account.
    string DirectoryId = 3;
    // The fully-qualified distinguished name of the organizational unit to place the computer account in.
    string OrganizationalUnitDistinguishedName = 4;
    // A one-time password that is used to join the computer to the directory. You should generate a random, strong password to use for this parameter.
    string Password = 5;
}

message CreateComputerResult {
    // A <a>Computer</a> object that represents the computer account.
    Computer Computer = 1;
}

message CreateConditionalForwarderRequest {
    // The directory ID of the AWS directory for which you are creating the conditional forwarder.
    string DirectoryId = 1;
    // The IP addresses of the remote DNS server associated with RemoteDomainName.
    array DnsIpAddrs = 2;
    // The fully qualified domain name (FQDN) of the remote domain with which you will set up a trust relationship.
    string RemoteDomainName = 3;
}

message CreateConditionalForwarderResult {
}

message CreateDirectoryRequest {
    // A textual description for the directory.
    string Description = 1;
    // The fully qualified name for the directory, such as <code>corp.example.com</code>.
    string Name = 2;
    // The password for the directory administrator. The directory creation process creates a directory administrator account with the username <code>Administrator</code> and this password.
    string Password = 3;
    // The short name of the directory, such as <code>CORP</code>.
    string ShortName = 4;
    // The size of the directory.
    DirectorySize Size = 5;
    // A <a>DirectoryVpcSettings</a> object that contains additional information for the operation.
    DirectoryVpcSettings VpcSettings = 6;
}

message CreateDirectoryResult {
    // The identifier of the directory that was created.
    string DirectoryId = 1;
}

message CreateMicrosoftADRequest {
    // A textual description for the directory. This label will appear on the AWS console <code>Directory Details</code> page after the directory is created.
    string Description = 1;
    // The fully qualified domain name for the directory, such as <code>corp.example.com</code>. This name will resolve inside your VPC only. It does not need to be publicly resolvable.
    string Name = 2;
    // The password for the default administrative user named <code>Admin</code>.
    string Password = 3;
    // The NetBIOS name for your domain. A short identifier for your domain, such as <code>CORP</code>. If you don't specify a NetBIOS name, it will default to the first part of your directory DNS. For example, <code>CORP</code> for the directory DNS <code>corp.example.com</code>.
    string ShortName = 4;
    // Contains VPC information for the <a>CreateDirectory</a> or <a>CreateMicrosoftAD</a> operation.
    DirectoryVpcSettings VpcSettings = 5;
}

message CreateMicrosoftADResult {
    // The identifier of the directory that was created.
    string DirectoryId = 1;
}

message CreateSnapshotRequest {
    // The identifier of the directory of which to take a snapshot.
    string DirectoryId = 1;
    // The descriptive name to apply to the snapshot.
    string Name = 2;
}

message CreateSnapshotResult {
    // The identifier of the snapshot that was created.
    string SnapshotId = 1;
}

message CreateTrustRequest {
    // The IP addresses of the remote DNS server associated with RemoteDomainName.
    array ConditionalForwarderIpAddrs = 1;
    // The Directory ID of the Microsoft AD in the AWS cloud for which to establish the trust relationship.
    string DirectoryId = 2;
    // The Fully Qualified Domain Name (FQDN) of the external domain for which to create the trust relationship.
    string RemoteDomainName = 3;
    // The direction of the trust relationship.
    TrustDirection TrustDirection = 4;
    // The trust password. The must be the same password that was used when creating the trust relationship on the external domain.
    string TrustPassword = 5;
    // The trust relationship type.
    TrustType TrustType = 6;
}

message CreateTrustResult {
    // A unique identifier for the trust relationship that was created.
    string TrustId = 1;
}

message DeleteConditionalForwarderRequest {
    // The directory ID for which you are deleting the conditional forwarder.
    string DirectoryId = 1;
    // The fully qualified domain name (FQDN) of the remote domain with which you are deleting the conditional forwarder.
    string RemoteDomainName = 2;
}

message DeleteConditionalForwarderResult {
}

message DeleteDirectoryRequest {
    // The identifier of the directory to delete.
    string DirectoryId = 1;
}

message DeleteDirectoryResult {
    // The directory identifier.
    string DirectoryId = 1;
}

message DeleteSnapshotRequest {
    // The identifier of the directory snapshot to be deleted.
    string SnapshotId = 1;
}

message DeleteSnapshotResult {
    // The identifier of the directory snapshot that was deleted.
    string SnapshotId = 1;
}

message DeleteTrustRequest {
    // Delete a conditional forwarder as part of a DeleteTrustRequest.
    boolean DeleteAssociatedConditionalForwarder = 1;
    // The Trust ID of the trust relationship to be deleted.
    string TrustId = 2;
}

message DeleteTrustResult {
    // The Trust ID of the trust relationship that was deleted.
    string TrustId = 1;
}

message DeregisterEventTopicRequest {
    // The Directory ID to remove as a publisher. This directory will no longer send messages to the specified SNS topic.
    string DirectoryId = 1;
    // The name of the SNS topic from which to remove the directory as a publisher.
    string TopicName = 2;
}

message DeregisterEventTopicResult {
}

message DescribeConditionalForwardersRequest {
    // The directory ID for which to get the list of associated conditional forwarders.
    string DirectoryId = 1;
    // The fully qualified domain names (FQDN) of the remote domains for which to get the list of associated conditional forwarders. If this member is null, all conditional forwarders are returned.
    array RemoteDomainNames = 2;
}

message DescribeConditionalForwardersResult {
    // The list of conditional forwarders that have been created.
    array ConditionalForwarders = 1;
}

message DescribeDirectoriesRequest {
    // <p>A list of identifiers of the directories for which to obtain the information. If this member is null, all directories that belong to the current account are returned.</p> <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
    array DirectoryIds = 1;
    // The maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation.
    integer Limit = 2;
    // The <i>DescribeDirectoriesResult.NextToken</i> value from a previous call to <a>DescribeDirectories</a>. Pass null if this is the first call.
    string NextToken = 3;
}

message DescribeDirectoriesResult {
    // <p>The list of <a>DirectoryDescription</a> objects that were retrieved.</p> <p>It is possible that this list contains less than the number of items specified in the <i>Limit</i> member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.</p>
    array DirectoryDescriptions = 1;
    // If not null, more results are available. Pass this value for the <i>NextToken</i> parameter in a subsequent call to <a>DescribeDirectories</a> to retrieve the next set of items.
    string NextToken = 2;
}

message DescribeDomainControllersRequest {
    // Identifier of the directory for which to retrieve the domain controller information.
    string DirectoryId = 1;
    // A list of identifiers for the domain controllers whose information will be provided.
    array DomainControllerIds = 2;
    // The maximum number of items to return.
    integer Limit = 3;
    // The <i>DescribeDomainControllers.NextToken</i> value from a previous call to <a>DescribeDomainControllers</a>. Pass null if this is the first call.
    string NextToken = 4;
}

message DescribeDomainControllersResult {
    // List of the <a>DomainController</a> objects that were retrieved.
    array DomainControllers = 1;
    // If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to <a>DescribeDomainControllers</a> retrieve the next set of items.
    string NextToken = 2;
}

message DescribeEventTopicsRequest {
    // The Directory ID for which to get the list of associated SNS topics. If this member is null, associations for all Directory IDs are returned.
    string DirectoryId = 1;
    // <p>A list of SNS topic names for which to obtain the information. If this member is null, all associations for the specified Directory ID are returned.</p> <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
    array TopicNames = 2;
}

message DescribeEventTopicsResult {
    // A list of SNS topic names that receive status messages from the specified Directory ID.
    array EventTopics = 1;
}

message DescribeSnapshotsRequest {
    // The identifier of the directory for which to retrieve snapshot information.
    string DirectoryId = 1;
    // The maximum number of objects to return.
    integer Limit = 2;
    // The <i>DescribeSnapshotsResult.NextToken</i> value from a previous call to <a>DescribeSnapshots</a>. Pass null if this is the first call.
    string NextToken = 3;
    // A list of identifiers of the snapshots to obtain the information for. If this member is null or empty, all snapshots are returned using the <i>Limit</i> and <i>NextToken</i> members.
    array SnapshotIds = 4;
}

message DescribeSnapshotsResult {
    // If not null, more results are available. Pass this value in the <i>NextToken</i> member of a subsequent call to <a>DescribeSnapshots</a>.
    string NextToken = 1;
    // <p>The list of <a>Snapshot</a> objects that were retrieved.</p> <p>It is possible that this list contains less than the number of items specified in the <i>Limit</i> member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.</p>
    array Snapshots = 2;
}

message DescribeTrustsRequest {
    // The Directory ID of the AWS directory that is a part of the requested trust relationship.
    string DirectoryId = 1;
    // The maximum number of objects to return.
    integer Limit = 2;
    // The <i>DescribeTrustsResult.NextToken</i> value from a previous call to <a>DescribeTrusts</a>. Pass null if this is the first call.
    string NextToken = 3;
    // <p>A list of identifiers of the trust relationships for which to obtain the information. If this member is null, all trust relationships that belong to the current account are returned.</p> <p>An empty list results in an <code>InvalidParameterException</code> being thrown.</p>
    array TrustIds = 4;
}

message DescribeTrustsResult {
    // If not null, more results are available. Pass this value for the <i>NextToken</i> parameter in a subsequent call to <a>DescribeTrusts</a> to retrieve the next set of items.
    string NextToken = 1;
    // <p>The list of Trust objects that were retrieved.</p> <p>It is possible that this list contains less than the number of items specified in the <i>Limit</i> member of the request. This occurs if there are less than the requested number of items left to retrieve, or if the limitations of the operation have been exceeded.</p>
    array Trusts = 2;
}

message DirectoryConnectSettings {
    // A list of one or more IP addresses of DNS servers or domain controllers in the on-premises directory.
    array CustomerDnsIps = 1;
    // <p>The username of an account in the on-premises directory that is used to connect to the directory. This account must have the following privileges:</p> <ul> <li> <p>Read users and groups</p> </li> <li> <p>Create computer objects</p> </li> <li> <p>Join computers to the domain</p> </li> </ul>
    string CustomerUserName = 2;
    // A list of subnet identifiers in the VPC in which the AD Connector is created.
    array SubnetIds = 3;
    // The identifier of the VPC in which the AD Connector is created.
    string VpcId = 4;
}

message DirectoryConnectSettingsDescription {
    // A list of the Availability Zones that the directory is in.
    array AvailabilityZones = 1;
    // The IP addresses of the AD Connector servers.
    array ConnectIps = 2;
    // The username of the service account in the on-premises directory.
    string CustomerUserName = 3;
    // The security group identifier for the AD Connector directory.
    string SecurityGroupId = 4;
    // A list of subnet identifiers in the VPC that the AD connector is in.
    array SubnetIds = 5;
    // The identifier of the VPC that the AD Connector is in.
    string VpcId = 6;
}

message DirectoryDescription {
    // The access URL for the directory, such as <code>http://&lt;alias&gt;.awsapps.com</code>. If no alias has been created for the directory, <code>&lt;alias&gt;</code> is the directory identifier, such as <code>d-XXXXXXXXXX</code>.
    string AccessUrl = 1;
    // The alias for the directory. If no alias has been created for the directory, the alias is the directory identifier, such as <code>d-XXXXXXXXXX</code>.
    string Alias = 2;
    // A <a>DirectoryConnectSettingsDescription</a> object that contains additional information about an AD Connector directory. This member is only present if the directory is an AD Connector directory.
    DirectoryConnectSettingsDescription ConnectSettings = 3;
    // The textual description for the directory.
    string Description = 4;
    // The desired number of domain controllers in the directory if the directory is Microsoft AD.
    integer DesiredNumberOfDomainControllers = 5;
    // The directory identifier.
    string DirectoryId = 6;
    // The IP addresses of the DNS servers for the directory. For a Simple AD or Microsoft AD directory, these are the IP addresses of the Simple AD or Microsoft AD directory servers. For an AD Connector directory, these are the IP addresses of the DNS servers or domain controllers in the on-premises directory to which the AD Connector is connected.
    array DnsIpAddrs = 7;
    // Specifies when the directory was created.
    string LaunchTime = 8;
    // The fully-qualified name of the directory.
    string Name = 9;
    // A <a>RadiusSettings</a> object that contains information about the RADIUS server configured for this directory.
    RadiusSettings RadiusSettings = 10;
    // The status of the RADIUS MFA server connection.
    RadiusStatus RadiusStatus = 11;
    // The short name of the directory.
    string ShortName = 12;
    // The directory size.
    DirectorySize Size = 13;
    // Indicates if single-sign on is enabled for the directory. For more information, see <a>EnableSso</a> and <a>DisableSso</a>.
    boolean SsoEnabled = 14;
    // The current stage of the directory.
    DirectoryStage Stage = 15;
    // The date and time that the stage was last updated.
    string StageLastUpdatedDateTime = 16;
    // Additional information about the directory stage.
    string StageReason = 17;
    // The directory size.
    DirectoryType Type = 18;
    // A <a>DirectoryVpcSettingsDescription</a> object that contains additional information about a directory. This member is only present if the directory is a Simple AD or Managed AD directory.
    DirectoryVpcSettingsDescription VpcSettings = 19;
}

repeated DirectoryDescription DirectoryDescriptions = 1



repeated string DirectoryIds = 1

message DirectoryLimitExceededException {
    string Message = 1;
    string RequestId = 2;
}

message DirectoryLimits {
    // The current number of cloud directories in the region.
    integer CloudOnlyDirectoriesCurrentCount = 1;
    // The maximum number of cloud directories allowed in the region.
    integer CloudOnlyDirectoriesLimit = 2;
    // Indicates if the cloud directory limit has been reached.
    boolean CloudOnlyDirectoriesLimitReached = 3;
    // The current number of Microsoft AD directories in the region.
    integer CloudOnlyMicrosoftADCurrentCount = 4;
    // The maximum number of Microsoft AD directories allowed in the region.
    integer CloudOnlyMicrosoftADLimit = 5;
    // Indicates if the Microsoft AD directory limit has been reached.
    boolean CloudOnlyMicrosoftADLimitReached = 6;
    // The current number of connected directories in the region.
    integer ConnectedDirectoriesCurrentCount = 7;
    // The maximum number of connected directories allowed in the region.
    integer ConnectedDirectoriesLimit = 8;
    // Indicates if the connected directory limit has been reached.
    boolean ConnectedDirectoriesLimitReached = 9;
}

enum DirectorySize {
    SMALL = 0;
    LARGE = 1;
}

enum DirectoryStage {
    REQUESTED = 0;
    CREATING = 1;
    CREATED = 2;
    ACTIVE = 3;
    INOPERABLE = 4;
    IMPAIRED = 5;
    RESTORING = 6;
    RESTOREFAILED = 7;
    DELETING = 8;
    DELETED = 9;
    FAILED = 10;
}

enum DirectoryType {
    SIMPLEAD = 0;
    ADCONNECTOR = 1;
    MICROSOFTAD = 2;
}

message DirectoryUnavailableException {
    string Message = 1;
    string RequestId = 2;
}

message DirectoryVpcSettings {
    // The identifiers of the subnets for the directory servers. The two subnets must be in different Availability Zones. AWS Directory Service creates a directory server and a DNS server in each of these subnets.
    array SubnetIds = 1;
    // The identifier of the VPC in which to create the directory.
    string VpcId = 2;
}

message DirectoryVpcSettingsDescription {
    // The list of Availability Zones that the directory is in.
    array AvailabilityZones = 1;
    // The security group identifier for the directory. If the directory was created before 8/1/2014, this is the identifier of the directory members security group that was created when the directory was created. If the directory was created after this date, this value is null.
    string SecurityGroupId = 2;
    // The identifiers of the subnets for the directory servers.
    array SubnetIds = 3;
    // The identifier of the VPC that the directory is in.
    string VpcId = 4;
}

message DisableRadiusRequest {
    // The identifier of the directory for which to disable MFA.
    string DirectoryId = 1;
}

message DisableRadiusResult {
}

message DisableSsoRequest {
    // The identifier of the directory for which to disable single-sign on.
    string DirectoryId = 1;
    // The password of an alternate account to use to disable single-sign on. This is only used for AD Connector directories. For more information, see the <i>UserName</i> parameter.
    string Password = 2;
    // <p>The username of an alternate account to use to disable single-sign on. This is only used for AD Connector directories. This account must have privileges to remove a service principal name.</p> <p>If the AD Connector service account does not have privileges to remove a service principal name, you can specify an alternate account with the <i>UserName</i> and <i>Password</i> parameters. These credentials are only used to disable single sign-on and are not stored by the service. The AD Connector service account is not changed.</p>
    string UserName = 3;
}

message DisableSsoResult {
}

repeated string DnsIpAddrs = 1

message DomainController {
    // The Availability Zone where the domain controller is located.
    string AvailabilityZone = 1;
    // Identifier of the directory where the domain controller resides.
    string DirectoryId = 2;
    // The IP address of the domain controller.
    string DnsIpAddr = 3;
    // Identifies a specific domain controller in the directory.
    string DomainControllerId = 4;
    // Specifies when the domain controller was created.
    string LaunchTime = 5;
    // The status of the domain controller.
    DomainControllerStatus Status = 6;
    // The date and time that the status was last updated.
    string StatusLastUpdatedDateTime = 7;
    // A description of the domain controller state.
    string StatusReason = 8;
    // Identifier of the subnet in the VPC that contains the domain controller.
    string SubnetId = 9;
    // The identifier of the VPC that contains the domain controller.
    string VpcId = 10;
}



repeated string DomainControllerIds = 1

message DomainControllerLimitExceededException {
    string Message = 1;
    string RequestId = 2;
}

enum DomainControllerStatu {
    CREATING = 0;
    ACTIVE = 1;
    IMPAIRED = 2;
    RESTORING = 3;
    DELETING = 4;
    DELETED = 5;
    FAILED = 6;
}



repeated DomainController DomainControllers = 1

message EnableRadiusRequest {
    // The identifier of the directory for which to enable MFA.
    string DirectoryId = 1;
    // A <a>RadiusSettings</a> object that contains information about the RADIUS server.
    RadiusSettings RadiusSettings = 2;
}

message EnableRadiusResult {
}

message EnableSsoRequest {
    // The identifier of the directory for which to enable single-sign on.
    string DirectoryId = 1;
    // The password of an alternate account to use to enable single-sign on. This is only used for AD Connector directories. For more information, see the <i>UserName</i> parameter.
    string Password = 2;
    // <p>The username of an alternate account to use to enable single-sign on. This is only used for AD Connector directories. This account must have privileges to add a service principal name.</p> <p>If the AD Connector service account does not have privileges to add a service principal name, you can specify an alternate account with the <i>UserName</i> and <i>Password</i> parameters. These credentials are only used to enable single sign-on and are not stored by the service. The AD Connector service account is not changed.</p>
    string UserName = 3;
}

message EnableSsoResult {
}

message EntityAlreadyExistsException {
    string Message = 1;
    string RequestId = 2;
}

message EntityDoesNotExistException {
    string Message = 1;
    string RequestId = 2;
}

message EventTopic {
    // The date and time of when you associated your directory with the SNS topic.
    string CreatedDateTime = 1;
    // The Directory ID of an AWS Directory Service directory that will publish status messages to an SNS topic.
    string DirectoryId = 2;
    // The topic registration status.
    TopicStatus Status = 3;
    // The SNS topic ARN (Amazon Resource Name).
    string TopicArn = 4;
    // The name of an AWS SNS topic the receives status messages from the directory.
    string TopicName = 5;
}

repeated EventTopic EventTopics = 1



message GetDirectoryLimitsRequest {
}

message GetDirectoryLimitsResult {
    // A <a>DirectoryLimits</a> object that contains the directory limits for the current region.
    DirectoryLimits DirectoryLimits = 1;
}

message GetSnapshotLimitsRequest {
    // Contains the identifier of the directory to obtain the limits for.
    string DirectoryId = 1;
}

message GetSnapshotLimitsResult {
    // A <a>SnapshotLimits</a> object that contains the manual snapshot limits for the specified directory.
    SnapshotLimits SnapshotLimits = 1;
}

message InsufficientPermissionsException {
    string Message = 1;
    string RequestId = 2;
}

message InvalidNextTokenException {
    string Message = 1;
    string RequestId = 2;
}

message InvalidParameterException {
    string Message = 1;
    string RequestId = 2;
}



repeated string IpAddrs = 1

message IpRoute {
    // IP address block using CIDR format, for example 10.0.0.0/24. This is often the address block of the DNS server used for your on-premises domain. For a single IP address use a CIDR address block with /32. For example 10.0.0.0/32.
    string CidrIp = 1;
    // Description of the address block.
    string Description = 2;
}

message IpRouteInfo {
    // The date and time the address block was added to the directory.
    string AddedDateTime = 1;
    // IP address block in the <a>IpRoute</a>.
    string CidrIp = 2;
    // Description of the <a>IpRouteInfo</a>.
    string Description = 3;
    // Identifier (ID) of the directory associated with the IP addresses.
    string DirectoryId = 4;
    // The status of the IP address block.
    IpRouteStatusMsg IpRouteStatusMsg = 5;
    // The reason for the IpRouteStatusMsg.
    string IpRouteStatusReason = 6;
}

message IpRouteLimitExceededException {
    string Message = 1;
    string RequestId = 2;
}

enum IpRouteStatusMsg {
    ADDING = 0;
    ADDED = 1;
    REMOVING = 2;
    REMOVED = 3;
    ADDFAILED = 4;
    REMOVEFAILED = 5;
}



repeated IpRoute IpRoutes = 1

repeated IpRouteInfo IpRoutesInfo = 1









message ListIpRoutesRequest {
    // Identifier (ID) of the directory for which you want to retrieve the IP addresses.
    string DirectoryId = 1;
    // Maximum number of items to return. If this value is zero, the maximum number of items is specified by the limitations of the operation.
    integer Limit = 2;
    // The <i>ListIpRoutes.NextToken</i> value from a previous call to <a>ListIpRoutes</a>. Pass null if this is the first call.
    string NextToken = 3;
}

message ListIpRoutesResult {
    // A list of <a>IpRoute</a>s.
    array IpRoutesInfo = 1;
    // If not null, more results are available. Pass this value for the <i>NextToken</i> parameter in a subsequent call to <a>ListIpRoutes</a> to retrieve the next set of items.
    string NextToken = 2;
}

message ListSchemaExtensionsRequest {
    // The identifier of the directory from which to retrieve the schema extension information.
    string DirectoryId = 1;
    // The maximum number of items to return.
    integer Limit = 2;
    // The <code>ListSchemaExtensions.NextToken</code> value from a previous call to <code>ListSchemaExtensions</code>. Pass null if this is the first call.
    string NextToken = 3;
}

message ListSchemaExtensionsResult {
    // If not null, more results are available. Pass this value for the <code>NextToken</code> parameter in a subsequent call to <code>ListSchemaExtensions</code> to retrieve the next set of items.
    string NextToken = 1;
    // Information about the schema extensions applied to the directory.
    array SchemaExtensionsInfo = 2;
}

message ListTagsForResourceRequest {
    // Reserved for future use.
    integer Limit = 1;
    // Reserved for future use.
    string NextToken = 2;
    // Identifier (ID) of the directory for which you want to retrieve tags.
    string ResourceId = 3;
}

message ListTagsForResourceResult {
    // Reserved for future use.
    string NextToken = 1;
    // List of tags returned by the ListTagsForResource operation.
    array Tags = 2;
}

enum RadiusAuthenticationProtocol {
    PAP = 0;
    CHAP = 1;
    MSCHAPV1 = 2;
    MSCHAPV2 = 3;
}

message RadiusSettings {
    // The protocol specified for your RADIUS endpoints.
    RadiusAuthenticationProtocol AuthenticationProtocol = 1;
    // Not currently used.
    string DisplayLabel = 2;
    // The port that your RADIUS server is using for communications. Your on-premises network must allow inbound traffic over this port from the AWS Directory Service servers.
    integer RadiusPort = 3;
    // The maximum number of times that communication with the RADIUS server is attempted.
    integer RadiusRetries = 4;
    // An array of strings that contains the IP addresses of the RADIUS server endpoints, or the IP addresses of your RADIUS server load balancer.
    array RadiusServers = 5;
    // The amount of time, in seconds, to wait for the RADIUS server to respond.
    integer RadiusTimeout = 6;
    // Not currently used.
    string SharedSecret = 7;
    // Not currently used.
    boolean UseSameUsername = 8;
}

enum RadiusStatu {
    CREATING = 0;
    COMPLETED = 1;
    FAILED = 2;
}

message RegisterEventTopicRequest {
    // The Directory ID that will publish status messages to the SNS topic.
    string DirectoryId = 1;
    // The SNS topic name to which the directory will publish status messages. This SNS topic must be in the same region as the specified Directory ID.
    string TopicName = 2;
}

message RegisterEventTopicResult {
}



repeated string RemoteDomainNames = 1

message RemoveIpRoutesRequest {
    // IP address blocks that you want to remove.
    array CidrIps = 1;
    // Identifier (ID) of the directory from which you want to remove the IP addresses.
    string DirectoryId = 2;
}

message RemoveIpRoutesResult {
}

message RemoveTagsFromResourceRequest {
    // Identifier (ID) of the directory from which to remove the tag.
    string ResourceId = 1;
    // The tag key (name) of the tag to be removed.
    array TagKeys = 2;
}

message RemoveTagsFromResourceResult {
}

enum ReplicationScope {
    DOMAIN = 0;
}

message RestoreFromSnapshotRequest {
    // The identifier of the snapshot to restore from.
    string SnapshotId = 1;
}

message RestoreFromSnapshotResult {
}

message SchemaExtensionInfo {
    // A description of the schema extension.
    string Description = 1;
    // The identifier of the directory to which the schema extension is applied.
    string DirectoryId = 2;
    // The date and time that the schema extension was completed.
    string EndDateTime = 3;
    // The identifier of the schema extension.
    string SchemaExtensionId = 4;
    // The current status of the schema extension.
    SchemaExtensionStatus SchemaExtensionStatus = 5;
    // The reason for the <code>SchemaExtensionStatus</code>.
    string SchemaExtensionStatusReason = 6;
    // The date and time that the schema extension started being applied to the directory.
    string StartDateTime = 7;
}

enum SchemaExtensionStatu {
    INITIALIZING = 0;
    CREATINGSNAPSHOT = 1;
    UPDATINGSCHEMA = 2;
    REPLICATING = 3;
    CANCELINPROGRESS = 4;
    ROLLBACKINPROGRESS = 5;
    CANCELLED = 6;
    FAILED = 7;
    COMPLETED = 8;
}



repeated SchemaExtensionInfo SchemaExtensionsInfo = 1





repeated string Servers = 1

message ServiceException {
    string Message = 1;
    string RequestId = 2;
}

message Snapshot {
    // The directory identifier.
    string DirectoryId = 1;
    // The descriptive name of the snapshot.
    string Name = 2;
    // The snapshot identifier.
    string SnapshotId = 3;
    // The date and time that the snapshot was taken.
    string StartTime = 4;
    // The snapshot status.
    SnapshotStatus Status = 5;
    // The snapshot type.
    SnapshotType Type = 6;
}



repeated string SnapshotIds = 1

message SnapshotLimitExceededException {
    string Message = 1;
    string RequestId = 2;
}

message SnapshotLimits {
    // The current number of manual snapshots of the directory.
    integer ManualSnapshotsCurrentCount = 1;
    // The maximum number of manual snapshots allowed.
    integer ManualSnapshotsLimit = 2;
    // Indicates if the manual snapshot limit has been reached.
    boolean ManualSnapshotsLimitReached = 3;
}

enum SnapshotStatu {
    CREATING = 0;
    COMPLETED = 1;
    FAILED = 2;
}

enum SnapshotType {
    AUTO = 0;
    MANUAL = 1;
}

repeated Snapshot Snapshots = 1







message StartSchemaExtensionRequest {
    // If true, creates a snapshot of the directory before applying the schema extension.
    boolean CreateSnapshotBeforeSchemaExtension = 1;
    // A description of the schema extension.
    string Description = 2;
    // The identifier of the directory for which the schema extension will be applied to.
    string DirectoryId = 3;
    // The LDIF file represented as a string. To construct the LdifContent string, precede each line as it would be formatted in an ldif file with \n. See the example request below for more details. The file size can be no larger than 1MB.
    string LdifContent = 4;
}

message StartSchemaExtensionResult {
    // The identifier of the schema extension that will be applied.
    string SchemaExtensionId = 1;
}







repeated string SubnetIds = 1

message Tag {
    // Required name of the tag. The string value can be Unicode characters and cannot be prefixed with "aws:". The string can contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
    string Key = 1;
    // The optional value of the tag. The string value can be Unicode characters. The string can contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
    string Value = 2;
}



repeated string TagKeys = 1

message TagLimitExceededException {
    string Message = 1;
    string RequestId = 2;
}



repeated Tag Tags = 1





repeated string TopicNames = 1

enum TopicStatu {
    REGISTERED = 0;
    TOPIC_NOT_FOUND = 1;
    FAILED = 2;
    DELETED = 3;
}

message Trust {
    // The date and time that the trust relationship was created.
    string CreatedDateTime = 1;
    // The Directory ID of the AWS directory involved in the trust relationship.
    string DirectoryId = 2;
    // The date and time that the trust relationship was last updated.
    string LastUpdatedDateTime = 3;
    // The Fully Qualified Domain Name (FQDN) of the external domain involved in the trust relationship.
    string RemoteDomainName = 4;
    // The date and time that the TrustState was last updated.
    string StateLastUpdatedDateTime = 5;
    // The trust relationship direction.
    TrustDirection TrustDirection = 6;
    // The unique ID of the trust relationship.
    string TrustId = 7;
    // The trust relationship state.
    TrustState TrustState = 8;
    // The reason for the TrustState.
    string TrustStateReason = 9;
    // The trust relationship type.
    TrustType TrustType = 10;
}

enum TrustDirection {
    ONEWAY:_OUTGOING = 0;
    ONEWAY:_INCOMING = 1;
    TWOWAY = 2;
}



repeated string TrustIds = 1



enum TrustState {
    CREATING = 0;
    CREATED = 1;
    VERIFYING = 2;
    VERIFYFAILED = 3;
    VERIFIED = 4;
    DELETING = 5;
    DELETED = 6;
    FAILED = 7;
}

enum TrustType {
    FOREST = 0;
}

repeated Trust Trusts = 1

message UnsupportedOperationException {
    string Message = 1;
    string RequestId = 2;
}

message UpdateConditionalForwarderRequest {
    // The directory ID of the AWS directory for which to update the conditional forwarder.
    string DirectoryId = 1;
    // The updated IP addresses of the remote DNS server associated with the conditional forwarder.
    array DnsIpAddrs = 2;
    // The fully qualified domain name (FQDN) of the remote domain with which you will set up a trust relationship.
    string RemoteDomainName = 3;
}

message UpdateConditionalForwarderResult {
}

message UpdateNumberOfDomainControllersRequest {
    // The number of domain controllers desired in the directory.
    integer DesiredNumber = 1;
    // Identifier of the directory to which the domain controllers will be added or removed.
    string DirectoryId = 2;
}

message UpdateNumberOfDomainControllersResult {
}

message UpdateRadiusRequest {
    // The identifier of the directory for which to update the RADIUS server information.
    string DirectoryId = 1;
    // A <a>RadiusSettings</a> object that contains information about the RADIUS server.
    RadiusSettings RadiusSettings = 2;
}

message UpdateRadiusResult {
}

message VerifyTrustRequest {
    // The unique Trust ID of the trust relationship to verify.
    string TrustId = 1;
}

message VerifyTrustResult {
    // The unique Trust ID of the trust relationship that was verified.
    string TrustId = 1;
}

service AWSDirectoryServiceService {
    // <p>If the DNS server for your on-premises domain uses a publicly addressable IP address, you must add a CIDR address block to correctly route traffic to and from your Microsoft AD on Amazon Web Services. <i>AddIpRoutes</i> adds this address block. You can also use <i>AddIpRoutes</i> to facilitate routing traffic that uses public IP ranges from your Microsoft AD on AWS to a peer VPC. </p> <p>Before you call <i>AddIpRoutes</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>AddIpRoutes</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
    rpc Post(PostRequest) returns (AddIpRoutesResult) {
      option (google.api.http) = {
        post: "//"
        body: "body"
      };
    }
    // Adds or overwrites one or more tags for the specified directory. Each directory can have a maximum of 50 tags. Each tag consists of a key and optional value. Tag keys must be unique to each resource.
    rpc Post#AddTagsToResource(Post#AddTagsToResourceRequest) returns (AddTagsToResourceResult) {
      option (google.api.http) = {
        post: "//#AddTagsToResource"
        body: "body"
      };
    }
    // Cancels an in-progress schema extension to a Microsoft AD directory. Once a schema extension has started replicating to all domain controllers, the task can no longer be canceled. A schema extension can be canceled during any of the following states; <code>Initializing</code>, <code>CreatingSnapshot</code>, and <code>UpdatingSchema</code>.
    rpc Post#CancelSchemaExtension(Post#CancelSchemaExtensionRequest) returns (CancelSchemaExtensionResult) {
      option (google.api.http) = {
        post: "//#CancelSchemaExtension"
        body: "body"
      };
    }
    // <p>Creates an AD Connector to connect to an on-premises directory.</p> <p>Before you call <i>ConnectDirectory</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>ConnectDirectory</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
    rpc Post#ConnectDirectory(Post#ConnectDirectoryRequest) returns (ConnectDirectoryResult) {
      option (google.api.http) = {
        post: "//#ConnectDirectory"
        body: "body"
      };
    }
    // <p>Creates an alias for a directory and assigns the alias to the directory. The alias is used to construct the access URL for the directory, such as <code>http://&lt;alias&gt;.awsapps.com</code>.</p> <important> <p>After an alias has been created, it cannot be deleted or reused, so this operation should only be used when absolutely necessary.</p> </important>
    rpc Post#CreateAlias(Post#CreateAliasRequest) returns (CreateAliasResult) {
      option (google.api.http) = {
        post: "//#CreateAlias"
        body: "body"
      };
    }
    // Creates a computer account in the specified directory, and joins the computer to the directory.
    rpc Post#CreateComputer(Post#CreateComputerRequest) returns (CreateComputerResult) {
      option (google.api.http) = {
        post: "//#CreateComputer"
        body: "body"
      };
    }
    // Creates a conditional forwarder associated with your AWS directory. Conditional forwarders are required in order to set up a trust relationship with another domain. The conditional forwarder points to the trusted domain.
    rpc Post#CreateConditionalForwarder(Post#CreateConditionalForwarderRequest) returns (CreateConditionalForwarderResult) {
      option (google.api.http) = {
        post: "//#CreateConditionalForwarder"
        body: "body"
      };
    }
    // <p>Creates a Simple AD directory.</p> <p>Before you call <i>CreateDirectory</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>CreateDirectory</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
    rpc Post#CreateDirectory(Post#CreateDirectoryRequest) returns (CreateDirectoryResult) {
      option (google.api.http) = {
        post: "//#CreateDirectory"
        body: "body"
      };
    }
    // <p>Creates a Microsoft AD in the AWS cloud.</p> <p>Before you call <i>CreateMicrosoftAD</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>CreateMicrosoftAD</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
    rpc Post#CreateMicrosoftAD(Post#CreateMicrosoftADRequest) returns (CreateMicrosoftADResult) {
      option (google.api.http) = {
        post: "//#CreateMicrosoftAD"
        body: "body"
      };
    }
    // <p>Creates a snapshot of a Simple AD or Microsoft AD directory in the AWS cloud.</p> <note> <p>You cannot take snapshots of AD Connector directories.</p> </note>
    rpc Post#CreateSnapshot(Post#CreateSnapshotRequest) returns (CreateSnapshotResult) {
      option (google.api.http) = {
        post: "//#CreateSnapshot"
        body: "body"
      };
    }
    // <p>AWS Directory Service for Microsoft Active Directory allows you to configure trust relationships. For example, you can establish a trust between your Microsoft AD in the AWS cloud, and your existing on-premises Microsoft Active Directory. This would allow you to provide users and groups access to resources in either domain, with a single set of credentials.</p> <p>This action initiates the creation of the AWS side of a trust relationship between a Microsoft AD in the AWS cloud and an external domain.</p>
    rpc Post#CreateTrust(Post#CreateTrustRequest) returns (CreateTrustResult) {
      option (google.api.http) = {
        post: "//#CreateTrust"
        body: "body"
      };
    }
    // Deletes a conditional forwarder that has been set up for your AWS directory.
    rpc Post#DeleteConditionalForwarder(Post#DeleteConditionalForwarderRequest) returns (DeleteConditionalForwarderResult) {
      option (google.api.http) = {
        post: "//#DeleteConditionalForwarder"
        body: "body"
      };
    }
    // <p>Deletes an AWS Directory Service directory.</p> <p>Before you call <i>DeleteDirectory</i>, ensure that all of the required permissions have been explicitly granted through a policy. For details about what permissions are required to run the <i>DeleteDirectory</i> operation, see <a href="http://docs.aws.amazon.com/directoryservice/latest/admin-guide/UsingWithDS_IAM_ResourcePermissions.html">AWS Directory Service API Permissions: Actions, Resources, and Conditions Reference</a>.</p>
    rpc Post#DeleteDirectory(Post#DeleteDirectoryRequest) returns (DeleteDirectoryResult) {
      option (google.api.http) = {
        post: "//#DeleteDirectory"
        body: "body"
      };
    }
    // Deletes a directory snapshot.
    rpc Post#DeleteSnapshot(Post#DeleteSnapshotRequest) returns (DeleteSnapshotResult) {
      option (google.api.http) = {
        post: "//#DeleteSnapshot"
        body: "body"
      };
    }
    // Deletes an existing trust relationship between your Microsoft AD in the AWS cloud and an external domain.
    rpc Post#DeleteTrust(Post#DeleteTrustRequest) returns (DeleteTrustResult) {
      option (google.api.http) = {
        post: "//#DeleteTrust"
        body: "body"
      };
    }
    // Removes the specified directory as a publisher to the specified SNS topic.
    rpc Post#DeregisterEventTopic(Post#DeregisterEventTopicRequest) returns (DeregisterEventTopicResult) {
      option (google.api.http) = {
        post: "//#DeregisterEventTopic"
        body: "body"
      };
    }
    // <p>Obtains information about the conditional forwarders for this account.</p> <p>If no input parameters are provided for RemoteDomainNames, this request describes all conditional forwarders for the specified directory ID.</p>
    rpc Post#DescribeConditionalForwarders(Post#DescribeConditionalForwardersRequest) returns (DescribeConditionalForwardersResult) {
      option (google.api.http) = {
        post: "//#DescribeConditionalForwarders"
        body: "body"
      };
    }
    // <p>Obtains information about the directories that belong to this account.</p> <p>You can retrieve information about specific directories by passing the directory identifiers in the <i>DirectoryIds</i> parameter. Otherwise, all directories that belong to the current account are returned.</p> <p>This operation supports pagination with the use of the <i>NextToken</i> request and response parameters. If more results are available, the <i>DescribeDirectoriesResult.NextToken</i> member contains a token that you pass in the next call to <a>DescribeDirectories</a> to retrieve the next set of items.</p> <p>You can also specify a maximum number of return results with the <i>Limit</i> parameter.</p>
    rpc Post#DescribeDirectories(Post#DescribeDirectoriesRequest) returns (DescribeDirectoriesResult) {
      option (google.api.http) = {
        post: "//#DescribeDirectories"
        body: "body"
      };
    }
    // Provides information about any domain controllers in your directory.
    rpc Post#DescribeDomainControllers(Post#DescribeDomainControllersRequest) returns (DescribeDomainControllersResult) {
      option (google.api.http) = {
        post: "//#DescribeDomainControllers"
        body: "body"
      };
    }
    // <p>Obtains information about which SNS topics receive status messages from the specified directory.</p> <p>If no input parameters are provided, such as DirectoryId or TopicName, this request describes all of the associations in the account.</p>
    rpc Post#DescribeEventTopics(Post#DescribeEventTopicsRequest) returns (DescribeEventTopicsResult) {
      option (google.api.http) = {
        post: "//#DescribeEventTopics"
        body: "body"
      };
    }
    // <p>Obtains information about the directory snapshots that belong to this account.</p> <p>This operation supports pagination with the use of the <i>NextToken</i> request and response parameters. If more results are available, the <i>DescribeSnapshots.NextToken</i> member contains a token that you pass in the next call to <a>DescribeSnapshots</a> to retrieve the next set of items.</p> <p>You can also specify a maximum number of return results with the <i>Limit</i> parameter.</p>
    rpc Post#DescribeSnapshots(Post#DescribeSnapshotsRequest) returns (DescribeSnapshotsResult) {
      option (google.api.http) = {
        post: "//#DescribeSnapshots"
        body: "body"
      };
    }
    // <p>Obtains information about the trust relationships for this account.</p> <p>If no input parameters are provided, such as DirectoryId or TrustIds, this request describes all the trust relationships belonging to the account.</p>
    rpc Post#DescribeTrusts(Post#DescribeTrustsRequest) returns (DescribeTrustsResult) {
      option (google.api.http) = {
        post: "//#DescribeTrusts"
        body: "body"
      };
    }
    // Disables multi-factor authentication (MFA) with the Remote Authentication Dial In User Service (RADIUS) server for an AD Connector directory.
    rpc Post#DisableRadius(Post#DisableRadiusRequest) returns (DisableRadiusResult) {
      option (google.api.http) = {
        post: "//#DisableRadius"
        body: "body"
      };
    }
    // Disables single-sign on for a directory.
    rpc Post#DisableSso(Post#DisableSsoRequest) returns (DisableSsoResult) {
      option (google.api.http) = {
        post: "//#DisableSso"
        body: "body"
      };
    }
    // Enables multi-factor authentication (MFA) with the Remote Authentication Dial In User Service (RADIUS) server for an AD Connector directory.
    rpc Post#EnableRadius(Post#EnableRadiusRequest) returns (EnableRadiusResult) {
      option (google.api.http) = {
        post: "//#EnableRadius"
        body: "body"
      };
    }
    // Enables single sign-on for a directory.
    rpc Post#EnableSso(Post#EnableSsoRequest) returns (EnableSsoResult) {
      option (google.api.http) = {
        post: "//#EnableSso"
        body: "body"
      };
    }
    // Obtains directory limit information for the current region.
    rpc Post#GetDirectoryLimits(Post#GetDirectoryLimitsRequest) returns (GetDirectoryLimitsResult) {
      option (google.api.http) = {
        post: "//#GetDirectoryLimits"
        body: "body"
      };
    }
    // Obtains the manual snapshot limits for a directory.
    rpc Post#GetSnapshotLimits(Post#GetSnapshotLimitsRequest) returns (GetSnapshotLimitsResult) {
      option (google.api.http) = {
        post: "//#GetSnapshotLimits"
        body: "body"
      };
    }
    // Lists the address blocks that you have added to a directory.
    rpc Post#ListIpRoutes(Post#ListIpRoutesRequest) returns (ListIpRoutesResult) {
      option (google.api.http) = {
        post: "//#ListIpRoutes"
        body: "body"
      };
    }
    // Lists all schema extensions applied to a Microsoft AD Directory.
    rpc Post#ListSchemaExtensions(Post#ListSchemaExtensionsRequest) returns (ListSchemaExtensionsResult) {
      option (google.api.http) = {
        post: "//#ListSchemaExtensions"
        body: "body"
      };
    }
    // Lists all tags on a directory.
    rpc Post#ListTagsForResource(Post#ListTagsForResourceRequest) returns (ListTagsForResourceResult) {
      option (google.api.http) = {
        post: "//#ListTagsForResource"
        body: "body"
      };
    }
    // Associates a directory with an SNS topic. This establishes the directory as a publisher to the specified SNS topic. You can then receive email or text (SMS) messages when the status of your directory changes. You get notified if your directory goes from an Active status to an Impaired or Inoperable status. You also receive a notification when the directory returns to an Active status.
    rpc Post#RegisterEventTopic(Post#RegisterEventTopicRequest) returns (RegisterEventTopicResult) {
      option (google.api.http) = {
        post: "//#RegisterEventTopic"
        body: "body"
      };
    }
    // Removes IP address blocks from a directory.
    rpc Post#RemoveIpRoutes(Post#RemoveIpRoutesRequest) returns (RemoveIpRoutesResult) {
      option (google.api.http) = {
        post: "//#RemoveIpRoutes"
        body: "body"
      };
    }
    // Removes tags from a directory.
    rpc Post#RemoveTagsFromResource(Post#RemoveTagsFromResourceRequest) returns (RemoveTagsFromResourceResult) {
      option (google.api.http) = {
        post: "//#RemoveTagsFromResource"
        body: "body"
      };
    }
    // <p>Restores a directory using an existing directory snapshot.</p> <p>When you restore a directory from a snapshot, any changes made to the directory after the snapshot date are overwritten.</p> <p>This action returns as soon as the restore operation is initiated. You can monitor the progress of the restore operation by calling the <a>DescribeDirectories</a> operation with the directory identifier. When the <b>DirectoryDescription.Stage</b> value changes to <code>Active</code>, the restore operation is complete.</p>
    rpc Post#RestoreFromSnapshot(Post#RestoreFromSnapshotRequest) returns (RestoreFromSnapshotResult) {
      option (google.api.http) = {
        post: "//#RestoreFromSnapshot"
        body: "body"
      };
    }
    // Applies a schema extension to a Microsoft AD directory.
    rpc Post#StartSchemaExtension(Post#StartSchemaExtensionRequest) returns (StartSchemaExtensionResult) {
      option (google.api.http) = {
        post: "//#StartSchemaExtension"
        body: "body"
      };
    }
    // Updates a conditional forwarder that has been set up for your AWS directory.
    rpc Post#UpdateConditionalForwarder(Post#UpdateConditionalForwarderRequest) returns (UpdateConditionalForwarderResult) {
      option (google.api.http) = {
        post: "//#UpdateConditionalForwarder"
        body: "body"
      };
    }
    // Adds or removes domain controllers to or from the directory. Based on the difference between current value and new value (provided through this API call), domain controllers will be added or removed. It may take up to 45 minutes for any new domain controllers to become fully active once the requested number of domain controllers is updated. During this time, you cannot make another update request.
    rpc Post#UpdateNumberOfDomainControllers(Post#UpdateNumberOfDomainControllersRequest) returns (UpdateNumberOfDomainControllersResult) {
      option (google.api.http) = {
        post: "//#UpdateNumberOfDomainControllers"
        body: "body"
      };
    }
    // Updates the Remote Authentication Dial In User Service (RADIUS) server information for an AD Connector directory.
    rpc Post#UpdateRadius(Post#UpdateRadiusRequest) returns (UpdateRadiusResult) {
      option (google.api.http) = {
        post: "//#UpdateRadius"
        body: "body"
      };
    }
    // <p>AWS Directory Service for Microsoft Active Directory allows you to configure and verify trust relationships.</p> <p>This action verifies a trust relationship between your Microsoft AD in the AWS cloud and an external domain.</p>
    rpc Post#VerifyTrust(Post#VerifyTrustRequest) returns (VerifyTrustResult) {
      option (google.api.http) = {
        post: "//#VerifyTrust"
        body: "body"
      };
    }
}
