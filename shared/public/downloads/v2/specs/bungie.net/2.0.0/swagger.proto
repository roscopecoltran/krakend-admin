syntax = "proto3";

import "google/protobuf/empty.proto";

import "google/api/annotations.proto";

package bungie.net;

message GetCommunityContentGetSortMediaFilterPageRequest {
    // The type of media to get
    int32 mediaFilter = 1;
    // Zero based page
    int32 page = 2;
    // The sort mode.
    byte sort = 3;
}

message GetCommunityContentGetSortMediaFilterPageResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetCommunityContentLiveAllPartnershipTypeSortPageRequest {
    // The hash of the Activity Mode for which streams should be retrieved. Don't pass it in or pass 0 to not filter by mode.
    uint32 modeHash = 1;
    // Zero based page.
    int32 page = 2;
    // The type of partnership for which the status should be returned.
    int32 partnershipType = 3;
    // The sort mode.
    int32 sort = 4;
    // The locale for streams you'd like to see. Don't pass this to fall back on your BNet locale. Pass 'ALL' to not filter by locale.
    string streamLocale = 5;
}

message GetCommunityContentLiveAllPartnershipTypeSortPageResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfCommunityLiveStatus Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetCommunityContentLiveClanPartnershipTypeSortPageRequest {
    // Zero based page.
    int32 page = 1;
    // The type of partnership for which the status should be returned.
    int32 partnershipType = 2;
    // The sort mode.
    int32 sort = 3;
}

message GetCommunityContentLiveClanPartnershipTypeSortPageResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfCommunityLiveStatus Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetCommunityContentLiveFeaturedPartnershipTypeSortPageRequest {
    // Zero based page.
    int32 page = 1;
    // The type of partnership for which the status should be returned.
    int32 partnershipType = 2;
    // The sort mode.
    int32 sort = 3;
    // The locale for streams you'd like to see. Don't pass this to fall back on your BNet locale. Pass 'ALL' to not filter by locale.
    string streamLocale = 4;
}

message GetCommunityContentLiveFeaturedPartnershipTypeSortPageResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfCommunityLiveStatus Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetCommunityContentLiveFriendsPartnershipTypeSortPageRequest {
    // Zero based page.
    int32 page = 1;
    // The type of partnership for which the status should be returned.
    int32 partnershipType = 2;
    // The sort mode.
    int32 sort = 3;
}

message GetCommunityContentLiveFriendsPartnershipTypeSortPageResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfCommunityLiveStatus Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetCommunityContentLiveUsersPartnershipTypeMembershipTypeMembershipIdRequest {
    // The membershipId related to that type.
    int64 membershipId = 1;
    // The type of account for which info will be extracted.
    int32 membershipType = 2;
    // The type of partnership for which info will be extracted.
    int32 partnershipType = 3;
}

message GetCommunityContentLiveUsersPartnershipTypeMembershipTypeMembershipIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Community.CommunityLiveStatus Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostDestiny2ActionsItemsActivateTalentNodeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostDestiny2ActionsItemsEquipItemResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostDestiny2ActionsItemsEquipItemsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.DestinyEquipItemResults Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostDestiny2ActionsItemsInsertSocketPlugResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostDestiny2ActionsItemsSetLockStateResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostDestiny2ActionsItemsTransferItemResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2ArmorySearchTypeSearchTermRequest {
    // Page number to return, starting with 0.
    int32 page = 1;
    // The string to use when searching for Destiny entities.
    string searchTerm = 2;
    // The type of entity for whom you would like results. These correspond to the entity's definition contract name. For instance, if you are looking for items, this property should be 'DestinyInventoryItemDefinition'. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation.
    string type = 3;
}

message GetDestiny2ArmorySearchTypeSearchTermResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Definitions.DestinyEntitySearchResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2ClanGroupIdWeeklyRewardStateRequest {
    // A valid group id of clan.
    int64 groupId = 1;
}

message GetDestiny2ClanGroupIdWeeklyRewardStateResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Milestones.DestinyMilestone Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2ManifestResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Config.DestinyManifest Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2ManifestEntityTypeHashIdentifierRequest {
    // The type of entity for whom you would like results. These correspond to the entity's definition contract name. For instance, if you are looking for items, this property should be 'DestinyInventoryItemDefinition'. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation.
    string entityType = 1;
    // The hash identifier for the specific Entity you want returned.
    uint32 hashIdentifier = 2;
}

message GetDestiny2ManifestEntityTypeHashIdentifierResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Definitions.DestinyDefinition Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MilestonesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, Destiny.Milestones.DestinyPublicMilestone> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MilestonesMilestoneHashContentRequest {
    // The identifier for the milestone to be returned.
    uint32 milestoneHash = 1;
}

message GetDestiny2MilestonesMilestoneHashContentResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Milestones.DestinyMilestoneContent Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2SearchDestinyPlayerMembershipTypeDisplayNameRequest {
    // The full gamertag or PSN id of the player. Spaces and case are ignored.
    string displayName = 1;
    // A valid non-BungieNet membership type, or All.
    int32 membershipType = 2;
}

message GetDestiny2SearchDestinyPlayerMembershipTypeDisplayNameResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated User.UserInfoCard Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2StatsAggregateClanStatsGroupIdRequest {
    // Group ID of the clan whose leaderboards you wish to fetch.
    int64 groupId = 1;
    // List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.
    string modes = 2;
}

message GetDestiny2StatsAggregateClanStatsGroupIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Destiny.HistoricalStats.DestinyClanAggregateStat Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2StatsDefinitionResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, Destiny.HistoricalStats.Definitions.DestinyHistoricalStatsDefinition> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2StatsLeaderboardsClansGroupIdRequest {
    // Group ID of the clan whose leaderboards you wish to fetch.
    int64 groupId = 1;
    // Maximum number of top players to return. Use a large number to get entire leaderboard.
    int32 maxtop = 2;
    // List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.
    string modes = 3;
    // ID of stat to return rather than returning all Leaderboard stats.
    string statid = 4;
}

message GetDestiny2StatsLeaderboardsClansGroupIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, object> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2StatsLeaderboardsMembershipTypeDestinyMembershipIdCharacterIdRequest {
    // The specific character to build the leaderboard around for the provided Destiny Membership.
    int64 characterId = 1;
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 2;
    // Maximum number of top players to return. Use a large number to get entire leaderboard.
    int32 maxtop = 3;
    // A valid non-BungieNet membership type.
    int32 membershipType = 4;
    // List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.
    string modes = 5;
    // ID of stat to return rather than returning all Leaderboard stats.
    string statid = 6;
}

message GetDestiny2StatsLeaderboardsMembershipTypeDestinyMembershipIdCharacterIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, object> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2StatsPostGameCarnageReportActivityIdRequest {
    // The ID of the activity whose PGCR is requested.
    int64 activityId = 1;
}

message GetDestiny2StatsPostGameCarnageReportActivityIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.HistoricalStats.DestinyPostGameCarnageReportData Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsRequest {
    // The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters.
    int64 characterId = 1;
    // Last day to return when daily stats are requested. Use the format YYYY-MM-DD.
    string dayend = 2;
    // First day to return when daily stats are requested. Use the format YYYY-MM-DD
    string daystart = 3;
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 4;
    // Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals
    repeated integer groups = 5;
    // A valid non-BungieNet membership type.
    int32 membershipType = 6;
    // Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.
    repeated integer modes = 7;
    // Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity
    int32 periodType = 8;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsActivitiesRequest {
    // The id of the character to retrieve.
    int64 characterId = 1;
    // Number of rows to return
    int32 count = 2;
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 3;
    // A valid non-BungieNet membership type.
    int32 membershipType = 4;
    // A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation.
    int32 mode = 5;
    // Page number to return, starting with 0.
    int32 page = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsActivitiesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.HistoricalStats.DestinyActivityHistoryResults Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsAggregateActivityStatsRequest {
    // The specific character whose activities should be returned.
    int64 characterId = 1;
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 2;
    // A valid non-BungieNet membership type.
    int32 membershipType = 3;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsAggregateActivityStatsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.HistoricalStats.DestinyAggregateActivityResults Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsUniqueWeaponsRequest {
    // The id of the character to retrieve.
    int64 characterId = 1;
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 2;
    // A valid non-BungieNet membership type.
    int32 membershipType = 3;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsUniqueWeaponsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.HistoricalStats.DestinyHistoricalWeaponStatsData Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsRequest {
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 1;
    // Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals.
    repeated integer groups = 2;
    // A valid non-BungieNet membership type.
    int32 membershipType = 3;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.HistoricalStats.DestinyHistoricalStatsAccountResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsLeaderboardsRequest {
    // The Destiny membershipId of the user to retrieve.
    int64 destinyMembershipId = 1;
    // Maximum number of top players to return. Use a large number to get entire leaderboard.
    int32 maxtop = 2;
    // A valid non-BungieNet membership type.
    int32 membershipType = 3;
    // List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.
    string modes = 4;
    // ID of stat to return rather than returning all Leaderboard stats.
    string statid = 5;
}

message GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsLeaderboardsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, object> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdRequest {
    // A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.
    repeated integer components = 1;
    // Destiny membership ID.
    int64 destinyMembershipId = 2;
    // A valid non-BungieNet membership type.
    int32 membershipType = 3;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Responses.DestinyProfileResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdRequest {
    // ID of the character.
    int64 characterId = 1;
    // A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.
    repeated integer components = 2;
    // Destiny membership ID.
    int64 destinyMembershipId = 3;
    // A valid non-BungieNet membership type.
    int32 membershipType = 4;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Responses.DestinyCharacterResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsRequest {
    // The Destiny Character ID of the character for whom we're getting vendor info.
    int64 characterId = 1;
    // A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.
    repeated integer components = 2;
    // Destiny membership ID of another user. You may be denied.
    int64 destinyMembershipId = 3;
    // A valid non-BungieNet membership type.
    int32 membershipType = 4;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Destiny.Responses.DestinyVendorResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsVendorHashRequest {
    // The Destiny Character ID of the character for whom we're getting vendor info.
    int64 characterId = 1;
    // A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.
    repeated integer components = 2;
    // Destiny membership ID of another user. You may be denied.
    int64 destinyMembershipId = 3;
    // A valid non-BungieNet membership type.
    int32 membershipType = 4;
    // The Hash identifier of the Vendor to be returned.
    uint32 vendorHash = 5;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsVendorHashResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Responses.DestinyVendorResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdItemItemInstanceIdRequest {
    // A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.
    repeated integer components = 1;
    // The membership ID of the destiny profile.
    int64 destinyMembershipId = 2;
    // The Instance ID of the destiny item.
    int64 itemInstanceId = 3;
    // A valid non-BungieNet membership type.
    int32 membershipType = 4;
}

message GetDestiny2MembershipTypeProfileDestinyMembershipIdItemItemInstanceIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Destiny.Responses.DestinyItemResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetCoreTopicsPagedPageSortQuickDateCategoryFilterRequest {
    // The category filter.
    int32 categoryFilter = 1;
    // Comma seperated list of locales posts must match to return in the result list. Default 'en'
    string locales = 2;
    // Zero base page
    int32 page = 3;
    // The date filter.
    int32 quickDate = 4;
    // The sort mode.
    byte sort = 5;
}

message GetForumGetCoreTopicsPagedPageSortQuickDateCategoryFilterResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetForumTagSuggestionsRequest {
    // The partial tag input to generate suggestions from.
    string partialtag = 1;
}

message GetForumGetForumTagSuggestionsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Tags.Models.Contracts.TagResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetPostAndParentChildPostIdRequest {
    uint64 childPostId = 1;
    // If this value is not null or empty, banned posts are requested to be returned
    string showbanned = 2;
}

message GetForumGetPostAndParentChildPostIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetPostAndParentAwaitingApprovalChildPostIdRequest {
    uint64 childPostId = 1;
    // If this value is not null or empty, banned posts are requested to be returned
    string showbanned = 2;
}

message GetForumGetPostAndParentAwaitingApprovalChildPostIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetPostsThreadedPagedParentPostIdPagePageSizeReplySizeGetParentPostRootThreadModeSortModeRequest {
    bool getParentPost = 1;
    int32 page = 2;
    int32 pageSize = 3;
    uint64 parentPostId = 4;
    int32 replySize = 5;
    bool rootThreadMode = 6;
    // If this value is not null or empty, banned posts are requested to be returned
    string showbanned = 7;
    int32 sortMode = 8;
}

message GetForumGetPostsThreadedPagedParentPostIdPagePageSizeReplySizeGetParentPostRootThreadModeSortModeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetPostsThreadedPagedFromChildChildPostIdPagePageSizeReplySizeRootThreadModeSortModeRequest {
    uint64 childPostId = 1;
    int32 page = 2;
    int32 pageSize = 3;
    int32 replySize = 4;
    bool rootThreadMode = 5;
    // If this value is not null or empty, banned posts are requested to be returned
    string showbanned = 6;
    int32 sortMode = 7;
}

message GetForumGetPostsThreadedPagedFromChildChildPostIdPagePageSizeReplySizeRootThreadModeSortModeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetTopicForContentContentIdRequest {
    int64 contentId = 1;
}

message GetForumGetTopicForContentContentIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int64 Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumGetTopicsPagedPagePageSizeGroupSortQuickDateCategoryFilterRequest {
    // A category filter
    int32 categoryFilter = 1;
    // The group, if any.
    int64 group = 2;
    // Comma seperated list of locales posts must match to return in the result list. Default 'en'
    string locales = 3;
    // Zero paged page number
    int32 page = 4;
    // Unused
    int32 pageSize = 5;
    // A date filter.
    int32 quickDate = 6;
    // The sort mode.
    byte sort = 7;
    // The tags to search, if any.
    string tagstring = 8;
}

message GetForumGetTopicsPagedPagePageSizeGroupSortQuickDateCategoryFilterResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetForumPollTopicIdRequest {
    // The post id of the topic that has the poll.
    int64 topicId = 1;
}

message GetForumPollTopicIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.PostSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostForumRecruitApproveTopicIdRequest {
    // The post id of the recruitment topic to approve.
    int64 topicId = 1;
}

message PostForumRecruitApproveTopicIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Messages.Responses.SaveMessageResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostForumRecruitJoinTopicIdRequest {
    // The post id of the recruitment topic you wish to join.
    int64 topicId = 1;
}

message PostForumRecruitJoinTopicIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.ForumRecruitmentDetail Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostForumRecruitKickBanTopicIdTargetMembershipIdRequest {
    // The id of the user you wish to kick.
    int64 targetMembershipId = 1;
    // The post id of the recruitment topic you wish to join.
    int64 topicId = 2;
}

message PostForumRecruitKickBanTopicIdTargetMembershipIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.ForumRecruitmentDetail Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostForumRecruitLeaveTopicIdRequest {
    // The post id of the recruitment topic you wish to leave.
    int64 topicId = 1;
}

message PostForumRecruitLeaveTopicIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Forum.ForumRecruitmentDetail Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostForumRecruitSummariesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Forum.ForumRecruitmentDetail Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2CreateResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupCreationResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GetAvailableAvatarsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    map<string, string> Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GetAvailableThemesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Config.GroupTheme Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GetUserClanInviteSettingMTypeRequest {
    // The Destiny membership type of the account we wish to access settings.
    int32 mType = 1;
}

message GetGroupV2GetUserClanInviteSettingMTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    bool Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2NameGroupNameGroupTypeRequest {
    // Exact name of the group to find.
    string groupName = 1;
    // Type of group to find.
    int32 groupType = 2;
}

message GetGroupV2NameGroupNameGroupTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2RecommendedResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2SearchResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2SetUserClanInviteSettingMTypeAllowInvitesRequest {
    // True to allow invites of this user to clans, false otherwise.
    bool allowInvites = 1;
    // The Destiny membership type of linked account we are manipulating.
    int32 mType = 2;
}

message PostGroupV2SetUserClanInviteSettingMTypeAllowInvitesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2UserPotentialMembershipTypeMembershipIdFilterGroupTypeRequest {
    // Filter apply to list of potential joined groups.
    int32 filter = 1;
    // Type of group the supplied member applied.
    int32 groupType = 2;
    // Membership ID to for which to find applied groups.
    int64 membershipId = 3;
    // Membership type of the supplied membership ID.
    int32 membershipType = 4;
}

message GetGroupV2UserPotentialMembershipTypeMembershipIdFilterGroupTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupPotentialMembershipSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2UserMembershipTypeMembershipIdFilterGroupTypeRequest {
    // Filter apply to list of joined groups.
    int32 filter = 1;
    // Type of group the supplied member founded.
    int32 groupType = 2;
    // Membership ID to for which to find founded groups.
    int64 membershipId = 3;
    // Membership type of the supplied membership ID.
    int32 membershipType = 4;
}

message GetGroupV2UserMembershipTypeMembershipIdFilterGroupTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupMembershipSearchResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdRequest {
    // Requested group's id.
    int64 groupId = 1;
}

message GetGroupV2GroupIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdAdminAbdicateFoundershipMembershipTypeFounderIdNewRequest {
    // The new founder for this group. Must already be a group admin.
    int64 founderIdNew = 1;
    // The target group id.
    int64 groupId = 2;
    // Membership type of the provided founderIdNew.
    int32 membershipType = 3;
}

message PostGroupV2GroupIdAdminAbdicateFoundershipMembershipTypeFounderIdNewResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    bool Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdAdminsAndFounderRequest {
    // The ID of the group.
    int64 groupId = 1;
}

message GetGroupV2GroupIdAdminsAndFounderResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfGroupMember Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdBannedRequest {
    // Group ID whose banned members you are fetching
    int64 groupId = 1;
}

message GetGroupV2GroupIdBannedResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfGroupBan Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdEditRequest {
    // Group ID of the group to edit.
    int64 groupId = 1;
}

message PostGroupV2GroupIdEditResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdEditClanBannerRequest {
    // Group ID of the group to edit.
    int64 groupId = 1;
}

message PostGroupV2GroupIdEditClanBannerResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdEditFounderOptionsRequest {
    // Group ID of the group to edit.
    int64 groupId = 1;
}

message PostGroupV2GroupIdEditFounderOptionsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdMembersRequest {
    // The ID of the group.
    int64 groupId = 1;
    // Filter out other member types. Use None for all members.
    int32 memberType = 2;
    // The name fragment upon which a search should be executed for members with matching display or unique names.
    string nameSearch = 3;
}

message GetGroupV2GroupIdMembersResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfGroupMember Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersApplyMembershipTypeRequest {
    // ID of the group you would like to join.
    int64 groupId = 1;
    // MembershipType of the account to use when joining.
    int32 membershipType = 2;
}

message PostGroupV2GroupIdMembersApplyMembershipTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupApplicationResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersApproveAllRequest {
    // ID of the group.
    int64 groupId = 1;
}

message PostGroupV2GroupIdMembersApproveAllResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Entities.EntityActionResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersApproveListRequest {
    // ID of the group.
    int64 groupId = 1;
}

message PostGroupV2GroupIdMembersApproveListResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Entities.EntityActionResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersDenyAllRequest {
    // ID of the group.
    int64 groupId = 1;
}

message PostGroupV2GroupIdMembersDenyAllResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Entities.EntityActionResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersDenyListRequest {
    // ID of the group.
    int64 groupId = 1;
}

message PostGroupV2GroupIdMembersDenyListResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Entities.EntityActionResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersIndividualInviteMembershipTypeMembershipIdRequest {
    // ID of the group you would like to join.
    int64 groupId = 1;
    // Membership id of the account being invited.
    int64 membershipId = 2;
    // MembershipType of the account being invited.
    int32 membershipType = 3;
}

message PostGroupV2GroupIdMembersIndividualInviteMembershipTypeMembershipIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupApplicationResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersIndividualInviteCancelMembershipTypeMembershipIdRequest {
    // ID of the group you would like to join.
    int64 groupId = 1;
    // Membership id of the account being cancelled.
    int64 membershipId = 2;
    // MembershipType of the account being cancelled.
    int32 membershipType = 3;
}

message PostGroupV2GroupIdMembersIndividualInviteCancelMembershipTypeMembershipIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupApplicationResponse Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdMembersInvitedIndividualsRequest {
    // ID of the group.
    int64 groupId = 1;
}

message GetGroupV2GroupIdMembersInvitedIndividualsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfGroupMemberApplication Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdMembersPendingRequest {
    // ID of the group.
    int64 groupId = 1;
}

message GetGroupV2GroupIdMembersPendingResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfGroupMemberApplication Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersRescindMembershipTypeRequest {
    // ID of the group.
    int64 groupId = 1;
    // MembershipType of the account to leave.
    int32 membershipType = 2;
}

message PostGroupV2GroupIdMembersRescindMembershipTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupMemberLeaveResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdBanRequest {
    // Group ID that has the member to ban.
    int64 groupId = 1;
    // Membership ID of the member to ban from the group.
    int64 membershipId = 2;
    // Membership type of the provided membership ID.
    int32 membershipType = 3;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdBanResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdKickRequest {
    // Group ID to kick the user from.
    int64 groupId = 1;
    // Membership ID to kick.
    int64 membershipId = 2;
    // Membership type of the provided membership ID.
    int32 membershipType = 3;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdKickResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    GroupsV2.GroupMemberLeaveResult Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdSetMembershipTypeMemberTypeRequest {
    // ID of the group to which the member belongs.
    int64 groupId = 1;
    // New membertype for the specified member.
    int32 memberType = 2;
    // Membership ID to modify.
    int64 membershipId = 3;
    // Membership type of the provide membership ID.
    int32 membershipType = 4;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdSetMembershipTypeMemberTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdUnbanRequest {
    int64 groupId = 1;
    // Membership ID of the member to unban from the group
    int64 membershipId = 2;
    // Membership type of the provided membership ID.
    int32 membershipType = 3;
}

message PostGroupV2GroupIdMembersMembershipTypeMembershipIdUnbanResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int32 Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetGroupV2GroupIdOptionalConversationsRequest {
    // Requested group's id.
    int64 groupId = 1;
}

message GetGroupV2GroupIdOptionalConversationsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated GroupsV2.GroupOptionalConversation Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdOptionalConversationsAddRequest {
    // Group ID of the group to edit.
    int64 groupId = 1;
}

message PostGroupV2GroupIdOptionalConversationsAddResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int64 Response = 5;
    int32 ThrottleSeconds = 6;
}

message PostGroupV2GroupIdOptionalConversationsEditConversationIdRequest {
    // Conversation Id of the channel being edited.
    int64 conversationId = 1;
    // Group ID of the group to edit.
    int64 groupId = 2;
}

message PostGroupV2GroupIdOptionalConversationsEditConversationIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    int64 Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetTrendingCategoriesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Trending.TrendingCategories Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetTrendingCategoriesCategoryIdPageNumberRequest {
    // The ID of the category for whom you want additional results.
    string categoryId = 1;
    // The page # of results to return.
    int32 pageNumber = 2;
}

message GetTrendingCategoriesCategoryIdPageNumberResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    SearchResultOfTrendingEntry Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetTrendingDetailsTrendingEntryTypeIdentifierRequest {
    // The identifier for the entity to be returned.
    string identifier = 1;
    // The type of entity to be returned.
    int32 trendingEntryType = 2;
}

message GetTrendingDetailsTrendingEntryTypeIdentifierResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    Trending.TrendingDetail Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserGetAvailableThemesResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Config.UserTheme Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserGetBungieNetUserByIdIdRequest {
    // The requested Bungie.net membership id.
    int64 id = 1;
}

message GetUserGetBungieNetUserByIdIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    User.GeneralUser Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserGetMembershipsByIdMembershipIdMembershipTypeRequest {
    // The membership ID of the target user.
    int64 membershipId = 1;
    // Type of the supplied membership ID.
    int32 membershipType = 2;
}

message GetUserGetMembershipsByIdMembershipIdMembershipTypeResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    User.UserMembershipData Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserGetMembershipsForCurrentUserResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    User.UserMembershipData Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserGetUserAliasesIdRequest {
    // The requested Bungie.net membership id.
    int64 id = 1;
}

message GetUserGetUserAliasesIdResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated User.Models.UserAlias Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserSearchUsersRequest {
    // The search string.
    string q = 1;
}

message GetUserSearchUsersResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated User.GeneralUser Response = 5;
    int32 ThrottleSeconds = 6;
}

message GetUserMembershipIdPartnershipsRequest {
    // The ID of the member for whom partnerships should be returned.
    int64 membershipId = 1;
}

message GetUserMembershipIdPartnershipsResponse {
    integer ErrorCode = 1;
    string ErrorStatus = 2;
    string Message = 3;
    map<string, string> MessageData = 4;
    repeated Partnerships.PublicPartnershipDetail Response = 5;
    int32 ThrottleSeconds = 6;
}







repeated integer BungieMembershipType[] = 1

message Community.CommunityLiveStatus {
    uint32 activityModeHash = 1;
    uint32 currentActivityHash = 2;
    int32 currentViewers = 3;
    string dateFeatured = 4;
    string dateLastPlayed = 5;
    string dateStatusUpdated = 6;
    string dateStreamStarted = 7;
    int64 destinyCharacterId = 8;
    int32 followers = 9;
    bool isFeatured = 10;
    bool isSubscribable = 11;
    string locale = 12;
    int32 overallViewers = 13;
    string partnershipIdentifier = 14;
    integer partnershipType = 15;
    string thumbnail = 16;
    string thumbnailLarge = 17;
    string thumbnailSmall = 18;
    string title = 19;
    float trendingValue = 20;
    string url = 21;
    User.UserInfoCard userInfo = 22;
}

message Components.ComponentResponse {
    integer privacy = 1;
}

message Config.GroupTheme {
    string description = 1;
    string folder = 2;
    string name = 3;
}

message Config.UserTheme {
    string userThemeDescription = 1;
    int32 userThemeId = 2;
    string userThemeName = 3;
}

message Content.CommentSummary {
    int32 commentCount = 1;
    int64 topicId = 2;
}

message Content.ContentItemPublicContract {
    bool allowComments = 1;
    User.GeneralUser author = 2;
    bool autoEnglishPropertyFallback = 3;
    string cType = 4;
    string cmsPath = 5;
    Content.CommentSummary commentSummary = 6;
    int64 contentId = 7;
    string creationDate = 8;
    bool hasAgeGate = 9;
    int32 minimumAge = 10;
    string modifyDate = 11;
    // Firehose content is really a collection of metadata and "properties", which are the potentially-but-not-strictly localizable data that comprises the meat of whatever content is being shown.
    // As Cole Porter would have crooned, "Anything Goes" with Firehose properties. They are most often strings, but they can theoretically be anything. They are JSON encoded, and could be JSON structures, simple strings, numbers etc... The Content Type of the item (cType) will describe the properties, and thus how they ought to be deserialized.
    map<string, object> properties = 12;
    string ratingImagePath = 13;
    repeated Content.ContentRepresentation representations = 14;
    repeated string tags = 15;
}

message Content.ContentRepresentation {
    string name = 1;
    string path = 2;
    string validationString = 3;
}

message Dates.DateRange {
    string end = 1;
    string start = 2;
}

message Destiny.Activities.DestinyPublicActivityStatus {
    // Active Challenges for the activity, if any - represented as hashes for DestinyObjectiveDefinitions.
    repeated uint32 challengeObjectiveHashes = 1;
    // The active modifiers on this activity, if any - represented as hashes for DestinyActivityModifierDefinitions.
    repeated uint32 modifierHashes = 2;
    // If the activity itself provides any specific "mock" rewards, this will be the items and their quantity.
    // Why "mock", you ask? Because these are the rewards as they are represented in the tooltip of the Activity.
    // These are often pointers to fake items that look good in a tooltip, but represent an abstract concept of what you will get for a reward rather than the specific items you may obtain.
    repeated Destiny.DestinyItemQuantity rewardTooltipItems = 3;
}

message Destiny.Challenges.DestinyChallengeStatus {
    // The progress - including completion status - of the active challenge.
    message Objective {
    }
    Objective objective = 1;
}

message Destiny.Character.DestinyCharacterCustomization {
    uint32 decalColor = 1;
    int32 decalIndex = 2;
    uint32 eyeColor = 3;
    uint32 face = 4;
    repeated uint32 featureColors = 5;
    int32 featureIndex = 6;
    repeated uint32 hairColors = 7;
    int32 hairIndex = 8;
    uint32 lipColor = 9;
    uint32 personality = 10;
    uint32 skinColor = 11;
    bool wearHelmet = 12;
}

message Destiny.Character.DestinyCharacterPeerView {
    repeated Destiny.Character.DestinyItemPeerView equipment = 1;
}

message Destiny.Character.DestinyItemPeerView {
    // The list of dyes that have been applied to this item.
    repeated Destiny.DyeReference dyes = 1;
    // The hash identifier of the item in question. Use it to look up the DestinyInventoryItemDefinition of the item for static rendering data.
    uint32 itemHash = 2;
}

message Destiny.Components.Items.DestinyItemPlugComponent {
    // If a plug is not enabled, this will be populated with indexes into the plug item definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.
    // This list will be empty if the plug is enabled.
    repeated int32 enableFailIndexes = 1;
    // If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.
    // This list will be empty if the plug can be inserted.
    repeated int32 insertFailIndexes = 2;
}

message Destiny.Components.Kiosks.DestinyKioskItem {
    // If true, the user can not only see the item, but they can acquire it. It is possible that a user can see a kiosk item and not be able to acquire it.
    bool canAcquire = 1;
    // Indexes into failureStrings for the Vendor, indicating the reasons why it failed if any.
    repeated int32 failureIndexes = 2;
    // The index of the item in the related DestinyVendorDefintion's itemList property, representing the sale.
    int32 index = 3;
}

message Destiny.Components.Kiosks.DestinyKiosksComponent {
    // A dictionary keyed by the Kiosk Vendor's hash identifier (use it to look up the DestinyVendorDefinition for the relevant kiosk vendor), and whose value is a list of all the items that the user can "see" in the Kiosk, and any other interesting metadata.
    map<string, array> kioskItems = 1;
}

message Destiny.Config.DestinyManifest {
    string mobileAssetContentPath = 1;
    string mobileClanBannerDatabasePath = 2;
    repeated Destiny.Config.GearAssetDataBaseDefinition mobileGearAssetDataBases = 3;
    map<string, string> mobileGearCDN = 4;
    map<string, string> mobileWorldContentPaths = 5;
    string version = 6;
}

message Destiny.Config.GearAssetDataBaseDefinition {
    string path = 1;
    int32 version = 2;
}

message Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
}

message Destiny.Definitions.Animations.DestinyAnimationReference {
    string animIdentifier = 1;
    string animName = 2;
    string path = 3;
}

message Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition {
    string description = 1;
    bool hasIcon = 2;
    // Note that "icon" is sometimes misleading, and should be interpreted in the context of the entity. For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.
    // But usually, it will be a small square image that you can use as... well, an icon.
    string icon = 3;
    string name = 4;
}

message Destiny.Definitions.Common.DestinyPositionDefinition {
    int32 x = 1;
    int32 y = 2;
    int32 z = 3;
}

message Destiny.Definitions.DestinyActivityChallengeDefinition {
    // The hash for the Objective that matches this challenge. Use it to look up the DestinyObjectiveDefinition.
    uint32 objectiveHash = 1;
}

message Destiny.Definitions.DestinyActivityDefinition {
    // Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity.
    repeated Destiny.Definitions.DestinyActivityGraphListEntryDefinition activityGraphList = 1;
    // The difficulty level of the activity.
    int32 activityLevel = 2;
    // The recommended light level for this activity.
    int32 activityLightLevel = 3;
    repeated uint32 activityModeHashes = 4;
    repeated integer activityModeTypes = 5;
    // The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You'll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing.
    uint32 activityTypeHash = 6;
    // An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they're active and what rewards they provide. Sadly, at the moment there's no central definition for challenges: much like "Skulls" were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time.
    repeated Destiny.Definitions.DestinyActivityChallengeDefinition challenges = 7;
    // The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a "Place". For instance, if the "Place" is Earth, the "Destination" would be a specific city or region on Earth.
    uint32 destinationHash = 8;
    uint32 directActivityModeHash = 9;
    int32 directActivityModeType = 10;
    // The title, subtitle, and icon for the activity.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 11;
    // This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn't exist, the game is not able to be played as a guided game.
    message GuidedGame {
    }
    GuidedGame guidedGame = 12;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 13;
    // The index of the entity as it was found in the investment tables.
    int32 index = 14;
    // If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist.
    bool isPlaylist = 15;
    // If true, this activity is a PVP activity or playlist.
    bool isPvP = 16;
    // This block of data provides information about the Activity's matchmaking attributes: how many people can join and such.
    message Matchmaking {
    }
    Matchmaking matchmaking = 17;
    // Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time.
    repeated Destiny.Definitions.DestinyActivityModifierReferenceDefinition modifiers = 18;
    // If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown.
    repeated Destiny.Definitions.DestinyActivityUnlockStringDefinition optionalUnlockStrings = 19;
    // When Activities are completed, we generate a "Post-Game Carnage Report", or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general.
    string pgcrImage = 20;
    // The hash identifier for the "Place" on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the "Place" is Earth, the "Destination" would be a specific city or region on Earth.
    uint32 placeHash = 21;
    // Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time.
    repeated Destiny.Definitions.DestinyActivityPlaylistItemDefinition playlistItems = 22;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 23;
    // If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release's icon.
    string releaseIcon = 24;
    // If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible.
    int32 releaseTime = 25;
    // The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game's state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or "Dummy" items: items that tell you what you can earn in vague terms rather than what you'll specifically be earning (partly because the game doesn't even know what you'll earn specifically until you roll for it at the end)
    repeated Destiny.Definitions.DestinyActivityRewardDefinition rewards = 26;
    // The difficulty tier of the activity.
    int32 tier = 27;
}

message Destiny.Definitions.DestinyActivityGraphListEntryDefinition {
    // The hash identifier of the DestinyActivityGraphDefinition that should be shown when opening the director.
    uint32 activityGraphHash = 1;
}

message Destiny.Definitions.DestinyActivityGuidedBlockDefinition {
    // If -1, the guided group cannot be disbanded. Otherwise, take the total # of players in the activity and subtract this number: that is the total # of votes needed for the guided group to disband.
    int32 guidedDisbandCount = 1;
    // The maximum amount of people that can be in the waiting lobby.
    int32 guidedMaxLobbySize = 2;
    // The minimum amount of people that can be in the waiting lobby.
    int32 guidedMinLobbySize = 3;
}

message Destiny.Definitions.DestinyActivityMatchmakingBlockDefinition {
    // If TRUE, the activity is matchmade. Otherwise, it requires explicit forming of a party.
    bool isMatchmade = 1;
    // The maximum # of people allowed in a Fireteam.
    int32 maxParty = 2;
    // The maximum # of people allowed across all teams in the activity.
    int32 maxPlayers = 3;
    // The minimum # of people in the fireteam for the activity to launch.
    int32 minParty = 4;
    // If true, you have to Solemnly Swear to be up to Nothing But Good(tm) to play.
    bool requiresGuardianOath = 5;
}

message Destiny.Definitions.DestinyActivityModeDefinition {
    integer activityModeCategory = 1;
    map<string, integer> activityModeMappings = 2;
    // If FALSE, we want to ignore this type when we're showing activity modes in BNet UI. It will still be returned in case 3rd parties want to use it for any purpose.
    bool display = 3;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 4;
    string friendlyName = 5;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 6;
    // The index of the entity as it was found in the investment tables.
    int32 index = 7;
    bool isAggregateMode = 8;
    bool isTeamBased = 9;
    integer modeType = 10;
    // The relative ordering of activity modes.
    int32 order = 11;
    repeated uint32 parentHashes = 12;
    string pgcrImage = 13;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 14;
}

message Destiny.Definitions.DestinyActivityModifierReferenceDefinition {
    // The hash identifier for the DestinyActivityModifierDefinition referenced by this activity.
    uint32 activityModifierHash = 1;
}

message Destiny.Definitions.DestinyActivityPlaylistItemDefinition {
    // The hash identifier of the Activity that can be played. Use it to look up the DestinyActivityDefinition.
    uint32 activityHash = 1;
    repeated uint32 activityModeHashes = 2;
    repeated integer activityModeTypes = 3;
    uint32 directActivityModeHash = 4;
    int32 directActivityModeType = 5;
}

message Destiny.Definitions.DestinyActivityRewardDefinition {
    // The "Items provided" in the reward. This is almost always a pointer to a DestinyInventoryItemDefintion for an item that you can't actually earn in-game, but that has name/description/icon information for the vague concept of the rewards you will receive. This is because the actual reward generation is non-deterministic and extremely complicated, so the best the game can do is tell you what you'll get in vague terms. And so too shall we.
    // Interesting trivia: you actually *do* earn these items when you complete the activity. They go into a single-slot bucket on your profile, which is how you see the pop-ups of these rewards when you complete an activity that match these "dummy" items. You can even see them if you look at the last one you earned in your profile-level inventory through the BNet API! Who said reading documentation is a waste of time?
    repeated Destiny.DestinyItemQuantity rewardItems = 1;
    // The header for the reward set, if any.
    string rewardText = 2;
}

message Destiny.Definitions.DestinyActivityTypeDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
}

message Destiny.Definitions.DestinyActivityUnlockStringDefinition {
    // The string to be displayed if the conditions are met.
    string displayString = 1;
}

message Destiny.Definitions.DestinyBubbleDefinition {
    // The identifier for the bubble: only guaranteed to be unique within the Destination.
    uint32 hash = 1;
}

message Destiny.Definitions.DestinyClassDefinition {
    // In Destiny 1, we added a convenience Enumeration for referring to classes. We've kept it, though mostly for posterity. This is the enum value for this definition's class.
    message ClassType {
    }
    ClassType classType = 1;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 2;
    // A localized string referring to the singular form of the Class's name when referred to in gendered form. Keyed by the DestinyGender.
    map<string, string> genderedClassNames = 3;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 4;
    // The index of the entity as it was found in the investment tables.
    int32 index = 5;
    // If the Class has a Mentor (all classes *should*), this will be the hash identifier for that Vendor if you care.
    uint32 mentorVendorHash = 6;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 7;
}

message Destiny.Definitions.DestinyDamageTypeDefinition {
    // The description of the damage type, icon etc...
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // We have an enumeration for damage types for quick reference. This is the current definition's damage type enum value.
    message EnumValue {
    }
    EnumValue enumValue = 2;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 3;
    // The index of the entity as it was found in the investment tables.
    int32 index = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
    // If TRUE, the game shows this damage type's icon. Otherwise, it doesn't. Whether you show it or not is up to you.
    bool showIcon = 6;
    // A variant of the icon that is transparent and colorless.
    string transparentIconPath = 7;
}

message Destiny.Definitions.DestinyDefinition {
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 1;
    // The index of the entity as it was found in the investment tables.
    int32 index = 2;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 3;
}

message Destiny.Definitions.DestinyDestinationBubbleSettingDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
}

message Destiny.Definitions.DestinyDestinationDefinition {
    // If the Destination has default Activity Graphs (i.e. "Map") that should be shown in the director, this is the list of those Graphs. At most, only one should be active at any given time for a Destination: these would represent, for example, different variants on a Map if the Destination is changing on a macro level based on game state.
    repeated Destiny.Definitions.DestinyActivityGraphListEntryDefinition activityGraphEntries = 1;
    // A Destination may have many "Bubbles" zones with human readable properties.
    // We don't get as much info as I'd like about them - I'd love to return info like where on the map they are located - but at least this gives you the name of those bubbles. bubbleSettings and bubbles both have the identical number of entries, and you should match up their indexes to provide matching bubble and bubbleSettings data.
    repeated Destiny.Definitions.DestinyDestinationBubbleSettingDefinition bubbleSettings = 2;
    // This provides the unique identifiers for every bubble in the destination (only guaranteed unique within the destination), and any intrinsic properties of the bubble.
    // bubbleSettings and bubbles both have the identical number of entries, and you should match up their indexes to provide matching bubble and bubbleSettings data.
    repeated Destiny.Definitions.DestinyBubbleDefinition bubbles = 3;
    // If this Destination has a default Free-Roam activity, this is the hash for that Activity. Use it to look up the DestinyActivityDefintion.
    uint32 defaultFreeroamActivityHash = 4;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 5;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 6;
    // The index of the entity as it was found in the investment tables.
    int32 index = 7;
    // The place that "owns" this Destination. Use this hash to look up the DestinyPlaceDefinition.
    uint32 placeHash = 8;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 9;
}

message Destiny.Definitions.DestinyDisplayCategoryDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // A string identifier for the display category.
    string identifier = 2;
}

message Destiny.Definitions.DestinyEntitySearchResult {
    // The items found that are matches/near matches for the searched-for term, sorted by something vaguely resembling "relevance". Hopefully this will get better in the future.
    message Results {
    }
    Results results = 1;
    // A list of suggested words that might make for better search results, based on the text searched for.
    repeated string suggestedWords = 2;
}

message Destiny.Definitions.DestinyEntitySearchResultItem {
    // Basic display properties on the entity, so you don't have to look up the definition to show basic results for the item.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // The type of entity, returned as a string matching the DestinyDefinition's contract class name. You'll have to have your own mapping from class names to actually looking up those definitions in the manifest databases.
    string entityType = 2;
    // The hash identifier of the entity. You will use this to look up the DestinyDefinition relevant for the entity found.
    uint32 hash = 3;
    // The ranking value for sorting that we calculated using our relevance formula. This will hopefully get better with time and iteration.
    double weight = 4;
}

message Destiny.Definitions.DestinyEquipmentSlotDefinition {
    // If True, equipped items should have their custom art dyes applied when rendering the item. Otherwise, custom art dyes on an item should be ignored if the item is equipped in this slot.
    bool applyCustomArtDyes = 1;
    // The inventory bucket that owns this equipment slot.
    uint32 bucketTypeHash = 2;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 3;
    // These technically point to "Equipment Category Definitions". But don't get excited. There's nothing of significant value in those definitions, so I didn't bother to expose them. You can use the hash here to group equipment slots by common functionality, which serves the same purpose as if we had the Equipment Category definitions exposed.
    uint32 equipmentCategoryHash = 4;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 5;
    // The index of the entity as it was found in the investment tables.
    int32 index = 6;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 7;
}

message Destiny.Definitions.DestinyEquippingBlockDefinition {
    // These are custom attributes on the equippability of the item.
    // For now, this can only be "equip on acquire", which would mean that the item will be automatically equipped as soon as you pick it up.
    message Attributes {
    }
    Attributes attributes = 1;
    // These are strings that represent the possible Game/Account/Character state failure conditions that can occur when trying to equip the item. They match up one-to-one with requiredUnlockExpressions.
    repeated string displayStrings = 2;
    // An equipped item *must* be equipped in an Equipment Slot. This is the hash identifier of the DestinyEquipmentSlotDefinition into which it must be equipped.
    uint32 equipmentSlotTypeHash = 3;
    // If the item is part of a gearset, this is a reference to that gearset item.
    uint32 gearsetItemHash = 4;
    // If defined, this is the label used to check if the item has other items of matching types already equipped. 
    // For instance, when you aren't allowed to equip more than one Exotic Weapon, that's because all exotic weapons have identical uniqueLabels and the game checks the to-be-equipped item's uniqueLabel vs. all other already equipped items (other than the item in the slot that's about to be occupied).
    string uniqueLabel = 5;
    // The hash of that unique label. Does not point to a specific definition.
    uint32 uniqueLabelHash = 6;
}

message Destiny.Definitions.DestinyFactionDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // The hash identifier for the DestinyProgressionDefinition that indicates the character's relationship with this faction in terms of experience and levels.
    uint32 progressionHash = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
}

message Destiny.Definitions.DestinyGearArtArrangementReference {
    uint32 artArrangementHash = 1;
    uint32 classHash = 2;
}

message Destiny.Definitions.DestinyGenderDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // This is a quick reference enumeration for all of the currently defined Genders. We use the enumeration for quicker lookups in related data, like DestinyClassDefinition.genderedClassNames.
    message GenderType {
    }
    GenderType genderType = 2;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 3;
    // The index of the entity as it was found in the investment tables.
    int32 index = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
}

message Destiny.Definitions.DestinyInventoryBucketDefinition {
    // Use this property to provide a quick-and-dirty recommended ordering for buckets in the UI. Most UIs will likely want to forsake this for something more custom and manual.
    int32 bucketOrder = 1;
    // An enum value for what items can be found in the bucket. See the BucketCategory enum for more details.
    message Category {
    }
    Category category = 2;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 3;
    // If True, this bucket is enabled. Disabled buckets may include buckets that were included for test purposes, or that were going to be used but then were abandoned but never removed from content *cough*.
    bool enabled = 4;
    // if a FIFO bucket fills up, it will delete the oldest item from said bucket when a new item tries to be added to it. If this is FALSE, the bucket will not allow new items to be placed in it until room is made by the user manually deleting items from it. You can see an example of this with the Postmaster's bucket.
    bool fifo = 5;
    // If TRUE, there is at least one Vendor that can transfer items to/from this bucket. See the DestinyVendorDefinition's acceptedItems property for more information on how transferring works.
    bool hasTransferDestination = 6;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 7;
    // The index of the entity as it was found in the investment tables.
    int32 index = 8;
    // The maximum # of item "slots" in a bucket. A slot is a given combination of item + quantity.
    // For instance, a Weapon will always take up a single slot, and always have a quantity of 1. But a material could take up only a single slot with hundreds of quantity.
    int32 itemCount = 9;
    // Sometimes, inventory buckets represent conceptual "locations" in the game that might not be expected. This value indicates the conceptual location of the bucket, regardless of where it is actually contained on the character/account. 
    // See ItemLocation for details. 
    // Note that location includes the Vault and the Postmaster (both of whom being just inventory buckets with additional actions that can be performed on them through a Vendor)
    message Location {
    }
    Location location = 10;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 11;
    // Where the bucket is found. 0 = Character, 1 = Account
    message Scope {
    }
    Scope scope = 12;
}

message Destiny.Definitions.DestinyInventoryItemDefinition {
    // If the item can be "used", this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is "dismantle". Shocker)
    message Action {
    }
    Action action = 1;
    // BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.
    bool allowActions = 2;
    // If any animations were extracted from game content for this item, these will be the definitions of those animations.
    repeated Destiny.Definitions.Animations.DestinyAnimationReference animations = 3;
    // We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class' enumeration value so that users can easily identify class restricted items.
    // If you see a mis-classed item, please inform the developers in the Bungie API forum.
    message ClassType {
    }
    ClassType classType = 4;
    // Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.
    repeated uint32 damageTypeHashes = 5;
    // This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.
    // This damage type prediction will only use the following to determine potential damage types:
    // - Intrinsic perks
    // - Talent Node perks
    // - Known, reusable plugs for sockets
    repeated integer damageTypes = 6;
    // If the item has a damage type that could be considered to be default, it will be populated here.
    // For various upsetting reasons, it's surprisingly cumbersome to figure this out. I hope you're happy.
    message DefaultDamageType {
    }
    DefaultDamageType defaultDamageType = 7;
    // Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.
    // I will likely regret leaving in the enumeration versions of these properties, but for now they're very convenient.
    uint32 defaultDamageTypeHash = 8;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 9;
    // In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it's instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.
    string displaySource = 10;
    // If true, then you will be allowed to equip the item if you pass its other requirements.
    // This being false means that you cannot equip the item under any circumstances.
    bool equippable = 11;
    // If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.
    message EquippingBlock {
    }
    EquippingBlock equippingBlock = 12;
    // If this item has related items in a "Gear Set", this will be non-null and the relationships defined herein.
    message Gearset {
    }
    Gearset gearset = 13;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 14;
    // The index of the entity as it was found in the investment tables.
    int32 index = 15;
    // If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.
    message Inventory {
    }
    Inventory inventory = 16;
    // If the item has stats, this block will be defined. It has the "raw" investment stats for the item. These investment stats don't take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.
    repeated Destiny.Definitions.DestinyItemInvestmentStatDefinition investmentStats = 17;
    // BNet attempts to make a more formal definition of item "Categories", as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it's a "Weapon", that it's an "Auto Rifle", etc...)
    // The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.
    repeated uint32 itemCategoryHashes = 18;
    // A value indicating the "sub-type" of the item. For instance, where an item might have an itemType value "Weapon", this will be something more specific like "Auto Rifle".
    // itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
    message ItemSubType {
    }
    ItemSubType itemSubType = 19;
    // A value indicating the "base" the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a "Type". Still, it's handy in many situations.
    // itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
    message ItemType {
    }
    ItemType itemType = 20;
    // It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I'm just going to go ahead and start pre-creating these for items.
    string itemTypeAndTierDisplayName = 21;
    // The localized title/name of the item's type. This can be whatever the designers want, and has no guarantee of consistency between items.
    string itemTypeDisplayName = 22;
    // If we added any help or informational URLs about this item, these will be those links.
    repeated Links.HyperlinkReference links = 23;
    // If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.
    uint32 loreHash = 24;
    // The intrinsic transferability of an item.
    // I hate that this boolean is negative - but there's a reason.
    // Just because an item is intrinsically transferrable doesn't mean that it can be transferred, and we don't want to imply that this is the only source of that transferability.
    bool nonTransferrable = 25;
    // If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.
    message Objectives {
    }
    Objectives objectives = 26;
    // If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.
    repeated Destiny.Definitions.DestinyItemPerkEntryDefinition perks = 27;
    // If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.
    message Plug {
    }
    Plug plug = 28;
    // If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.
    message Preview {
    }
    Preview preview = 29;
    // If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, "quality", and infusion) data. See the block for more details, there's often less upfront information in D2 so you'll want to be aware of how you use quality and item level on the definition level now.
    message Quality {
    }
    Quality quality = 30;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 31;
    // If this item is a "reward sack" that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.
    message Sack {
    }
    Sack sack = 32;
    // If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.
    string screenshot = 33;
    // A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.
    string secondaryIcon = 34;
    // Pulled from the secondary icon, this is the "secondary background" of the secondary icon. Confusing? Sure, that's why I call it "overlay" here: because as far as it's been used thus far, it has been for an optional overlay image. We'll see if that holds up, but at least for now it explains what this image is a bit better.
    string secondaryOverlay = 35;
    // Pulled from the Secondary Icon, this is the "special" background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.
    string secondarySpecial = 36;
    // If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn't clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.
    message SetData {
    }
    SetData setData = 37;
    // If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.
    message Sockets {
    }
    Sockets sockets = 38;
    // If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn't have time for, and I'm hoping to get back to at some point in the future.
    message SourceData {
    }
    SourceData sourceData = 39;
    // In Destiny 1, we identified some items as having particular categories that we'd like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
    message SpecialItemType {
    }
    SpecialItemType specialItemType = 40;
    // If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.
    message Stats {
    }
    Stats stats = 41;
    // Summary data about the item.
    message Summary {
    }
    Summary summary = 42;
    // There are times when the game will show you a "summary/vague" version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.
    // This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.
    uint32 summaryItemHash = 43;
    // If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/"Build" items.
    message TalentGrid {
    }
    TalentGrid talentGrid = 44;
    // An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it'll be up to you to interpret and display your UI differently according to these styles (or ignore it).
    string tooltipStyle = 45;
    // If this item can be rendered, this block will be non-null and will be populated with rendering information.
    message TranslationBlock {
    }
    TranslationBlock translationBlock = 46;
    // The conceptual "Value" of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.
    message Value {
    }
    Value value = 47;
}

message Destiny.Definitions.DestinyInventoryItemStatDefinition {
    // The maximum possible value for this stat that we think the item can roll.
    int32 maximum = 1;
    // The minimum possible value for this stat that we think the item can roll.
    int32 minimum = 2;
    // The hash for the DestinyStatDefinition representing this stat.
    uint32 statHash = 3;
    // This value represents the stat value assuming the minimum possible roll but accounting for any mandatory bonuses that should be applied to the stat on item creation.
    // In Destiny 1, this was different from the "minimum" value because there were certain conditions where an item could be theoretically lower level/value than the initial roll. 
    // In Destiny 2, this is not possible unless Talent Grids begin to be used again for these purposes or some other system change occurs... thus in practice, value and minimum should be the same in Destiny 2. Good riddance.
    int32 value = 4;
}

message Destiny.Definitions.DestinyItemActionBlockDefinition {
    // The internal identifier for the action.
    string actionTypeLabel = 1;
    // If true, the entire stack is deleted when the action completes.
    bool consumeEntireStack = 2;
    // If true, the item is deleted when the action completes.
    bool deleteOnAction = 3;
    // The content has this property, however it's not entirely clear how it is used.
    bool isPositive = 4;
    // The icon associated with the overlay screen for the action, if any.
    string overlayIcon = 5;
    // If the action has an overlay screen associated with it, this is the name of that screen. Unfortunately, we cannot return the screen's data itself.
    string overlayScreenName = 6;
    // If performing this action earns you Progression, this is the list of progressions and values granted for those progressions by performing this action.
    repeated Destiny.Definitions.DestinyProgressionRewardDefinition progressionRewards = 7;
    // The identifier hash for the Cooldown associated with this action. We have not pulled this data yet for you to have more data to use for cooldowns.
    uint32 requiredCooldownHash = 8;
    // The number of seconds to delay before allowing this action to be performed again.
    int32 requiredCooldownSeconds = 9;
    // If the action requires other items to exist or be destroyed, this is the list of those items and requirements.
    repeated Destiny.Definitions.DestinyItemActionRequiredItemDefinition requiredItems = 10;
    // Theoretically, an item could have a localized string for a hint about the location in which the action should be performed. In practice, no items yet have this property.
    string requiredLocation = 11;
    // If true, this action will be performed as soon as you earn this item. Some rewards work this way, providing you a single item to pick up from a reward-granting vendor in-game and then immediately consuming itself to provide you multiple items.
    bool useOnAcquire = 12;
    // Localized text describing the action being performed.
    string verbDescription = 13;
    // Localized text for the verb of the action being performed.
    string verbName = 14;
}

message Destiny.Definitions.DestinyItemActionRequiredItemDefinition {
    // The minimum quantity of the item you have to have.
    int32 count = 1;
    // If true, the item/quantity will be deleted from your inventory when the action is performed. Otherwise, you'll retain these required items after the action is complete.
    bool deleteOnAction = 2;
    // The hash identifier of the item you need to have. Use it to look up the DestinyInventoryItemDefinition for more info.
    uint32 itemHash = 3;
}

message Destiny.Definitions.DestinyItemCategoryDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // If an item belongs to this category, it will also get this class restriction enum value.
    // See the other "grant"-prefixed properties on this definition for my color commentary.
    message GrantDestinyClass {
    }
    GrantDestinyClass grantDestinyClass = 2;
    // If an item belongs to this category, it will also receive this item type. This is now how DestinyItemType is populated for items: it used to be an even jankier process, but that's a story that requires more alcohol.
    message GrantDestinyItemType {
    }
    GrantDestinyItemType grantDestinyItemType = 3;
    // If an item belongs to this category, it will also receive this subtype enum value.
    // I know what you're thinking - what if it belongs to multiple categories that provide sub-types?
    // The last one processed wins, as is the case with all of these "grant" enums. Now you can see one reason why we moved away from these enums... but they're so convenient when they work, aren't they?
    message GrantDestinySubType {
    }
    GrantDestinySubType grantDestinySubType = 4;
    // If this category is a "parent" category of other categories, those children will have their hashes listed in rendering order here, and can be looked up using these hashes against DestinyItemCategoryDefinition.
    // In this way, you can build up a visual hierarchy of item categories. That's what we did, and you can do it too. I believe in you. Yes, you, Carl.
    // (I hope someone named Carl reads this someday)
    repeated uint32 groupedCategoryHashes = 5;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 6;
    // The index of the entity as it was found in the investment tables.
    int32 index = 7;
    // The janky regular expression we used against the item type to try and discern whether the item belongs to this category.
    string itemTypeRegex = 8;
    // If the item type matches this janky regex, it does *not* belong to this category.
    string itemTypeRegexNot = 9;
    // If the item belongs to this bucket, it does belong to this category.
    string originBucketIdentifier = 10;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 11;
    // A shortened version of the title. The reason why we have this is because the Armory in German had titles that were too long to display in our UI, so these were localized abbreviated versions of those categories. The property still exists today, even though the Armory doesn't exist for D2... yet.
    string shortTitle = 12;
    // If True, this category should be visible in UI. Sometimes we make categories that we don't think are interesting externally. It's up to you if you want to skip on showing them.
    bool visible = 13;
}

message Destiny.Definitions.DestinyItemCreationEntryLevelDefinition {
    int32 level = 1;
}

message Destiny.Definitions.DestinyItemGearsetBlockDefinition {
    // The list of hashes for items in the gearset. Use them to look up DestinyInventoryItemDefinition entries for the items in the set.
    repeated uint32 itemList = 1;
    // The maximum possible number of items that can be collected.
    int32 trackingValueMax = 2;
}

message Destiny.Definitions.DestinyItemInventoryBlockDefinition {
    // The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this "bucketHash", but too many things refer to it now. Sigh.
    uint32 bucketTypeHash = 1;
    // If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer).
    bool isInstanceItem = 2;
    // The maximum quantity of this item that can exist in a stack.
    int32 maxStackSize = 3;
    // If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead.
    uint32 recoveryBucketTypeHash = 4;
    // If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness.
    string stackUniqueLabel = 5;
    // The enumeration matching the tier type of the item to known values, again for convenience sake.
    message TierType {
    }
    TierType tierType = 6;
    // The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier.
    uint32 tierTypeHash = 7;
    // The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to.
    string tierTypeName = 8;
}

message Destiny.Definitions.DestinyItemInvestmentStatDefinition {
    // The hash identifier for the DestinyStatDefinition defining this stat.
    uint32 statTypeHash = 1;
    // The raw "Investment" value for the stat, before transformations are performed to turn this raw stat into stats that are displayed in the game UI.
    int32 value = 2;
}

message Destiny.Definitions.DestinyItemObjectiveBlockDefinition {
    // For every entry in objectiveHashes, there is a corresponding entry in this array at the same index. If the objective is meant to be associated with a specific DestinyActivityDefinition, there will be a valid hash at that index. Otherwise, it will be invalid (0).
    repeated uint32 displayActivityHashes = 1;
    // The localized string for narrative text related to this quest step, if any.
    string narrative = 2;
    // The hashes to Objectives (DestinyObjectiveDefinition) that are part of this Quest Step, in the order that they should be rendered.
    repeated uint32 objectiveHashes = 3;
    // The localized string describing an action to be performed associated with the objectives, if any.
    string objectiveVerbName = 4;
    // A hashed value for the questTypeIdentifier, because apparently I like to be redundant.
    uint32 questTypeHash = 5;
    // The identifier for the type of quest being performed, if any. Not associated with any fixed definition, yet.
    string questTypeIdentifier = 6;
    // The hash for the DestinyInventoryItemDefinition representing the Quest to which this Quest Step belongs.
    uint32 questlineItemHash = 7;
    // If True, all objectives must be completed for the step to be completed. If False, any one objective can be completed for the step to be completed.
    bool requireFullObjectiveCompletion = 8;
}

message Destiny.Definitions.DestinyItemPerkEntryDefinition {
    // A hash identifier for the DestinySandboxPerkDefinition being provided on the item.
    uint32 perkHash = 1;
    // If this perk is not active, this is the string to show for why it's not providing its benefits.
    string requirementDisplayString = 2;
}

message Destiny.Definitions.DestinyItemPreviewBlockDefinition {
    // This is a list of the items being previewed, categorized in the same way as they are in the preview UI.
    repeated Destiny.Definitions.Items.DestinyDerivedItemCategoryDefinition derivedItemCategories = 1;
    // If the preview has an associated action (like "Open"), this will be the localized string for that action.
    string previewActionString = 2;
    // If the preview data is derived from a fake "Preview" Vendor, this will be the hash identifier for the DestinyVendorDefinition of that fake vendor.
    uint32 previewVendorHash = 3;
}

message Destiny.Definitions.DestinyItemQualityBlockDefinition {
    // The hash identifier for the infusion. It does not map to a Definition entity.
    uint32 infusionCategoryHash = 1;
    // The string identifier for this item's "infusability", if any. 
    // Items that match the same infusionCategoryName are allowed to infuse with each other.
    string infusionCategoryName = 2;
    // The "base" defined level of an item. This is a list because, in theory, each Expansion could define its own base level for an item.
    // In practice, not only was that never done in Destiny 1, but now this isn't even populated at all. When it's not populated, the level at which it spawns has to be inferred by Reward information, of which BNet receives an imperfect view and will only be reliable on instanced data as a result.
    repeated int32 itemLevels = 3;
    // An item can refer to pre-set level requirements. They are defined in DestinyProgressionLevelRequirementDefinition, and you can use this hash to find the appropriate definition.
    uint32 progressionLevelRequirementHash = 4;
    // qualityLevel is used in combination with the item's level to calculate stats like Attack and Defense. It plays a role in that calculation, but not nearly as large as itemLevel does.
    int32 qualityLevel = 5;
}

message Destiny.Definitions.DestinyItemSackBlockDefinition {
    // A description of what will happen when you open the sack. As far as I can tell, this is blank currently. Unknown whether it will eventually be populated with useful info.
    string detailAction = 1;
    // The localized name of the action being performed when you open the sack.
    string openAction = 2;
    int32 selectItemCount = 3;
    string vendorSackType = 4;
}

message Destiny.Definitions.DestinyItemSetBlockDefinition {
    // A collection of hashes of set items, for items such as Quest Metadata items that possess this data.
    repeated Destiny.Definitions.DestinyItemSetBlockEntryDefinition itemList = 1;
    // If true, items in the set can only be added in increasing order, and adding an item will remove any previous item. For Quests, this is by necessity true. Only one quest step is present at a time, and previous steps are removed as you advance in the quest.
    bool requireOrderedSetItemAdd = 2;
    // If true, the UI should treat this quest as "featured"
    bool setIsFeatured = 3;
    // A string identifier we can use to attempt to identify the category of the Quest.
    string setType = 4;
}

message Destiny.Definitions.DestinyItemSetBlockEntryDefinition {
    // This is the hash identifier for a DestinyInventoryItemDefinition representing this quest step.
    uint32 itemHash = 1;
    // Used for tracking which step a user reached. These values will be populated in the user's internal state, which we expose externally as a more usable DestinyQuestStatus object. If this item has been obtained, this value will be set in trackingUnlockValueHash.
    int32 trackingValue = 2;
}

message Destiny.Definitions.DestinyItemSocketBlockDefinition {
    // This was supposed to be a string that would give per-item details about sockets. In practice, it turns out that all this ever has is the localized word "details". ... that's lame, but perhaps it will become something cool in the future.
    string detail = 1;
    // A convenience property, that refers to the sockets in the "sockets" property, pre-grouped by category and ordered in the manner that they should be grouped in the UI. You could form this yourself with the existing data, but why would you want to? Enjoy life man.
    repeated Destiny.Definitions.DestinyItemSocketCategoryDefinition socketCategories = 2;
    // Each socket on an item is defined here. Check inside for more info.
    repeated Destiny.Definitions.DestinyItemSocketEntryDefinition socketEntries = 3;
}

message Destiny.Definitions.DestinyItemSocketCategoryDefinition {
    // The hash for the Socket Category: a quick way to go get the header display information for the category. Use it to look up DestinySocketCategoryDefinition info.
    uint32 socketCategoryHash = 1;
    // Use these indexes to look up the sockets in the "sockets.socketEntries" property on the item definition. These are the indexes under the category, in game-rendered order.
    repeated int32 socketIndexes = 2;
}

message Destiny.Definitions.DestinyItemSocketEntryDefinition {
    // This is a list of pre-determined plugs that can *always* be plugged into this socket, without the character having the plug in their inventory.
    // If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.
    repeated Destiny.Definitions.DestinyItemSocketEntryPlugItemDefinition reusablePlugItems = 1;
    // If a valid hash, this is the hash identifier for the DestinyInventoryItemDefinition representing the Plug that will be initially inserted into the item on item creation. Otherwise, this Socket will either start without a plug inserted, or will have one randomly inserted.
    uint32 singleInitialItemHash = 2;
    // All sockets have a type, and this is the hash identifier for this particular type. Use it to look up the DestinySocketTypeDefinition: read there for more information on how socket types affect the behavior of the socket.
    uint32 socketTypeHash = 3;
}

message Destiny.Definitions.DestinyItemSocketEntryPlugItemDefinition {
    // The hash identifier of a DestinyInventoryItemDefinition representing the plug that can be inserted.
    uint32 plugItemHash = 1;
}

message Destiny.Definitions.DestinyItemSourceBlockDefinition {
    // If we found that this item is exclusive to a specific platform, this will be set to the BungieMembershipType enumeration that matches that platform.
    message Exclusive {
    }
    Exclusive exclusive = 1;
    // The list of hash identifiers for Reward Sources that hint where the item can be found (DestinyRewardSourceDefinition).
    repeated uint32 sourceHashes = 2;
    // A collection of details about the stats that were computed for the ways we found that the item could be spawned.
    repeated Destiny.Definitions.Sources.DestinyItemSourceDefinition sources = 3;
}

message Destiny.Definitions.DestinyItemStatBlockDefinition {
    // A quick and lazy way to determine whether any stat other than the "primary" stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they're not part of the "Stat Group" and thus we wouldn't display them in our UI. If this is False, then we're not going to display any of these stats other than the primary one.
    bool hasDisplayableStats = 1;
    // This stat is determined to be the "primary" stat, and can be looked up in the stats or any other stat collection related to the item.
    // Use this hash to look up the stat's value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.
    uint32 primaryBaseStatHash = 2;
    // If the item's stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.
    // If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don't have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.
    uint32 statGroupHash = 3;
    // If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the "Display" stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it's a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.
    // These stats are keyed by the DestinyStatDefinition's hash identifier for the stat that's found on the item.
    map<string, Destiny.Definitions.DestinyInventoryItemStatDefinition> stats = 4;
}

message Destiny.Definitions.DestinyItemSummaryBlockDefinition {
    // Apparently when rendering an item in a reward, this should be used as a sort priority. We're not doing it presently.
    int32 sortPriority = 1;
}

message Destiny.Definitions.DestinyItemTalentGridBlockDefinition {
    // A shortcut string identifier for the "build" in question, if this talent grid has an associated build. Doesn't map to anything we can expose at the moment.
    string buildName = 1;
    // If the talent grid implies a damage type, this is the enum value for that damage type.
    message HudDamageType {
    }
    HudDamageType hudDamageType = 2;
    // If the talent grid has a special icon that's shown in the game UI (like builds, funny that), this is the identifier for that icon. Sadly, we don't actually get that icon right now. I'll be looking to replace this with a path to the actual icon itself.
    string hudIcon = 3;
    // This is meant to be a subtitle for looking at the talent grid. In practice, somewhat frustratingly, this always merely says the localized word for "Details". Great. Maybe it'll have more if talent grids ever get used for more than builds and subclasses again.
    string itemDetailString = 4;
    // The hash identifier of the DestinyTalentGridDefinition attached to this item.
    uint32 talentGridHash = 5;
}

message Destiny.Definitions.DestinyItemTranslationBlockDefinition {
    repeated Destiny.Definitions.DestinyGearArtArrangementReference arrangements = 1;
    repeated Destiny.DyeReference customDyes = 2;
    repeated Destiny.DyeReference defaultDyes = 3;
    bool hasGeometry = 4;
    repeated Destiny.DyeReference lockedDyes = 5;
    uint32 weaponPatternHash = 6;
    string weaponPatternIdentifier = 7;
}

message Destiny.Definitions.DestinyItemValueBlockDefinition {
    // References to the items that make up this item's "value", and the quantity.
    repeated Destiny.DestinyItemQuantity itemValue = 1;
    // If there's a localized text description of the value provided, this will be said description.
    string valueDescription = 2;
}

message Destiny.Definitions.DestinyLocationDefinition {
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 1;
    // The index of the entity as it was found in the investment tables.
    int32 index = 2;
    // A Location may refer to different specific spots in the world based on the world's current state. This is a list of those potential spots, and the data we can use at runtime to determine which one of the spots is the currently valid one.
    repeated Destiny.Definitions.DestinyLocationReleaseDefinition locationReleases = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
    // If the location has a Vendor on it, this is the hash identifier for that Vendor. Look them up with DestinyVendorDefinition.
    uint32 vendorHash = 5;
}

message Destiny.Definitions.DestinyLocationReleaseDefinition {
    // The Activity Bubble within the Destination. Look this up in the DestinyDestinationDefinition's bubbles and bubbleSettings properties.
    uint32 activityBubbleName = 1;
    // The Activity Graph being pointed to by this location.
    uint32 activityGraphHash = 2;
    // The Activity Graph Node being pointed to by this location. (Remember that Activity Graph Node hashes are only unique within an Activity Graph: so use the combination to find the node being spoken of)
    uint32 activityGraphNodeHash = 3;
    // The Activity being pointed to by this location.
    uint32 activityHash = 4;
    // If we had map information, this would tell us something cool about the path this location wants you to take. I wish we had map information.
    uint32 activityPathBundle = 5;
    // If we had map information, this would tell us about path information related to destination on the map. Sad. Maybe you can do something cool with it. Go to town man.
    uint32 activityPathDestination = 6;
    // The Destination being pointed to by this location.
    uint32 destinationHash = 7;
    // Sadly, these don't appear to be populated anymore (ever?)
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 8;
    // The type of Nav Point that this represents. See the enumeration for more info.
    message NavPointType {
    }
    NavPointType navPointType = 9;
    // If we had map information, this spawnPoint would be interesting. But sadly, we don't have that info.
    uint32 spawnPoint = 10;
    // Looks like it should be the position on the map, but sadly it does not look populated... yet?
    repeated int32 worldPosition = 11;
}

message Destiny.Definitions.DestinyMaterialRequirement {
    // The amount of the material required.
    int32 count = 1;
    // If True, the material will be removed from the character's inventory when the action is performed.
    bool deleteOnAction = 2;
    // The hash identifier of the material required. Use it to look up the material's DestinyInventoryItemDefinition.
    uint32 itemHash = 3;
    // If True, this requirement is "silent": don't bother showing it in a material requirements display. I mean, I'm not your mom: I'm not going to tell you you *can't* show it. But we won't show it in our UI.
    bool omitFromRequirements = 4;
}

message Destiny.Definitions.DestinyMaterialRequirementSetDefinition {
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 1;
    // The index of the entity as it was found in the investment tables.
    int32 index = 2;
    // The list of all materials that are required.
    repeated Destiny.Definitions.DestinyMaterialRequirement materials = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
}

message Destiny.Definitions.DestinyNodeActivationRequirement {
    // The Progression level on the Talent Grid required to activate this node.
    // See DestinyTalentGridDefinition.progressionHash for the related Progression, and read DestinyProgressionDefinition's documentation to learn more about Progressions.
    int32 gridLevel = 1;
    // The list of hash identifiers for material requirement sets: materials that are required for the node to be activated. See DestinyMaterialRequirementSetDefinition for more information about material requirements.
    // In this case, only a single DestinyMaterialRequirementSetDefinition will be chosen from this list, and we won't know which one will be chosen until an instance of the item is created.
    repeated uint32 materialRequirementHashes = 2;
}

message Destiny.Definitions.DestinyNodeSocketReplaceResponse {
    // The hash identifier of the plug item that will be inserted into the socket found.
    uint32 plugItemHash = 1;
    // The hash identifier of the socket type to find amidst the item's sockets (the item to which this talent grid is attached). See DestinyInventoryItemDefinition.sockets.socketEntries to find the socket type of sockets on the item in question.
    uint32 socketTypeHash = 2;
}

message Destiny.Definitions.DestinyNodeStepDefinition {
    // If the step has requirements for activation (they almost always do, if nothing else than for the Talent Grid's Progression to have reached a certain level), they will be defined here.
    message ActivationRequirement {
    }
    ActivationRequirement activationRequirement = 1;
    // If true, this step can affect the level of the item. See DestinyInventoryItemDefintion for more information about item levels and their effect on stats.
    bool affectsLevel = 2;
    // If this is true, the step affects the item's Quality in some way. See DestinyInventoryItemDefinition for more information about the meaning of Quality. I already made a joke about Zen and the Art of Motorcycle Maintenance elsewhere in the documentation, so I will avoid doing it again. Oops too late
    bool affectsQuality = 3;
    // There was a time when talent nodes could be activated multiple times, and the effects of subsequent Steps would be compounded on each other, essentially "upgrading" the node. We have moved away from this, but theoretically the capability still exists.
    // I continue to return this in case it is used in the future: if true and this step is the current step in the node, you are allowed to activate the node a second time to receive the benefits of the next step in the node, which will then become the active step.
    bool canActivateNextStep = 4;
    // An enum representing a damage type granted by activating this step, if any.
    message DamageType {
    }
    DamageType damageType = 5;
    // If the step provides a damage type, this will be the hash identifier used to look up the damage type's DestinyDamageTypeDefinition.
    uint32 damageTypeHash = 6;
    // These are the display properties actually used to render the Talent Node. The currently active step's displayProperties are shown.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 7;
    // If you can interact with this node in some way, this is the localized description of that interaction.
    string interactionDescription = 8;
    // If true, the next step to be chosen is random, and if you're allowed to activate the next step. (if canActivateNextStep = true)
    bool isNextStepRandom = 9;
    // The stepIndex of the next step in the talent node, or -1 if this is the last step or if the next step to be chosen is random.
    // This doesn't really matter anymore unless canActivateNextStep begins to be used again.
    int32 nextStepIndex = 10;
    // The hash of this node step. Unfortunately, while it can be used to uniquely identify the step within a node, it is also content version dependent and should not be relied on without ensuring you have the latest vesion of content.
    uint32 nodeStepHash = 11;
    // The list of hash identifiers for Perks (DestinySandboxPerkDefinition) that are applied when this step is active. Perks provide a variety of benefits and modifications - examine DestinySandboxPerkDefinition to learn more.
    repeated uint32 perkHashes = 12;
    // If this step is activated, this will be a list of information used to replace socket items with new Plugs. See DestinyInventoryItemDefinition for more information about sockets and plugs.
    repeated Destiny.Definitions.DestinyNodeSocketReplaceResponse socketReplacements = 13;
    // When the Talent Grid's progression reaches this value, the circular "progress bar" that surrounds the talent node should be shown.
    // This also indicates the lower bound of said progress bar, with the upper bound being the progress required to reach activationRequirement.gridLevel. (at some point I should precalculate the upper bound and put it in the definition to save people time)
    int32 startProgressionBarAtProgress = 14;
    // When the step provides stat benefits on the item or character, this is the list of hash identifiers for stats (DestinyStatDefinition) that are provided.
    repeated uint32 statHashes = 15;
    // In Destiny 1, the Armory's Perk Filtering was driven by a concept of TalentNodeStepGroups: categorizations of talent nodes based on their functionality. While the Armory isn't a BNet-facing thing for now, and the new Armory will need to account for Sockets rather than Talent Nodes, this categorization capability feels useful enough to still keep around.
    message StepGroups {
    }
    StepGroups stepGroups = 16;
    // The index of this step in the list of Steps on the Talent Node.
    // Unfortunately, this is the closest thing we have to an identifier for the Step: steps are not provided a content version agnostic identifier. This means that, when you are dealing with talent nodes, you will need to first ensure that you have the latest version of content.
    int32 stepIndex = 17;
}

message Destiny.Definitions.DestinyObjectiveDefinition {
    // If true, the value is allowed to go negative.
    bool allowNegativeValue = 1;
    // If true, you can effectively "un-complete" this objective if you lose progress after crossing the completion threshold. 
    // If False, once you complete the task it will remain completed forever by locking the value.
    bool allowValueChangeWhenCompleted = 2;
    // The value that the unlock value defined in unlockValueHash must reach in order for the objective to be considered Completed. Used in calculating progress and completion status.
    int32 completionValue = 3;
    // Ideally, this should tell you what your task is. I'm not going to lie to you though. Sometimes this doesn't have useful information at all. Which sucks, but there's nothing either of us can do about it.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 4;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 5;
    // The index of the entity as it was found in the investment tables.
    int32 index = 6;
    // If true, completion means having an unlock value less than or equal to the completionValue.
    // If False, completion means having an unlock value greater than or equal to the completionValue.
    bool isCountingDownward = 7;
    // OPTIONAL: a hash identifier for the location at which this objective must be accomplished, if there is a location defined. Look up the DestinyLocationDefinition for this hash for that additional location info.
    uint32 locationHash = 8;
    // If this objective enables Perks intrinsically, the conditions for that enabling are defined here.
    message Perks {
    }
    Perks perks = 9;
    // Text to describe the progress bar.
    string progressDescription = 10;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 11;
    // If this objective enables modifications on a player's stats intrinsically, the conditions are defined here.
    message Stats {
    }
    Stats stats = 12;
    // The UI style applied to the objective. It's an enum, take a look at DestinyUnlockValueUIStyle for details of the possible styles. Use this info as you wish to customize your UI.
    message ValueStyle {
    }
    ValueStyle valueStyle = 13;
}

message Destiny.Definitions.DestinyObjectivePerkEntryDefinition {
    // The hash identifier of the DestinySandboxPerkDefinition that will be applied to the character.
    uint32 perkHash = 1;
    // An enumeration indicating whether it will be applied as long as the Objective is active, when it's completed, or until it's completed.
    message Style {
    }
    Style style = 2;
}

message Destiny.Definitions.DestinyObjectiveStatEntryDefinition {
    // The stat being modified, and the value used.
    message Stat {
    }
    Stat stat = 1;
    // Whether it will be applied as long as the objective is active, when it's completed, or until it's completed.
    message Style {
    }
    Style style = 2;
}

message Destiny.Definitions.DestinyPlaceDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
}

message Destiny.Definitions.DestinyProgressionDefinition {
    Destiny.Definitions.DestinyProgressionDisplayPropertiesDefinition displayProperties = 1;
    // If the value exists, this is the hash identifier for the Faction that owns this Progression.
    // This is purely for convenience, if you're looking at a progression and want to know if and who it's related to in terms of Faction Reputation.
    uint32 factionHash = 2;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 3;
    // The index of the entity as it was found in the investment tables.
    int32 index = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
    // If this is True, then the progression doesn't have a maximum level.
    bool repeatLastStep = 6;
    // The "Scope" of the progression indicates the source of the progression's live data.
    // See the DestinyProgressionScope enum for more info: but essentially, a Progression can either be backed by a stored value, or it can be a calculated derivative of other values.
    message Scope {
    }
    Scope scope = 7;
    // If there's a description of how to earn this progression in the local config, this will be that localized description.
    string source = 8;
    // Progressions are divided into Steps, which roughly equate to "Levels" in the traditional sense of a Progression. Notably, the last step can be repeated indefinitely if repeatLastStep is true, meaning that the calculation for your level is not as simple as comparing your current progress to the max progress of the steps. 
    // These and more calculations are done for you if you grab live character progression data, such as in the DestinyCharacterProgressionComponent.
    repeated Destiny.Definitions.DestinyProgressionStepDefinition steps = 9;
    // If true, the Progression is something worth showing to users.
    // If false, BNet isn't going to show it. But that doesn't mean you can't. We're all friends here.
    bool visible = 10;
}

message Destiny.Definitions.DestinyProgressionDisplayPropertiesDefinition {
    string description = 1;
    // When progressions show your "experience" gained, that bar has units (i.e. "Experience", "Bad Dudes Snuffed Out", whatever). This is the localized string for that unit of measurement.
    string displayUnitsName = 2;
    bool hasIcon = 3;
    // Note that "icon" is sometimes misleading, and should be interpreted in the context of the entity. For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.
    // But usually, it will be a small square image that you can use as... well, an icon.
    string icon = 4;
    string name = 5;
}

message Destiny.Definitions.DestinyProgressionMappingDefinition {
    // Infrequently defined in practice. Defer to the individual progressions' display properties.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // The localized unit of measurement for progression across the progressions defined in this mapping. Unfortunately, this is very infrequently defined. Defer to the individual progressions' display units.
    string displayUnits = 2;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 3;
    // The index of the entity as it was found in the investment tables.
    int32 index = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
}

message Destiny.Definitions.DestinyProgressionRewardDefinition {
    // The amount of experience to give to each of the mapped progressions.
    int32 amount = 1;
    // If true, the game's internal mechanisms to throttle progression should be applied.
    bool applyThrottles = 2;
    // The hash identifier of the DestinyProgressionMappingDefinition that contains the progressions for which experience should be applied.
    uint32 progressionMappingHash = 3;
}

message Destiny.Definitions.DestinyProgressionStepDefinition {
    // This appears to be, when you "level up", whether a visual effect will display and on what entity. See DestinyProgressionStepDisplayEffect for slightly more info.
    message DisplayEffectType {
    }
    DisplayEffectType displayEffectType = 1;
    // The total amount of progression points/"experience" you will need to initially reach this step. If this is the last step and the progression is repeating indefinitely (DestinyProgressionDefinition.repeatLastStep), this will also be the progress needed to level it up further by repeating this step again.
    int32 progressTotal = 2;
    // A listing of items rewarded as a result of reaching this level.
    repeated Destiny.DestinyItemQuantity rewardItems = 3;
    // Very rarely, Progressions will have localized text describing the Level of the progression. This will be that localized text, if it exists. Otherwise, the standard appears to be to simply show the level numerically.
    string stepName = 4;
}

message Destiny.Definitions.DestinyRaceDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // A localized string referring to the singular form of the Race's name when referred to in gendered form. Keyed by the DestinyGender.
    map<string, string> genderedRaceNames = 2;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 3;
    // The index of the entity as it was found in the investment tables.
    int32 index = 4;
    // An enumeration defining the existing, known Races/Species for player characters. This value will be the enum value matching this definition.
    message RaceType {
    }
    RaceType raceType = 5;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 6;
}

message Destiny.Definitions.DestinyRewardSourceDefinition {
    // Sources are grouped into categories: common ways that items are provided. I hope to see this expand in Destiny 2 once we have time to generate accurate reward source data.
    message Category {
    }
    Category category = 1;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 2;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 3;
    // The index of the entity as it was found in the investment tables.
    int32 index = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
}

message Destiny.Definitions.DestinySandboxPerkDefinition {
    // If this perk grants a damage type to a weapon, the damage type will be defined here.
    // Unless you have a compelling reason to use this enum value, use the damageTypeHash instead to look up the actual DestinyDamageTypeDefinition.
    message DamageType {
    }
    DamageType damageType = 1;
    // The hash identifier for looking up the DestinyDamageTypeDefinition, if this perk has a damage type.
    // This is preferred over using the damageType enumeration value, which has been left purely because it is occasionally convenient.
    uint32 damageTypeHash = 2;
    // These display properties are by no means guaranteed to be populated. Usually when it is, it's only because we back-filled them with the displayProperties of some Talent Node or Plug item that happened to be uniquely providing that perk.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 3;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 4;
    // The index of the entity as it was found in the investment tables.
    int32 index = 5;
    // If true, you can actually show the perk in the UI. Otherwise, it doesn't have useful player-facing information.
    bool isDisplayable = 6;
    // An old holdover from the original Armory, this was an attempt to group perks by functionality.
    // It is as yet unpopulated, and there will be quite a bit of work needed to restore it to its former working order.
    message PerkGroups {
    }
    PerkGroups perkGroups = 7;
    // The string identifier for the perk.
    string perkIdentifier = 8;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 9;
}

message Destiny.Definitions.DestinyStatDefinition {
    // Stats can exist on a character or an item, and they may potentially be aggregated in different ways. The DestinyStatAggregationType enum value indicates the way that this stat is being aggregated.
    message AggregationType {
    }
    AggregationType aggregationType = 1;
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 2;
    // True if the stat is computed rather than being delivered as a raw value on items.
    // For instance, the Light stat in Destiny 1 was a computed stat.
    bool hasComputedBlock = 3;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 4;
    // The index of the entity as it was found in the investment tables.
    int32 index = 5;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 6;
}

message Destiny.Definitions.DestinyStatDisplayDefinition {
    // If this is true, the stat should be displayed as a number. Otherwise, display it as a progress bar. Or, you know, do whatever you want. There's no displayAsNumeric police.
    bool displayAsNumeric = 1;
    // The interpolation table representing how the Investment Stat is transformed into a Display Stat. 
    // See DestinyStatDefinition for a description of the stages of stat transformation.
    repeated Interpolation.InterpolationPoint displayInterpolation = 2;
    // Regardless of the output of interpolation, this is the maximum possible value that the stat can be. It should also be used as the upper bound for displaying the stat as a progress bar (the minimum always being 0)
    int32 maximumValue = 3;
    // The hash identifier for the stat being transformed into a Display stat.
    // Use it to look up the DestinyStatDefinition, or key into a DestinyInventoryItemDefinition's stats property.
    uint32 statHash = 4;
}

message Destiny.Definitions.DestinyStatGroupDefinition {
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 1;
    // The index of the entity as it was found in the investment tables.
    int32 index = 2;
    // The maximum possible value that any stat in this group can be transformed into.
    // This is used by stats that *don't* have scaledStats entries below, but that still need to be displayed as a progress bar, in which case this is used as the upper bound for said progress bar. (the lower bound is always 0)
    int32 maximumValue = 3;
    // The game has the ability to override, based on the stat group, what the localized text is that is displayed for Stats being shown on the item.
    // Mercifully, no Stat Groups use this feature currently. If they start using them, we'll all need to start using them (and those of you who are more prudent than I am can go ahead and start pre-checking for this.)
    map<string, Destiny.Definitions.DestinyStatOverrideDefinition> overrides = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
    // Any stat that requires scaling to be transformed from an "Investment" stat to a "Display" stat will have an entry in this list. For more information on what those types of stats mean and the transformation process, see DestinyStatDefinition.
    // In retrospect, I wouldn't mind if this was a dictionary keyed by the stat hash instead. But I'm going to leave it be because [[After Apple Picking]].
    repeated Destiny.Definitions.DestinyStatDisplayDefinition scaledStats = 6;
    // This apparently indicates the position of the stats in the UI? I've returned it in case anyone can use it, but it's not of any use to us on BNet. Something's being lost in translation with this value.
    int32 uiPosition = 7;
}

message Destiny.Definitions.DestinyStatOverrideDefinition {
    // The display properties to show instead of the base DestinyStatDefinition display properties.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // The hash identifier of the stat whose display properties are being overridden.
    uint32 statHash = 2;
}

message Destiny.Definitions.DestinyTalentExclusiveGroup {
    // The identifier for this exclusive group. Only guaranteed unique within the talent grid, not globally.
    uint32 groupHash = 1;
    // If this group has an associated piece of lore to show next to it, this will be the identifier for that DestinyLoreDefinition.
    uint32 loreHash = 2;
    // A quick reference of the talent nodes that are part of this group, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)
    repeated uint32 nodeHashes = 3;
    // A quick reference of Groups whose nodes will be deactivated if any node in this group is activated.
    repeated uint32 opposingGroupHashes = 4;
    // A quick reference of Nodes that will be deactivated if any node in this group is activated, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)
    repeated uint32 opposingNodeHashes = 5;
}

message Destiny.Definitions.DestinyTalentGridDefinition {
    // Talent Nodes can exist in "exclusive sets": these are sets of nodes in which only a single node in the set can be activated at any given time. Activating a node in this set will automatically deactivate the other nodes in the set (referred to as a "Swap").
    // If a node in the exclusive set has already been activated, the game will not charge you materials to activate another node in the set, even if you have never activated it before, because you already paid the cost to activate one node in the set.
    // Not to be confused with Exclusive Groups. (how the heck do we NOT get confused by that? Jeez) See the groups property for information about that only-tangentially-related concept.
    repeated Destiny.Definitions.DestinyTalentNodeExclusiveSetDefinition exclusiveSets = 1;
    // The meaning of this has been lost in the sands of time: it still exists as a property, but appears to be unused in the modern UI of talent grids. It used to imply that each visual "column" of talent nodes required identical progression levels in order to be activated. Returning this value in case it is still useful to someone? Perhaps it's just a bit of interesting history.
    int32 gridLevelPerColumn = 2;
    // Talent Nodes can have "Exclusive Groups". These are not to be confused with Exclusive Sets (see exclusiveSets property).
    // Look at the definition of DestinyTalentExclusiveGroup for more information and how they work. These groups are keyed by the "groupHash" from DestinyTalentExclusiveGroup.
    map<string, Destiny.Definitions.DestinyTalentExclusiveGroup> groups = 3;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 4;
    // This is a quick reference to the indexes of nodes that are not part of exclusive sets. Handy for knowing which talent nodes can only be activated directly, rather than via swapping.
    repeated int32 independentNodeIndexes = 5;
    // The index of the entity as it was found in the investment tables.
    int32 index = 6;
    // The maximum possible level of the Talent Grid: at this level, any nodes are allowed to be activated.
    int32 maxGridLevel = 7;
    // BNet wants to show talent nodes grouped by similar purpose with localized titles. This is the ordered list of those categories: if you want to show nodes by category, you can iterate over this list, render the displayProperties for the category as the title, and then iterate over the talent nodes referenced by the category to show the related nodes.
    // Note that this is different from Exclusive Groups or Sets, because these categories also incorporate "Independent" nodes that belong to neither sets nor groups. These are purely for visual grouping of nodes rather than functional grouping.
    repeated Destiny.Definitions.DestinyTalentNodeCategory nodeCategories = 8;
    // The list of Talent Nodes on the Grid (recall that Nodes themselves are really just locations in the UI to show whatever their current Step is. You will only know the current step for a node by retrieving instanced data through platform calls to the API that return DestinyItemTalentGridComponent).
    repeated Destiny.Definitions.DestinyTalentNodeDefinition nodes = 9;
    // The hash identifier of the Progression (DestinyProgressionDefinition) that drives whether and when Talent Nodes can be activated on the Grid. Items will have instances of this Progression, and will gain experience that will eventually cause the grid to increase in level. As the grid's level increases, it will cross the threshold where nodes can be activated. See DestinyTalentGridStepDefinition's activation requirements for more information.
    uint32 progressionHash = 10;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 11;
}

message Destiny.Definitions.DestinyTalentNodeCategory {
    // Will contain at least the "name", which will be the title of the category. We will likely not have description and an icon yet, but I'm going to keep my options open.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // Mostly just for debug purposes, but if you find it useful you can have it. This is BNet's manually created identifier for this category.
    string identifier = 2;
    // If true, we found the localized content in a related DestinyLoreDefinition instead of local BNet localization files. This is mostly for ease of my own future investigations.
    bool isLoreDriven = 3;
    // The set of all hash identifiers for Talent Nodes (DestinyTalentNodeDefinition) in this Talent Grid that are part of this Category.
    repeated uint32 nodeHashes = 4;
}

message Destiny.Definitions.DestinyTalentNodeDefinition {
    // If true, this node will automatically unlock when the Talent Grid's level reaches the required level of the current step of this node.
    bool autoUnlocks = 1;
    // At one point, Talent Nodes supported the idea of "Binary Pairs": nodes that overlapped each other visually, and where activating one deactivated the other. They ended up not being used, mostly because Exclusive Sets are *almost* a superset of this concept, but the potential for it to be used still exists in theory.
    // If this is ever used, this will be the index into the DestinyTalentGridDefinition.nodes property for the node that is the binary pair match to this node. Activating one deactivates the other.
    int32 binaryPairNodeIndex = 2;
    // The visual "column" where the node should be shown in the UI. If negative, the node is hidden.
    int32 column = 3;
    // The nodeHash values for nodes that are in an Exclusive Set with this node.
    // See DestinyTalentGridDefinition.exclusiveSets for more info about exclusive sets.
    // Again, note that these are nodeHashes and *not* nodeIndexes.
    repeated uint32 exclusiveWithNodeHashes = 4;
    // As of Destiny 2, nodes can exist as part of "Exclusive Groups". These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause "opposing" nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.
    // See DestinyTalentExclusiveGroup for more information on the details. This is an identifier for this node's group, if it is part of one.
    uint32 groupHash = 5;
    // Comes from the talent grid node style: if true, then this node should be ignored for determining whether the grid is complete.
    bool ignoreForCompletion = 6;
    // If this is true, the node's step is determined randomly rather than the first step being chosen.
    bool isRandom = 7;
    // If this is true, the node can be "re-rolled" to acquire a different random current step. This is not used, but still exists for a theoretical future of talent grids.
    bool isRandomRepurchasable = 8;
    // At one point, Nodes were going to be able to be activated multiple times, changing the current step and potentially piling on multiple effects from the previously activated steps. This property would indicate if the last step could be activated multiple times. 
    // This is not currently used, but it isn't out of the question that this could end up being used again in a theoretical future.
    bool lastStepRepeats = 9;
    // A string identifier for a custom visual layout to apply to this talent node. Unfortunately, we do not have any data for rendering these custom layouts. It will be up to you to interpret these strings and change your UI if you want to have custom UI matching these layouts.
    string layoutIdentifier = 10;
    // Talent nodes can be associated with a piece of Lore, generally rendered in a tooltip. This is the hash identifier of the lore element to show, if there is one to be show.
    uint32 loreHash = 11;
    // The hash identifier for the node, which unfortunately is also content version dependent but can be (and ideally, should be) used instead of the nodeIndex to uniquely identify the node.
    // The two exist side-by-side for backcompat reasons due to the Great Talent Node Restructuring of Destiny 1, and I ran out of time to remove one of them and standardize on the other. Sorry!
    uint32 nodeHash = 12;
    // The index into the DestinyTalentGridDefinition's "nodes" property where this node is located. Used to uniquely identify the node within the Talent Grid. Note that this is content version dependent: make sure you have the latest version of content before trying to use these properties.
    int32 nodeIndex = 13;
    // Comes from the talent grid node style: this identifier should be used to determine how to render the node in the UI.
    string nodeStyleIdentifier = 14;
    // Indexes into the DestinyTalentGridDefinition.nodes property for any nodes that must be activated before this one is allowed to be activated.
    // I would have liked to change this to hashes for Destiny 2, but we have run out of time.
    repeated int32 prerequisiteNodeIndexes = 15;
    // At one point, you were going to be able to repurchase talent nodes that had random steps, to "re-roll" the current step of the node (and thus change the properties of your item). This was to be the activation requirement for performing that re-roll.
    // The system still exists to do this, as far as I know, so it may yet come back around!
    message RandomActivationRequirement {
    }
    RandomActivationRequirement randomActivationRequirement = 16;
    // If the node's step is randomly selected, this is the amount of the Talent Grid's progression experience at which the progression bar for the node should be shown.
    int32 randomStartProgressionBarAtProgression = 17;
    // The visual "row" where the node should be shown in the UI. If negative, then the node is hidden.
    int32 row = 18;
    // At this point, "steps" have been obfuscated into conceptual entities, aggregating the underlying notions of "properties" and "true steps".
    // If you need to know a step as it truly exists - such as when recreating Node logic when processing Vendor data - you'll have to use the "realSteps" property below.
    repeated Destiny.Definitions.DestinyNodeStepDefinition steps = 19;
}

message Destiny.Definitions.DestinyTalentNodeExclusiveSetDefinition {
    // The list of node indexes for the exclusive set. Historically, these were indexes. I would have liked to replace this with nodeHashes for consistency, but it's way too late for that. (9:09 PM, he's right!)
    repeated int32 nodeIndexes = 1;
}

message Destiny.Definitions.DestinyTalentNodeStepGroups {
    integer damageTypes = 1;
    integer guardianAttributes = 2;
    integer impactEffects = 3;
    integer lightAbilities = 4;
    integer weaponPerformance = 5;
}

message Destiny.Definitions.DestinyUnlockDefinition {
    // Sometimes, but not frequently, these unlock flags also have human readable information: usually when they are being directly tested for some requirement, in which case the string is a localized description of why the requirement check failed.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
}

message Destiny.Definitions.DestinyUnlockExpressionDefinition {
    // A shortcut for determining the most restrictive gating that this expression performs. See the DestinyGatingScope enum's documentation for more details.
    message Scope {
    }
    Scope scope = 1;
}

message Destiny.Definitions.DestinyVendorAcceptedItemDefinition {
    // The "source" bucket for a transfer. When a user wants to transfer an item, the appropriate DestinyVendorDefinition's acceptedItems property is evaluated, looking for an entry where acceptedInventoryBucketHash matches the bucket that the item being transferred is currently located. If it exists, the item will be transferred into whatever bucket is defined by destinationInventoryBucketHash.
    uint32 acceptedInventoryBucketHash = 1;
    // This is the bucket where the item being transferred will be put, given that it was being transferred *from* the bucket defined in acceptedInventoryBucketHash.
    uint32 destinationInventoryBucketHash = 2;
}

message Destiny.Definitions.DestinyVendorActionDefinition {
    uint32 actionHash = 1;
    string actionId = 2;
    bool autoPerformAction = 3;
    string description = 4;
    int32 executeSeconds = 5;
    string icon = 6;
    bool isPositive = 7;
    string name = 8;
    string verb = 9;
}

message Destiny.Definitions.DestinyVendorCategoryEntryDefinition {
    // The localized string for making purchases from this category, if it is different from the vendor's string for purchasing.
    string buyStringOverride = 1;
    // The hashed identifier for the category. (note that this is NOT pointing to a DestinyVendorCategoryDefinition, it's confusing but this is a sale item category in a vendor, not a categorization of vendors themselves)
    uint32 categoryHash = 2;
    // The string identifier of the category.
    string categoryId = 3;
    // The index of the category in the original category definitions for the vendor.
    int32 categoryIndex = 4;
    // If the category is disabled, this is the localized description to show.
    string disabledDescription = 5;
    // The localized title of the category.
    string displayTitle = 6;
    // True if this category doesn't allow purchases.
    bool hideFromRegularPurchase = 7;
    // If you don't have the currency required to buy items from this category, should the items be hidden?
    bool hideIfNoCurrency = 8;
    // If this category has an overlay prompt that should appear, this contains the details of that prompt.
    message Overlay {
    }
    Overlay overlay = 9;
    // The amount of items that will be available when this category is shown.
    int32 quantityAvailable = 10;
    // If items aren't up for sale in this category, should we still show them (greyed out)?
    bool showUnavailableItems = 11;
}

message Destiny.Definitions.DestinyVendorCategoryOverlayDefinition {
    string choiceDescription = 1;
    string description = 2;
    string icon = 3;
    string title = 4;
}

message Destiny.Definitions.DestinyVendorDefinition {
    // If the Vendor is actually a vehicle for the transferring of items (like the Vault and Postmaster vendors), this defines the list of source->destination buckets for transferring.
    repeated Destiny.Definitions.DestinyVendorAcceptedItemDefinition acceptedItems = 1;
    // Describes "actions" that can be performed on a vendor. Currently, none of these exist. But theoretically a Vendor could let you interact with it by performing actions. We'll see what these end up looking like if they ever get used.
    repeated Destiny.Definitions.DestinyVendorActionDefinition actions = 2;
    // If the vendor has a custom localized string describing the "buy" action, that is returned here.
    string buyString = 3;
    // These are the headers for sections of items that the vendor is selling. When you see items organized by category in the header, it is these categories that it is showing.
    // Well, technically not *exactly* these. On BNet, it doesn't make sense to have categories be "paged" as we do in Destiny, so we run some heuristics to attempt to aggregate pages of categories together. 
    // These are the categories post-concatenation, if the vendor had concatenation applied. If you want the pre-aggregated category data, use originalCategories.
    repeated Destiny.Definitions.DestinyVendorCategoryEntryDefinition categories = 4;
    // If TRUE, consolidate categories that only differ by trivial properties (such as having minor differences in name)
    bool consolidateCategories = 5;
    // Display Categories are different from "categories" in that these are specifically for visual grouping and display of categories in Vendor UI. 
    // The "categories" structure is for validation of the contained items, and can be categorized entirely separately from "Display Categories", there need be and often will be no meaningful relationship between the two.
    repeated Destiny.Definitions.DestinyDisplayCategoryDefinition displayCategories = 6;
    // If the vendor has an item that should be displayed as the "featured" item, this is the hash identifier for that DestinyVendorItemDefinition.
    // Apparently this is usually a related currency, like a reputation token. But it need not be restricted to that.
    uint32 displayItemHash = 7;
    Destiny.Definitions.DestinyVendorDisplayPropertiesDefinition displayProperties = 8;
    // If a vendor is not enabled, we won't even save the vendor's definition, and we won't return any items or info about them. It's as if they don't exist.
    bool enabled = 9;
    // If the Vendor has a faction, this hash will be valid and point to a DestinyFactionDefinition.
    // The game UI and BNet often mine the faction definition for additional elements and details to place on the screen, such as the faction's Progression status (aka "Reputation").
    uint32 factionHash = 10;
    // If an item can't be purchased from the vendor, there may be many "custom"/game state specific reasons why not.
    // This is a list of localized strings with messages for those custom failures. The live BNet data will return a failureIndexes property for items that can't be purchased: using those values to index into this array, you can show the user the appropriate failure message for the item that can't be bought.
    repeated string failureStrings = 11;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 12;
    // The index of the entity as it was found in the investment tables.
    int32 index = 13;
    // If this is true, you aren't allowed to buy whatever the vendor is selling.
    bool inhibitBuying = 14;
    // If this is true, you're not allowed to sell whatever the vendor is buying.
    bool inhibitSelling = 15;
    // In addition to selling items, vendors can have "interactions": UI where you "talk" with the vendor and they offer you a reward, some item, or merely acknowledge via dialog that you did something cool.
    repeated Destiny.Definitions.DestinyVendorInteractionDefinition interactions = 16;
    // If the vendor shows you items from your own inventory - such as the Vault vendor does - this data describes the UI around showing those inventory buckets and which ones get shown.
    repeated Destiny.Definitions.DestinyVendorInventoryFlyoutDefinition inventoryFlyouts = 17;
    // If the vendor sells items (or merely has a list of items to show like the "Sack" vendors do), this is the list of those items that the vendor can sell. From this list, only a subset will be available from the vendor at any given time, selected randomly and reset on the vendor's refresh interval.
    // Note that a vendor can sell the same item multiple ways: for instance, nothing stops a vendor from selling you some specific weapon but using two different currencies, or the same weapon at multiple "item levels".
    repeated Destiny.Definitions.DestinyVendorItemDefinition itemList = 18;
    // See the categories property for a description of categories and why originalCategories exists.
    repeated Destiny.Definitions.DestinyVendorCategoryEntryDefinition originalCategories = 19;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 20;
    // A number used for calculating the frequency of a vendor's inventory resetting/refreshing.
    // Don't worry about calculating this - we do it on the server side and send you the next refresh date with the live data.
    int32 resetIntervalMinutes = 21;
    // Again, used for reset/refreshing of inventory. Don't worry too much about it. Unless you want to.
    int32 resetOffsetMinutes = 22;
    // Ditto for selling. Not that you can sell items to a vendor anymore. Will it come back? Who knows. The string's still there.
    string sellString = 23;
    // BNet doesn't use this data yet, but it appears to be an optional list of flavor text about services that the Vendor can provide.
    repeated Destiny.Definitions.DestinyVendorServiceDefinition services = 24;
    // If we were able to predict the dates when this Vendor will be visible/available, this will be the list of those date ranges. Sadly, we're not able to predict this very frequently, so this will often be useless data.
    repeated Dates.DateRange unlockRanges = 25;
    // If the vendor has a custom banner image, that can be found here.
    string vendorBanner = 26;
    // The identifier of the VendorCategoryDefinition for this vendor.
    string vendorCategoryIdentifier = 27;
    // The internal identifier for the Vendor. A holdover from the old days of Vendors, but we don't have time to refactor it away.
    string vendorIdentifier = 28;
    // A portrait of the Vendor's smiling mug. Or frothing tentacles.
    string vendorPortrait = 29;
    // The identifier of the VendorCategoryDefinition for this vendor's subcategory.
    string vendorSubcategoryIdentifier = 30;
    // If a vendor is not visible, we still have and will give vendor definition info, but we won't use them for things like Advisors or UI.
    bool visible = 31;
}

message Destiny.Definitions.DestinyVendorDisplayPropertiesDefinition {
    string description = 1;
    bool hasIcon = 2;
    // Note that "icon" is sometimes misleading, and should be interpreted in the context of the entity. For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.
    // But usually, it will be a small square image that you can use as... well, an icon.
    string icon = 3;
    string largeIcon = 4;
    string name = 5;
    // Vendors, in addition to expected display property data, may also show some "common requirements" as statically defined definition data. This might be when a vendor accepts a single type of currency, or when the currency is unique to the vendor and the designers wanted to show that currency when you interact with the vendor.
    repeated Destiny.Definitions.DestinyVendorRequirementDisplayEntryDefinition requirementsDisplay = 6;
    string subtitle = 7;
}

message Destiny.Definitions.DestinyVendorInteractionDefinition {
    // If the vendor interaction has flavor text, this is some of it.
    string flavorLineOne = 1;
    // If the vendor interaction has flavor text, this is the rest of it.
    string flavorLineTwo = 2;
    // The header for the interaction dialog.
    message HeaderDisplayProperties {
    }
    HeaderDisplayProperties headerDisplayProperties = 3;
    // The localized text telling the player what to do when they see this dialog.
    string instructions = 4;
    // If this interaction dialog is about a quest, this is the questline related to the interaction. You can use this to show the quest overview, or even the character's status with the quest if you use it to find the character's current Quest Step by checking their inventory against this questlineItemHash's DestinyInventoryItemDefinition.setData.
    uint32 questlineItemHash = 5;
    // The potential replies that the user can make to the interaction.
    repeated Destiny.Definitions.DestinyVendorInteractionReplyDefinition replies = 6;
    // If this interaction is displaying rewards, this is the text to use for the header of the reward-displaying section of the interaction.
    string rewardBlockLabel = 7;
    // If the vendor's reward list is sourced from one of his categories, this is the index into the category array of items to show.
    int32 rewardVendorCategoryIndex = 8;
    // If this interaction is meant to show you sacks, this is the list of types of sacks to be shown. If empty, the interaction is not meant to show sacks.
    repeated Destiny.Definitions.DestinyVendorInteractionSackEntryDefinition sackInteractionList = 9;
    // A UI hint for the behavior of the interaction screen. BNet doesn't use this, but you can choose to.
    uint32 uiInteractionType = 10;
    // If >= 0, this is the category of sale items to show along with this interaction dialog.
    int32 vendorCategoryIndex = 11;
}

message Destiny.Definitions.DestinyVendorInteractionReplyDefinition {
    // The rewards granted upon responding to the vendor.
    message ItemRewardsSelection {
    }
    ItemRewardsSelection itemRewardsSelection = 1;
    // The localized text for the reply.
    string reply = 2;
    // An enum indicating the type of reply being made.
    message ReplyType {
    }
    ReplyType replyType = 3;
}

message Destiny.Definitions.DestinyVendorInteractionSackEntryDefinition {
    uint32 sackType = 1;
}

message Destiny.Definitions.DestinyVendorInventoryFlyoutBucketDefinition {
    // If true, the inventory bucket should be able to be collapsed visually.
    bool collapsible = 1;
    // The inventory bucket whose contents should be shown.
    uint32 inventoryBucketHash = 2;
    // The methodology to use for sorting items from the flyout.
    message SortItemsBy {
    }
    SortItemsBy sortItemsBy = 3;
}

message Destiny.Definitions.DestinyVendorInventoryFlyoutDefinition {
    // A list of inventory buckets and other metadata to show on the screen.
    repeated Destiny.Definitions.DestinyVendorInventoryFlyoutBucketDefinition buckets = 1;
    // The title and other common properties of the flyout.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 2;
    // An identifier for the flyout, in case anything else needs to refer to them.
    uint32 flyoutId = 3;
    // If the flyout is locked, this is the reason why.
    string lockedDescription = 4;
    // If this is true, don't show any of the glistening "this is a new item" UI elements, like we show on the inventory items themselves in in-game UI.
    bool suppressNewness = 5;
}

message Destiny.Definitions.DestinyVendorItemDefinition {
    // The action to be performed when purchasing the item, if it's not just "buy".
    message Action {
    }
    Action action = 1;
    // The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item.
    int32 categoryIndex = 2;
    // The Default level at which the item will spawn. Almost always driven by an adjusto these days. Ideally should be singular. It's a long story how this ended up as a list, but there is always either going to be 0:1 of these entities.
    repeated Destiny.Definitions.DestinyItemCreationEntryLevelDefinition creationLevels = 3;
    // This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to check for what the purchaser must pay for the item. Use this instead of trying to piece together the price separately.
    repeated Destiny.DestinyItemQuantity currencies = 4;
    // The string identifier for the category selling this item.
    string displayCategory = 5;
    // This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually)
    int32 displayCategoryIndex = 6;
    // An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item.
    repeated int32 failureIndexes = 7;
    // The inventory bucket into which this item will be placed upon purchase.
    uint32 inventoryBucketHash = 8;
    // The hash identifier of the item being sold (DestinyInventoryItemDefinition).
    // Note that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a unique identifier for this entity.
    uint32 itemHash = 9;
    // The maximum character level at which this item is available for sale.
    int32 maximumLevel = 10;
    // The minimum character level at which this item is available for sale.
    int32 minimumLevel = 11;
    // Same as above, but for the original category indexes.
    int32 originalCategoryIndex = 12;
    // Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.
    // See DestinyGatingScope's documentation for more information.
    message PurchasableScope {
    }
    PurchasableScope purchasableScope = 13;
    // The amount you will recieve of the item described in itemHash if you make the purchase.
    int32 quantity = 14;
    // If this item can be refunded, this is the policy for what will be refundd, how, and in what time period.
    message RefundPolicy {
    }
    RefundPolicy refundPolicy = 15;
    // The amount of time before refundability of the newly purchased item will expire.
    int32 refundTimeLimit = 16;
    // The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data.
    int32 vendorItemIndex = 17;
    // The most restrictive scope that determines whether the item is available in the Vendor's inventory. See DestinyGatingScope's documentation for more information.
    // This can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties).
    message VisibilityScope {
    }
    VisibilityScope visibilityScope = 18;
}

message Destiny.Definitions.DestinyVendorRequirementDisplayEntryDefinition {
    string icon = 1;
    string name = 2;
    string source = 3;
    string type = 4;
}

message Destiny.Definitions.DestinyVendorSaleItemActionBlockDefinition {
    float executeSeconds = 1;
    bool isPositive = 2;
}

message Destiny.Definitions.DestinyVendorServiceDefinition {
    // The localized name of a service provided.
    string name = 1;
}

message Destiny.Definitions.Director.DestinyActivityGraphArtElementDefinition {
    // The position on the map of the art element.
    message Position {
    }
    Position position = 1;
}

message Destiny.Definitions.Director.DestinyActivityGraphConnectionDefinition {
    uint32 destNodeHash = 1;
    uint32 sourceNodeHash = 2;
}

message Destiny.Definitions.Director.DestinyActivityGraphDefinition {
    // Represents one-off/special UI elements that appear on the map.
    repeated Destiny.Definitions.Director.DestinyActivityGraphArtElementDefinition artElements = 1;
    // Represents connections between graph nodes. However, it lacks context that we'd need to make good use of it.
    repeated Destiny.Definitions.Director.DestinyActivityGraphConnectionDefinition connections = 2;
    // Objectives can display on maps, and this is supposedly metadata for that. I have not had the time to analyze the details of what is useful within however: we could be missing important data to make this work. Expect this property to be expanded on later if possible.
    repeated Destiny.Definitions.Director.DestinyActivityGraphDisplayObjectiveDefinition displayObjectives = 3;
    // Progressions can also display on maps, but similarly to displayObjectives we appear to lack some required information and context right now. We will have to look into it later and add more data if possible.
    repeated Destiny.Definitions.Director.DestinyActivityGraphDisplayProgressionDefinition displayProgressions = 4;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 5;
    // The index of the entity as it was found in the investment tables.
    int32 index = 6;
    // Represents links between this Activity Graph and other ones.
    repeated Destiny.Definitions.Director.DestinyLinkedGraphDefinition linkedGraphs = 7;
    // These represent the visual "nodes" on the map's view. These are the activities you can click on in the map.
    repeated Destiny.Definitions.Director.DestinyActivityGraphNodeDefinition nodes = 8;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 9;
}

message Destiny.Definitions.Director.DestinyActivityGraphDisplayObjectiveDefinition {
    // $NOTE $amola 2017-01-19 This field is apparently something that CUI uses to manually wire up objectives to display info. I am unsure how it works.
    uint32 id = 1;
    // The objective being shown on the map.
    uint32 objectiveHash = 2;
}

message Destiny.Definitions.Director.DestinyActivityGraphDisplayProgressionDefinition {
    uint32 id = 1;
    uint32 progressionHash = 2;
}

message Destiny.Definitions.Director.DestinyActivityGraphNodeActivityDefinition {
    // The activity that will be activated if the user clicks on this node. Controls all activity-related information displayed on the node if it is active (the text shown in the tooltip etc)
    uint32 activityHash = 1;
    // An identifier for this node activity. It is only guaranteed to be unique within the Activity Graph.
    uint32 nodeActivityId = 2;
}

message Destiny.Definitions.Director.DestinyActivityGraphNodeDefinition {
    // The node may have various possible activities that could be active for it, however only one may be active at a time. See the DestinyActivityGraphNodeActivityDefinition for details.
    repeated Destiny.Definitions.Director.DestinyActivityGraphNodeActivityDefinition activities = 1;
    // The node may have various visual accents placed on it, or styles applied. These are the list of possible styles that the Node can have. The game iterates through each, looking for the first one that passes a check of the required game/character/account state in order to show that style, and then renders the node in that style.
    repeated Destiny.Definitions.Director.DestinyActivityGraphNodeFeaturingStateDefinition featuringStates = 2;
    // An identifier for the Activity Graph Node, only guaranteed to be unique within its parent Activity Graph.
    uint32 nodeId = 3;
    // The node *may* have display properties that override the active Activity's display properties.
    message OverrideDisplay {
    }
    OverrideDisplay overrideDisplay = 4;
    // The position on the map for this node.
    message Position {
    }
    Position position = 5;
}

message Destiny.Definitions.Director.DestinyActivityGraphNodeFeaturingStateDefinition {
    // The node can be highlighted in a variety of ways - the game iterates through these and finds the first FeaturingState that is valid at the present moment given the Game, Account, and Character state, and renders the node in that state. See the ActivityGraphNodeHighlightType enum for possible values.
    message HighlightType {
    }
    HighlightType highlightType = 1;
}

message Destiny.Definitions.Director.DestinyLinkedGraphDefinition {
    string description = 1;
    uint32 linkedGraphId = 2;
    repeated Destiny.Definitions.Director.DestinyLinkedGraphEntryDefinition linkedGraphs = 3;
    string name = 4;
    string overview = 5;
    Destiny.Definitions.DestinyUnlockExpressionDefinition unlockExpression = 6;
}

message Destiny.Definitions.Director.DestinyLinkedGraphEntryDefinition {
    uint32 activityGraphHash = 1;
}

message Destiny.Definitions.Items.DestinyDerivedItemCategoryDefinition {
    // The localized string for the category title. This will be something describing the items you can get as a group, or your likelihood/the quantity you'll get.
    string categoryDescription = 1;
    // This is the list of all of the items for this category and the basic properties we'll know about them.
    repeated Destiny.Definitions.Items.DestinyDerivedItemDefinition items = 2;
}

message Destiny.Definitions.Items.DestinyDerivedItemDefinition {
    // An icon for the item.
    string iconPath = 1;
    // A brief description of the item.
    string itemDescription = 2;
    // Additional details about the derived item, in addition to the description.
    string itemDetail = 3;
    // The hash for the DestinyInventoryItemDefinition of this derived item, if there is one. Sometimes we are given this information as a manual override, in which case there won't be an actual DestinyInventoryItemDefinition for what we display, but you can still show the strings from this object itself.
    uint32 itemHash = 4;
    // The name of the derived item.
    string itemName = 5;
    // If the item was derived from a "Preview Vendor", this will be an index into the DestinyVendorDefinition's itemList property. Otherwise, -1.
    int32 vendorItemIndex = 6;
}

message Destiny.Definitions.Items.DestinyItemPlugDefinition {
    // It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
    uint32 enabledMaterialRequirementHash = 1;
    // The rules around whether the plug, once inserted, is enabled and providing its benefits.
    // The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
    repeated Destiny.Definitions.Items.DestinyPlugRuleDefinition enabledRules = 2;
    // If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
    uint32 insertionMaterialRequirementHash = 3;
    // The rules around when this plug can be inserted into a socket, aside from the socket's individual restrictions.
    // The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
    repeated Destiny.Definitions.Items.DestinyPlugRuleDefinition insertionRules = 4;
    // If you successfully socket the item, this will determine whether or not you get "refunded" on the plug.
    bool onActionRecreateSelf = 5;
    // The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
    uint32 plugCategoryHash = 6;
    // The string identifier for the plug's category. Use the socket's DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
    string plugCategoryIdentifier = 7;
    // In the game, if you're inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
    uint32 previewItemOverrideHash = 8;
}

message Destiny.Definitions.Items.DestinyItemTierTypeDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this tier defines infusion properties, they will be contained here.
    message InfusionProcess {
    }
    InfusionProcess infusionProcess = 4;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 5;
}

message Destiny.Definitions.Items.DestinyItemTierTypeInfusionBlock {
    // The default portion of quality that will transfer from the infuser to the infusee item. (InfuserQuality - InfuseeQuality) * baseQualityTransferRatio = base quality transferred.
    float baseQualityTransferRatio = 1;
    // As long as InfuserQuality > InfuseeQuality, the amount of quality bestowed is guaranteed to be at least this value, even if the transferRatio would dictate that it should be less. The total amount of quality that ends up in the Infusee cannot exceed the Infuser's quality however (for instance, if you infuse a 300 item with a 301 item and the minimum quality increment is 10, the infused item will not end up with 310 quality)
    int32 minimumQualityIncrement = 2;
}

message Destiny.Definitions.Items.DestinyPlugRuleDefinition {
    // The localized string to show if this rule fails.
    string failureMessage = 1;
}

message Destiny.Definitions.Lore.DestinyLoreDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
    string subtitle = 5;
}

message Destiny.Definitions.Milestones.DestinyMilestoneActivityDefinition {
    // The "Conceptual" activity hash. Basically, we picked the lowest level activity and are treating it as the canonical definition of the activity for rendering purposes.
    // If you care about the specific difficulty modes and variations, use the activities under "Variants".
    uint32 conceptualActivityHash = 1;
    // A milestone-referenced activity can have many variants, such as Tiers or alternative modes of play.
    // Even if there is only a single variant, the details for these are represented within as a variant definition.
    // It is assumed that, if this DestinyMilestoneActivityDefinition is active, then all variants should be active.
    // If a Milestone could ever split the variants' active status conditionally, they should all have their own DestinyMilestoneActivityDefinition instead! The potential duplication will be worth it for the obviousness of processing and use.
    map<string, Destiny.Definitions.Milestones.DestinyMilestoneActivityVariantDefinition> variants = 2;
}

message Destiny.Definitions.Milestones.DestinyMilestoneActivityVariantDefinition {
    // The hash to use for looking up the variant Activity's definition (DestinyActivityDefinition), where you can find its distinguishing characteristics such as difficulty level and recommended light level. 
    // Frequently, that will be the only distinguishing characteristics in practice, which is somewhat of a bummer.
    uint32 activityHash = 1;
    // If you care to do so, render the variants in the order prescribed by this value.
    // When you combine live Milestone data with the definition, the order becomes more useful because you'll be cross-referencing between the definition and live data.
    int32 order = 2;
}

message Destiny.Definitions.Milestones.DestinyMilestoneDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // If the milestone has a friendly identifier for association with other features - such as Recruiting - that identifier can be found here. This is "friendly" in that it looks better in a URL than whatever the identifier for the Milestone actually is.
    string friendlyName = 2;
    // A shortcut for clients - and the server - to understand whether we can predict the start and end dates for this event. In practice, there are multiple ways that an event could have predictable date ranges, but not all events will be able to be predicted via any mechanism (for instance, events that are manually triggered on and off)
    bool hasPredictableDates = 3;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 4;
    // A custom image someone made just for the milestone. Isn't that special?
    string image = 5;
    // The index of the entity as it was found in the investment tables.
    int32 index = 6;
    // Some milestones are explicit objectives that you can see and interact with in the game. Some milestones are more conceptual, built by BNet to help advise you on activities and events that happen in-game but that aren't explicitly shown in game as Milestones. If this is TRUE, you can see this as a milestone in the game. If this is FALSE, it's an event or activity you can participate in, but you won't see it as a Milestone in the game's UI.
    bool isInGameMilestone = 7;
    // An enumeration listing one of the possible types of milestones. Check out the DestinyMilestoneType enum for more info!
    message MilestoneType {
    }
    MilestoneType milestoneType = 8;
    // The full set of possible Quests that give the overview of the Milestone event/activity in question. Only one of these can be active at a time for a given Conceptual Milestone, but many of them may be "available" for the user to choose from. (for instance, with Milestones you can choose from the three available Quests, but only one can be active at a time) Keyed by the quest item.
    map<string, Destiny.Definitions.Milestones.DestinyMilestoneQuestDefinition> quests = 9;
    // If True, then the Milestone has been integrated with BNet's recruiting feature.
    bool recruitable = 10;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 11;
    // If this milestone can provide rewards, this will define the categories into which the individual reward entries are placed.
    map<string, Destiny.Definitions.Milestones.DestinyMilestoneRewardCategoryDefinition> rewards = 12;
    // If TRUE, this entry should be returned in the list of milestones for the "Explore Destiny" (i.e. new BNet homepage) features of Bungie.net (as long as the underlying event is active)
    bool showInExplorer = 13;
    // Sometimes, milestones will have arbitrary values associated with them that are of interest to us or to third party developers. This is the collection of those values' definitions, keyed by the identifier of the value and providing useful definition information such as localizable names and descriptions for the value.
    map<string, Destiny.Definitions.Milestones.DestinyMilestoneValueDefinition> values = 14;
    // Sometimes, milestones will have rewards provided by Vendors. This definition gives the information needed to understand which vendors are relevant, the order in which they should be returned if order matters, and the conditions under which the Vendor is relevant to the user.
    repeated Destiny.Definitions.Milestones.DestinyMilestoneVendorDefinition vendors = 15;
}

message Destiny.Definitions.Milestones.DestinyMilestoneQuestDefinition {
    // The full set of all possible "conceptual activities" that are related to this Milestone. Tiers or alternative modes of play within these conceptual activities will be defined as sub-entities. Keyed by the Conceptual Activity Hash. Use the key to look up DestinyActivityDefinition.
    map<string, Destiny.Definitions.Milestones.DestinyMilestoneActivityDefinition> activities = 1;
    // The individual quests may have different definitions from the overall milestone: if there's a specific active quest, use these displayProperties instead of that of the overall DestinyMilestoneDefinition.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 2;
    // If populated, this image can be shown instead of the generic milestone's image when this quest is live, or it can be used to show a background image for the quest itself that differs from that of the Activity or the Milestone.
    string overrideImage = 3;
    // The item representing this Milestone quest. Use this hash to look up the DestinyInventoryItemDefinition for the quest to find its steps and human readable data.
    uint32 questItemHash = 4;
    // The rewards you will get for completing this quest, as best as we could extract them from our data. Sometimes, it'll be a decent amount of data. Sometimes, it's going to be sucky. Sorry.
    message QuestRewards {
    }
    QuestRewards questRewards = 5;
}

message Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardItem {
    // The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.
    uint32 itemHash = 1;
    // If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.
    int64 itemInstanceId = 2;
    // The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.
    int32 quantity = 3;
    // The quest reward item *may* be associated with a vendor. If so, this is that vendor. Use this hash to look up the DestinyVendorDefinition.
    uint32 vendorHash = 4;
    // The quest reward item *may* be associated with a vendor. If so, this is the index of the item being sold, which we can use at runtime to find instanced item information for the reward item.
    int32 vendorItemIndex = 5;
}

message Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardsDefinition {
    // The items that represent your reward for completing the quest.
    // Be warned, these could be "dummy" items: items that are only used to render a good-looking in-game tooltip, but aren't the actual items themselves.
    // For instance, when experience is given there's often a dummy item representing "experience", with quantity being the amount of experience you got. We don't have a programmatic association between those and whatever Progression is actually getting that experience... yet.
    repeated Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardItem items = 1;
}

message Destiny.Definitions.Milestones.DestinyMilestoneRewardCategoryDefinition {
    // Identifies the reward category. Only guaranteed unique within this specific component!
    uint32 categoryHash = 1;
    // The string identifier for the category, if you want to use it for some end. Guaranteed unique within the specific component.
    string categoryIdentifier = 2;
    // Hopefully this is obvious by now.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 3;
    // If you want to use BNet's recommended order for rendering categories programmatically, use this value and compare it to other categories to determine the order in which they should be rendered. I don't feel great about putting this here, I won't lie.
    int32 order = 4;
    // If this milestone can provide rewards, this will define the sets of rewards that can be earned, the conditions under which they can be acquired, internal data that we'll use at runtime to determine whether you've already earned or redeemed this set of rewards, and the category that this reward should be placed under.
    map<string, Destiny.Definitions.Milestones.DestinyMilestoneRewardEntryDefinition> rewardEntries = 5;
}

message Destiny.Definitions.Milestones.DestinyMilestoneRewardEntryDefinition {
    // For us to bother returning this info, we should be able to return some kind of information about why these rewards are grouped together. This is ideally that information. Look at how confident I am that this will always remain true.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // The items you will get as rewards, and how much of it you'll get.
    repeated Destiny.DestinyItemQuantity items = 2;
    // If you want to follow BNet's ordering of these rewards, use this number within a given category to order the rewards. Yeah, I know. I feel dirty too.
    int32 order = 3;
    // The identifier for this reward entry. Runtime data will refer to reward entries by this hash. Only guaranteed unique within the specific Milestone.
    uint32 rewardEntryHash = 4;
    // The string identifier, if you care about it. Only guaranteed unique within the specific Milestone.
    string rewardEntryIdentifier = 5;
    // If this reward is redeemed at a Vendor, this is the hash of the Vendor to go to in order to redeem the reward. Use this hash to look up the DestinyVendorDefinition.
    uint32 vendorHash = 6;
}

message Destiny.Definitions.Milestones.DestinyMilestoneValueDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    string key = 2;
}

message Destiny.Definitions.Milestones.DestinyMilestoneVendorDefinition {
    // The hash of the vendor whose wares should be shown as associated with the Milestone.
    uint32 vendorHash = 1;
}

message Destiny.Definitions.Progression.DestinyProgressionLevelRequirementDefinition {
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 1;
    // The index of the entity as it was found in the investment tables.
    int32 index = 2;
    // The progression whose level should be used to determine the level requirement.
    // Look up the DestinyProgressionDefinition with this hash for more information about the progression in question.
    uint32 progressionHash = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
    // A curve of level requirements, weighted by the related progressions' level.
    // Interpolate against this curve with the character's progression level to determine what the level requirement of the generated item that is using this data will be.
    repeated Interpolation.InterpolationPointFloat requirementCurve = 5;
}

message Destiny.Definitions.Sockets.DestinyInsertPlugActionDefinition {
    // How long it takes for the Plugging of the item to be completed once it is initiated, if you care.
    int32 actionExecuteSeconds = 1;
}

message Destiny.Definitions.Sockets.DestinyPlugWhitelistEntryDefinition {
    // The hash identifier of the Plug Category to compare against the plug item's plug.plugCategoryHash.
    // Note that this does NOT relate to any Definition in itself, it is only used for comparison purposes.
    uint32 categoryHash = 1;
    // The string identifier for the category, which is here mostly for debug purposes.
    string categoryIdentifier = 2;
}

message Destiny.Definitions.Sockets.DestinySocketCategoryDefinition {
    Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 4;
    // A string hinting to the game's UI system about how the sockets in this category should be displayed.
    // BNet doesn't use it: it's up to you to find valid values and make your own special UI if you want to honor this category style.
    uint32 uiCategoryStyle = 5;
}

message Destiny.Definitions.Sockets.DestinySocketTypeDefinition {
    // There are fields for this display data, but they appear to be unpopulated as of now. I am not sure where in the UI these would show if they even were populated, but I will continue to return this data in case it becomes useful.
    message DisplayProperties {
    }
    DisplayProperties displayProperties = 1;
    // The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
    // When entities refer to each other in Destiny content, it is this hash that they are referring to.
    uint32 hash = 2;
    // The index of the entity as it was found in the investment tables.
    int32 index = 3;
    // Defines what happens when a plug is inserted into sockets of this type.
    message InsertAction {
    }
    InsertAction insertAction = 4;
    // A list of Plug "Categories" that are allowed to be plugged into sockets of this type.
    // These should be compared against a given plug item's DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug item's category.
    // If the plug's category matches any whitelisted plug, or if the whitelist is empty, it is allowed to be inserted.
    repeated Destiny.Definitions.Sockets.DestinyPlugWhitelistEntryDefinition plugWhitelist = 5;
    // If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
    bool redacted = 6;
    uint32 socketCategoryHash = 7;
    integer visibility = 8;
}

message Destiny.Definitions.Sources.DestinyItemSourceDefinition {
    // The stats computed for this level/quality range.
    map<string, Destiny.Definitions.DestinyInventoryItemStatDefinition> computedStats = 1;
    // The level at which the item spawns. Essentially the Primary Key for this source data: there will be multiple of these source entries per item that has source data, grouped by the level at which the item spawns.
    int32 level = 2;
    // The maximum Character Level required for equipping the item when the item spawns at the item level defined on this DestinyItemSourceDefinition, as far as we saw in our processing.
    int32 maxLevelRequired = 3;
    // The maximum quality at which the item spawns for this level.
    int32 maxQuality = 4;
    // The minimum Character Level required for equipping the item when the item spawns at the item level defined on this DestinyItemSourceDefinition, as far as we saw in our processing.
    int32 minLevelRequired = 5;
    // The minimum Quality at which the item spawns for this level. Examine DestinyInventoryItemDefinition for more information about what Quality means. Just don't ask Phaedrus about it, he'll never stop talking and you'll have to write a book about it.
    int32 minQuality = 6;
    // The DestinyRewardSourceDefinitions found that can spawn the item at this level.
    repeated uint32 sourceHashes = 7;
}

message Destiny.DestinyActivity {
    // The hash identifier of the Activity. Use this to look up the DestinyActivityDefinition of the activity.
    uint32 activityHash = 1;
    // If true, the user is allowed to join with another Fireteam in this activity.
    bool canJoin = 2;
    // If true, the user is allowed to lead a Fireteam into this activity.
    bool canLead = 3;
    // A DestinyActivityDifficultyTier enum value indicating the difficulty of the activity.
    message DifficultyTier {
    }
    DifficultyTier difficultyTier = 4;
    // The difficulty level of the activity, if applicable.
    int32 displayLevel = 5;
    // If true, we both have the ability to know that the user has completed this activity and they have completed it. Unfortunately, we can't necessarily know this for all activities. As such, this should probably only be used if you already know in advance which specific activities you wish to check.
    bool isCompleted = 6;
    // If true, then the activity should have a "new" indicator in the Director UI.
    bool isNew = 7;
    // If true, the user should be able to see this activity.
    bool isVisible = 8;
    // The recommended light level for the activity, if applicable.
    int32 recommendedLight = 9;
}

message Destiny.DestinyEquipItemResult {
    // A PlatformErrorCodes enum indicating whether it succeeded, and if it failed why.
    message EquipStatus {
    }
    EquipStatus equipStatus = 1;
    // The instance ID of the item in question (all items that can be equipped must, but definition, be Instanced and thus have an Instance ID that you can use to refer to them)
    int64 itemInstanceId = 2;
}

message Destiny.DestinyEquipItemResults {
    repeated Destiny.DestinyEquipItemResult equipResults = 1;
}

message Destiny.DestinyItemQuantity {
    // The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.
    uint32 itemHash = 1;
    // If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.
    int64 itemInstanceId = 2;
    // The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.
    int32 quantity = 3;
}

message Destiny.DestinyProgression {
    // This is the total amount of progress obtained overall for this progression (for instance, the total amount of Character Level experience earned)
    int32 currentProgress = 1;
    // If this progression has a daily limit, this is that limit.
    int32 dailyLimit = 2;
    // The amount of progress earned today for this progression.
    int32 dailyProgress = 3;
    // This is the level of the progression (for instance, the Character Level).
    int32 level = 4;
    // This is the maximum possible level you can achieve for this progression (for example, the maximum character level obtainable)
    int32 levelCap = 5;
    // The total amount of progression (i.e. "Experience") needed in order to reach the next level.
    int32 nextLevelAt = 6;
    // The amount of progression (i.e. "Experience") needed to reach the next level of this Progression. Jeez, progression is such an overloaded word.
    int32 progressToNextLevel = 7;
    // The hash identifier of the Progression in question. Use it to look up the DestinyProgressionDefinition in static data.
    uint32 progressionHash = 8;
    // Progressions define their levels in "steps". Since the last step may be repeatable, the user may be at a higher level than the actual Step achieved in the progression. Not necessarily useful, but potentially interesting for those cruising the API. Relate this to the "steps" property of the DestinyProgression to see which step the user is on, if you care about that. (Note that this is Content Version dependent since it refers to indexes.)
    int32 stepIndex = 9;
    // If this progression has a weekly limit, this is that limit.
    int32 weeklyLimit = 10;
    // The amount of progress earned toward this progression in the current week.
    int32 weeklyProgress = 11;
}

message Destiny.DestinyStat {
    // The highest possible value for the stat, if we were able to compute it. (I wouldn't necessarily trust this value right now. I would like to improve its calculation in later iterations of the API. Consider this a placeholder for desired future functionality)
    int32 maximumValue = 1;
    // The hash identifier for the Stat. Use it to look up the DestinyStatDefinition for static data about the stat.
    uint32 statHash = 2;
    // The current value of the Stat.
    int32 value = 3;
}

message Destiny.DestinyTalentNode {
    // The progression level required on the Talent Grid in order to be able to activate this talent node. Talent Grids have their own Progression - similar to Character Level, but in this case it is experience related to the item itself.
    int32 activationGridLevel = 1;
    // Whether or not the talent node is actually visible in the game's UI. Whether you want to show it in your own UI is up to you! I'm not gonna tell you who to sock it to.
    bool hidden = 2;
    // If true, the node is activated: it's current step then provides its benefits.
    bool isActivated = 3;
    // If the node has material requirements to be activated, this is the list of those requirements.
    repeated Destiny.Definitions.DestinyMaterialRequirement materialsToUpgrade = 4;
    // The hash of the Talent Node being referred to (in DestinyTalentGridDefinition.nodes). Deceptively CONTENT VERSION DEPENDENT. We have no guarantee of the hash's immutability between content versions.
    uint32 nodeHash = 5;
    // The index of the Talent Node being referred to (an index into DestinyTalentGridDefinition.nodes[]). CONTENT VERSION DEPENDENT.
    int32 nodeIndex = 6;
    // This property has some history. A talent grid can provide stats on both the item it's related to and the character equipping the item. This returns data about those stat bonuses.
    message NodeStatsBlock {
    }
    NodeStatsBlock nodeStatsBlock = 7;
    // If you want to show a progress bar or circle for how close this talent node is to being activate-able, this is the percentage to show. It follows the node's underlying rules about when the progress bar should first show up, and when it should be filled.
    float progressPercent = 8;
    // An DestinyTalentNodeState enum value indicating the node's state: whether it can be activated or swapped, and why not if neither can be performed.
    message State {
    }
    State state = 9;
    // The currently relevant Step for the node. It is this step that has rendering data for the node and the benefits that are provided if the node is activated. (the actual rules for benefits provided are extremely complicated in theory, but with how Talent Grids are being used in Destiny 2 you don't have to worry about a lot of those old Destiny 1 rules.) This is an index into: DestinyTalentGridDefinition.nodes[nodeIndex].steps[stepIndex]
    int32 stepIndex = 10;
}

message Destiny.DestinyTalentNodeStatBlock {
    // The stat benefits conferred when this talent node is activated for the current Step that is active on the node.
    repeated Destiny.DestinyStat currentStepStats = 1;
    // This is a holdover from the old days of Destiny 1, when a node could be activated multiple times, conferring multiple steps worth of benefits: you would use this property to show what activating the "next" step on the node would provide vs. what the current step is providing. While Nodes are currently not being used this way, the underlying system for this functionality still exists. I hesitate to remove this property while the ability for designers to make such a talent grid still exists. Whether you want to show it is up to you.
    repeated Destiny.DestinyStat nextStepStats = 2;
}

message Destiny.DestinyUnlockStatus {
    // Whether the unlock flag is set.
    bool isSet = 1;
    // The hash identifier for the Unlock Flag. Use to lookup DestinyUnlockDefinition for static data. Not all unlocks have human readable data - in fact, most don't. But when they do, it can be very useful to show. Even if they don't have human readable data, you might be able to infer the meaning of an unlock flag with a bit of experimentation...
    uint32 unlockHash = 2;
}

message Destiny.DyeReference {
    uint32 channelHash = 1;
    uint32 dyeHash = 2;
}

message Destiny.Entities.Characters.DestinyCharacterActivitiesComponent {
    // The list of activities that the user can play.
    repeated Destiny.DestinyActivity availableActivities = 1;
    // If the user is in an activity, this will be the hash of the Activity being played. Note that you must combine this info with currentActivityModeHash to get a real picture of what the user is doing right now. For instance, PVP "Activities" are just maps: it's the ActivityMode that determines what type of PVP game they're playing.
    uint32 currentActivityHash = 2;
    // If the user is in an activity, this will be the hash of the activity mode being played. Combine with currentActivityHash to give a person a full picture of what they're doing right now.
    uint32 currentActivityModeHash = 3;
    repeated uint32 currentActivityModeHashes = 4;
    int32 currentActivityModeType = 5;
    repeated integer currentActivityModeTypes = 6;
    uint32 currentPlaylistActivityHash = 7;
    // The last date that the user started playing an activity.
    string dateActivityStarted = 8;
    // This will have the activity hash of the last completed story/campaign mission, in case you care about that.
    uint32 lastCompletedStoryHash = 9;
}

message Destiny.Entities.Characters.DestinyCharacterComponent {
    // The "base" level of your character, not accounting for any light level.
    int32 baseCharacterLevel = 1;
    // The unique identifier for the character.
    int64 characterId = 2;
    // Use this hash to look up the character's DestinyClassDefinition.
    uint32 classHash = 3;
    // Mostly for historical purposes at this point, this is an enumeration for the character's class.
    // It'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove.
    message ClassType {
    }
    ClassType classType = 4;
    // The last date that the user played Destiny.
    string dateLastPlayed = 5;
    // A shortcut path to the user's currently equipped emblem background image. If you're just showing summary info for a user, this is more convenient than examining their equipped emblem and looking up the definition.
    string emblemBackgroundPath = 6;
    // The hash of the currently equipped emblem for the user. Can be used to look up the DestinyInventoryItemDefinition.
    uint32 emblemHash = 7;
    // A shortcut path to the user's currently equipped emblem image. If you're just showing summary info for a user, this is more convenient than examining their equipped emblem and looking up the definition.
    string emblemPath = 8;
    // Use this hash to look up the character's DestinyGenderDefinition.
    uint32 genderHash = 9;
    // Mostly for historical purposes at this point, this is an enumeration for the character's Gender.
    // It'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove. And yeah, it's an enumeration and not a boolean. Fight me.
    message GenderType {
    }
    GenderType genderType = 10;
    // The progression that indicates your character's level. Not their light level, but their character level: you know, the thing you max out a couple hours in and then ignore for the sake of light level.
    message LevelProgression {
    }
    LevelProgression levelProgression = 11;
    // The user's calculated "Light Level". Light level is an indicator of your power that mostly matters in the end game, once you've reached the maximum character level: it's a level that's dependent on the average Attack/Defense power of your items.
    int32 light = 12;
    // Every Destiny Profile has a membershipId. This is provided on the character as well for convenience.
    int64 membershipId = 13;
    // membershipType tells you the platform on which the character plays. Examine the BungieMembershipType enumeration for possible values.
    message MembershipType {
    }
    MembershipType membershipType = 14;
    // If the user is currently playing, this is how long they've been playing.
    int64 minutesPlayedThisSession = 15;
    // If this value is 525,600, then they played Destiny for a year. Or they're a very dedicated Rent fan. Note that this includes idle time, not just time spent actually in activities shooting things.
    int64 minutesPlayedTotal = 16;
    // A number between 0 and 100, indicating the whole and fractional % remaining to get to the next character level.
    float percentToNextLevel = 17;
    // Use this hash to look up the character's DestinyRaceDefinition.
    uint32 raceHash = 18;
    // Mostly for historical purposes at this point, this is an enumeration for the character's race.
    // It'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove.
    message RaceType {
    }
    RaceType raceType = 19;
    // Your character's stats, such as Agility, Resilience, etc... *not* historical stats.
    // You'll have to call a different endpoint for those.
    map<string, integer> stats = 20;
}

message Destiny.Entities.Characters.DestinyCharacterProgressionComponent {
    // A dictionary of all known Factions, keyed by the Faction's hash. It contains data about this character's status with the faction.
    map<string, Destiny.Progression.DestinyFactionProgression> factions = 1;
    // Milestones are related to the simple progressions shown in the game, but return additional and hopefully helpful information for users about the specifics of the Milestone's status.
    map<string, Destiny.Milestones.DestinyMilestone> milestones = 2;
    // A Dictionary of all known progressions for the Character, keyed by the Progression's hash.
    // Not all progressions have user-facing data, but those who do will have that data contained in the DestinyProgressionDefinition.
    map<string, Destiny.DestinyProgression> progressions = 3;
    // If the user has any active quests, the quests' statuses will be returned here.
    // Note that quests have been largely supplanted by Milestones, but that doesn't mean that they won't make a comeback independent of milestones at some point.
    repeated Destiny.Quests.DestinyQuestStatus quests = 4;
    // Sometimes, you have items in your inventory that don't have instances, but still have Objective information. This provides you that objective information for uninstanced items. 
    // This dictionary is keyed by the item's hash: which you can use to look up the name and description for the overall task(s) implied by the objective. The value is the list of objectives for this item, and their statuses.
    map<string, array> uninstancedItemObjectives = 5;
}

message Destiny.Entities.Characters.DestinyCharacterRenderComponent {
    // Custom dyes, calculated by iterating over the character's equipped items. Useful for pre-fetching all of the dye data needed from our server.
    repeated Destiny.DyeReference customDyes = 1;
    // This is actually something that Spasm.js *doesn't* do right now, and that we don't return assets for yet. This is the data about what character customization options you picked. You can combine this with DestinyCharacterCustomizationOptionDefinition to show some cool info, and hopefully someday to actually render a user's face in 3D. We'll see if we ever end up with time for that.
    message Customization {
    }
    Customization customization = 2;
    // A minimal view of:
    // - Equipped items
    // - The rendering-related custom options on those equipped items
    // Combined, that should be enough to render all of the items on the equipped character.
    message PeerView {
    }
    PeerView peerView = 3;
}

message Destiny.Entities.Inventory.DestinyInventoryComponent {
    // The items in this inventory. If you care to bucket them, use the item's bucketHash property to group them.
    repeated Destiny.Entities.Items.DestinyItemComponent items = 1;
}

message Destiny.Entities.Items.DestinyItemComponent {
    // If the item is bound to a location, it will be specified in this enum.
    message BindStatus {
    }
    BindStatus bindStatus = 1;
    // The hash identifier for the specific inventory bucket in which the item is located.
    uint32 bucketHash = 2;
    // The identifier for the item's definition, which is where most of the useful static information for the item can be found.
    uint32 itemHash = 3;
    // If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item has no distinct local qualities aside from stack size.
    int64 itemInstanceId = 4;
    // An easy reference for where the item is located. Redundant if you got the item from an Inventory, but useful when making detail calls on specific items.
    message Location {
    }
    Location location = 5;
    // If the item can be locked, this will indicate that state.
    bool lockable = 6;
    // The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced item, this value will always be 1 (as the stack has exactly one item in it)
    int32 quantity = 7;
    // A flags enumeration indicating the states of the item: whether it's tracked or locked for example.
    message State {
    }
    State state = 8;
    // If there is a known error state that would cause this item to not be transferable, this Flags enum will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).
    message TransferStatus {
    }
    TransferStatus transferStatus = 9;
}

message Destiny.Entities.Items.DestinyItemInstanceComponent {
    // If this is an equippable item, you can check it here. There are permanent as well as transitory reasons why an item might not be able to be equipped: check cannotEquipReason for details.
    bool canEquip = 1;
    // If you cannot equip the item, this is a flags enum that enumerates all of the reasons why you couldn't equip the item. You may need to refine your UI further by using unlockHashesRequiredToEquip and equipRequiredLevel.
    message CannotEquipReason {
    }
    CannotEquipReason cannotEquipReason = 2;
    // If the item has a damage type, this is the item's current damage type.
    message DamageType {
    }
    DamageType damageType = 3;
    // The current damage type's hash, so you can look up localized info and icons for it.
    uint32 damageTypeHash = 4;
    // If the item cannot be equipped until you reach a certain level, that level will be reflected here.
    int32 equipRequiredLevel = 5;
    // Is the item currently equipped on the given character?
    bool isEquipped = 6;
    // The Item's "Level" has the most significant bearing on its stats, such as Light and Power.
    int32 itemLevel = 7;
    // The item stat that we consider to be "primary" for the item. For instance, this would be "Attack" for Weapons or "Defense" for armor.
    message PrimaryStat {
    }
    PrimaryStat primaryStat = 8;
    // The "Quality" of the item has a lesser - but still impactful - bearing on stats like Light and Power.
    int32 quality = 9;
    // Sometimes, there are limitations to equipping that are represented by character-level flags called "unlocks".
    // This is a list of flags that they need in order to equip the item that the character has not met. Use these to look up the descriptions to show in your UI by looking up the relevant DestinyUnlockDefinitions for the hashes.
    repeated uint32 unlockHashesRequiredToEquip = 10;
}

message Destiny.Entities.Items.DestinyItemObjectivesComponent {
    // If the item has a hard association with objectives, your progress on them will be defined here. 
    // Objectives are our standard way to describe a series of tasks that have to be completed for a reward.
    repeated Destiny.Quests.DestinyObjectiveProgress objectives = 1;
}

message Destiny.Entities.Items.DestinyItemPerksComponent {
    // The list of perks to display in an item tooltip - and whether or not they have been activated.
    repeated Destiny.Perks.DestinyPerkReference perks = 1;
}

message Destiny.Entities.Items.DestinyItemRenderComponent {
    // A dictionary for rendering gear components, with:
    // key = Art Arrangement Region Index
    // value = The chosen Arrangement Index for the Region, based on the value of a stat on the item used for making the choice.
    map<string, integer> artRegions = 1;
    // If you should use custom dyes on this item, it will be indicated here.
    bool useCustomDyes = 2;
}

message Destiny.Entities.Items.DestinyItemSocketState {
    // If a plug is inserted but not enabled, this will be populated with indexes into the plug item definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.
    repeated int32 enableFailIndexes = 1;
    // Even if a plug is inserted, it doesn't mean it's enabled.
    // This flag indicates whether the plug is active and providing its benefits.
    bool isEnabled = 2;
    // The currently active plug, if any.
    // Note that, because all plugs are statically defined, its effect on stats and perks can be statically determined using the plug item's definition. The stats and perks can be taken at face value on the plug item as the stats and perks it will provide to the user/item.
    uint32 plugHash = 3;
    // If the item supports reusable plugs, this is the list of plug item hashes that are currently allowed to be used for this socket. (sometimes restrictions may cause reusable plugs defined on the item definition to not be valid, so you should trust the instanced reusablePlugHashes list rather than the definition's list)
    // A Reusable Plug is a plug that you can *always* insert into this socket, regardless of whether or not you have the plug in your inventory. In practice, a socket will *either* have reusable plugs *or* it will allow for plugs in your inventory to be inserted. See DestinyInventoryItemDefinition.socket for more info.
    repeated uint32 reusablePlugHashes = 4;
}

message Destiny.Entities.Items.DestinyItemSocketsComponent {
    // The list of all sockets on the item, and their status information.
    repeated Destiny.Entities.Items.DestinyItemSocketState sockets = 1;
}

message Destiny.Entities.Items.DestinyItemStatsComponent {
    // If the item has stats that it provides (damage, defense, etc...), it will be given here.
    map<string, Destiny.DestinyStat> stats = 1;
}

message Destiny.Entities.Items.DestinyItemTalentGridComponent {
    // If the item has a progression, it will be detailed here. A progression means that the item can gain experience. Thresholds of experience are what determines whether and when a talent node can be activated.
    message GridProgression {
    }
    GridProgression gridProgression = 1;
    // Indicates whether the talent grid on this item is completed, and thus whether it should have a gold border around it.
    // Only will be true if the item actually *has* a talent grid, and only then if it is completed (i.e. every exclusive set has an activated node, and every non-exclusive set node has been activated)
    bool isGridComplete = 2;
    // Detailed information about the individual nodes in the talent grid.
    // A node represents a single visual "pip" in the talent grid or Build detail view, though each node may have multiple "steps" which indicate the actual bonuses and visual representation of that node.
    repeated Destiny.DestinyTalentNode nodes = 3;
    // Most items don't have useful talent grids anymore, but Builds in particular still do.
    // You can use this hash to lookup the DestinyTalentGridDefinition attached to this item, which will be crucial for understanding the node values on the item.
    uint32 talentGridHash = 4;
}

message Destiny.Entities.Profiles.DestinyProfileComponent {
    // A list of the character IDs, for further querying on your part.
    repeated int64 characterIds = 1;
    // The last time the user played with any character on this Profile.
    string dateLastPlayed = 2;
    // If you need to render the Profile (their platform name, icon, etc...) somewhere, this property contains that information.
    message UserInfo {
    }
    UserInfo userInfo = 3;
    // If you want to know what expansions they own, this will contain that data.
    message VersionsOwned {
    }
    VersionsOwned versionsOwned = 4;
}

message Destiny.Entities.Profiles.DestinyVendorReceiptsComponent {
    // The receipts for refundable purchases made at a vendor.
    repeated Destiny.Vendors.DestinyVendorReceipt receipts = 1;
}

message Destiny.Entities.Vendors.DestinyVendorCategoriesComponent {
    // The list of categories for items that the vendor sells, in rendering order.
    repeated Destiny.Entities.Vendors.DestinyVendorCategory categories = 1;
}

message Destiny.Entities.Vendors.DestinyVendorCategory {
    // An index into the DestinyVendorDefinition.categories property, so you can grab the display data for this category.
    int32 categoryIndex = 1;
    // An ordered list of indexes into items being sold in this category (DestinyVendorDefinition.itemList) which will contain more information about the items being sold themselves. Can also be used to index into DestinyVendorSaleItemComponent data, if you asked for that data to be returned.
    repeated int32 itemIndexes = 2;
}

message Destiny.Entities.Vendors.DestinyVendorComponent {
    // Long ago, we thought it would be a good idea to have special UI that showed whether or not you've seen a Vendor's inventory after cycling. 
    // For now, we don't have that UI anymore. This property still exists for historical purposes. Don't worry about it.
    message AckState {
    }
    AckState ackState = 1;
    // If True, you can purchase from the Vendor.
    // Theoretically, Vendors can be restricted from selling items. In practice, none do that (yet?).
    bool canPurchase = 2;
    // If True, the Vendor is currently accessible. 
    // If False, they may not actually be visible in the world at the moment.
    bool enabled = 3;
    // The date when this vendor's inventory will next rotate/refresh.
    string nextRefreshDate = 4;
    // If the Vendor has a related Reputation, this is the Progression data that represents the character's Reputation level with this Vendor.
    message Progression {
    }
    Progression progression = 5;
    // The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.
    uint32 vendorHash = 6;
}

message Destiny.Entities.Vendors.DestinyVendorSaleItemComponent {
    // A summary of the current costs of the item.
    repeated Destiny.DestinyItemQuantity costs = 1;
    // Indexes in to the "failureStrings" lookup table in DestinyVendorDefinition for the given Vendor. Gives some more reliable failure information for why you can't purchase an item.
    // It is preferred to use these over requiredUnlocks and unlockStatuses: the latter are provided mostly in case someone can do something interesting with it that I didn't anticipate.
    repeated int32 failureIndexes = 2;
    // The hash of the item being sold, as a quick shortcut for looking up the DestinyInventoryItemDefinition of the sale item.
    uint32 itemHash = 3;
    // If you can't buy the item due to a complex character state, these will be hashes for DestinyUnlockDefinitions that you can check to see messages regarding the failure (if the unlocks have human readable information: it is not guaranteed that Unlocks will have human readable strings, and your application will have to handle that)
    // Prefer using failureIndexes instead. These are provided for informational purposes, but have largely been supplanted by failureIndexes.
    repeated uint32 requiredUnlocks = 4;
    // A flag indicating whether the requesting character can buy the item, and if not the reasons why the character can't buy it.
    message SaleStatus {
    }
    SaleStatus saleStatus = 5;
    // If any complex unlock states are checked in determining purchasability, these will be returned here along with the status of the unlock check.
    // Prefer using failureIndexes instead. These are provided for informational purposes, but have largely been supplanted by failureIndexes.
    repeated Destiny.DestinyUnlockStatus unlockStatuses = 6;
    // The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is* Content Version dependent: make sure you have the latest content before you use Vendor data, or these indexes may mismatch. 
    // Most systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid content dependency at the moment.
    int32 vendorItemIndex = 7;
}







repeated integer Destiny.HistoricalStats.Definitions.DestinyActivityModeType[] = 1

message Destiny.HistoricalStats.Definitions.DestinyHistoricalStatsDefinition {
    // Category for the stat.
    message Category {
    }
    Category category = 1;
    // Statistic group
    message Group {
    }
    Group group = 2;
    // Optional URI to an icon for the statistic
    string iconImage = 3;
    // The tier associated with this medal - be it implicitly or explicitly.
    uint32 medalTierHash = 4;
    // Optional icon for the statistic
    int32 mergeMethod = 5;
    // Game modes where this statistic can be reported.
    repeated integer modes = 6;
    // Time periods the statistic covers
    repeated integer periodTypes = 7;
    // Description of a stat if applicable.
    string statDescription = 8;
    // Unique programmer friendly ID for this stat
    string statId = 9;
    // Display name
    string statName = 10;
    // Localized Unit Name for the stat.
    string unitLabel = 11;
    // Unit, if any, for the statistic
    message UnitType {
    }
    UnitType unitType = 12;
    // Weight assigned to this stat indicating its relative impressiveness.
    int32 weight = 13;
}









repeated integer Destiny.HistoricalStats.Definitions.PeriodType[] = 1



message Destiny.HistoricalStats.DestinyActivityHistoryResults {
    // List of activities, the most recent activity first.
    repeated Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup activities = 1;
}

message Destiny.HistoricalStats.DestinyAggregateActivityResults {
    // List of all activities the player has participated in.
    repeated Destiny.HistoricalStats.DestinyAggregateActivityStats activities = 1;
}

message Destiny.HistoricalStats.DestinyAggregateActivityStats {
    // Hash ID that can be looked up in the DestinyActivityTable.
    uint32 activityHash = 1;
    // Collection of stats for the player in this activity.
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> values = 2;
}

message Destiny.HistoricalStats.DestinyClanAggregateStat {
    // The id of the mode of stats (allPvp, allPvE, etc)
    message Mode {
    }
    Mode mode = 1;
    // The id of the stat
    string statId = 2;
    // Value of the stat for this player
    message Value {
    }
    Value value = 3;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsAccountResult {
    repeated Destiny.HistoricalStats.DestinyHistoricalStatsPerCharacter characters = 1;
    Destiny.HistoricalStats.DestinyHistoricalStatsWithMerged mergedAllCharacters = 2;
    Destiny.HistoricalStats.DestinyHistoricalStatsWithMerged mergedDeletedCharacters = 3;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsActivity {
    uint32 directorActivityHash = 1;
    // This value can be used to get additional data about this activity such as who else was playing.
    int64 instanceId = 2;
    // Whether or not the match was a private match.
    bool isPrivate = 3;
    // Indicates the game mode of the activity.
    message Mode {
    }
    Mode mode = 4;
    repeated integer modes = 5;
    // Hash ID that can be looked up in the DestinyActivityTable.
    uint32 referenceId = 6;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod {
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> allTime = 1;
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> allTimeTier1 = 2;
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> allTimeTier2 = 3;
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> allTimeTier3 = 4;
    repeated Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup daily = 5;
    repeated Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup monthly = 6;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsPerCharacter {
    int64 characterId = 1;
    bool deleted = 2;
    Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod merged = 3;
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod> results = 4;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup {
    // If the period group is for a specific activity, this property will be set.
    message ActivityDetails {
    }
    ActivityDetails activityDetails = 1;
    // Period for the group. If the stat periodType is day, then this will have a specific day. If the type is monthly, then this value will be the first day of the applicable month. This value is not set when the periodType is 'all time'.
    string period = 2;
    // Collection of stats for the period.
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> values = 3;
}

map<string, Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod> Destiny.HistoricalStats.DestinyHistoricalStatsResults = 1

message Destiny.HistoricalStats.DestinyHistoricalStatsValue {
    // Basic stat value.
    message Basic {
    }
    Basic basic = 1;
    // Per game average for the statistic, if applicable
    message Pga {
    }
    Pga pga = 2;
    // Unique ID for this stat
    string statId = 3;
    // Weighted value of the stat if a weight greater than 1 has been assigned.
    message Weighted {
    }
    Weighted weighted = 4;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsValuePair {
    // Localized formated version of the value.
    string displayValue = 1;
    // Raw value of the statistic
    double value = 2;
}

message Destiny.HistoricalStats.DestinyHistoricalStatsWithMerged {
    Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod merged = 1;
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod> results = 2;
}

message Destiny.HistoricalStats.DestinyHistoricalWeaponStats {
    // The hash ID of the item definition that describes the weapon.
    uint32 referenceId = 1;
    // Collection of stats for the period.
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> values = 2;
}

message Destiny.HistoricalStats.DestinyHistoricalWeaponStatsData {
    // List of weapons and their perspective values.
    repeated Destiny.HistoricalStats.DestinyHistoricalWeaponStats weapons = 1;
}

message Destiny.HistoricalStats.DestinyLeaderboard {
    repeated Destiny.HistoricalStats.DestinyLeaderboardEntry entries = 1;
    string statId = 2;
}

message Destiny.HistoricalStats.DestinyLeaderboardEntry {
    // ID of the player's best character for the reported stat.
    int64 characterId = 1;
    // Identity details of the player
    message Player {
    }
    Player player = 2;
    // Where this player ranks on the leaderboard. A value of 1 is the top rank.
    int32 rank = 3;
    // Value of the stat for this player
    message Value {
    }
    Value value = 4;
}

map<string, object> Destiny.HistoricalStats.DestinyLeaderboardResults = 1

message Destiny.HistoricalStats.DestinyPlayer {
    // Details about the player as they are known on BungieNet. This will be undefined if the player has marked their credential private, or does not have a BungieNet account.
    message BungieNetUserInfo {
    }
    BungieNetUserInfo bungieNetUserInfo = 1;
    // Class of the character if applicable and available.
    string characterClass = 2;
    // Level of the character if available. Zero if it is not available.
    int32 characterLevel = 3;
    // Current clan name for the player. This value may be null or an empty string if the user does not have a clan.
    string clanName = 4;
    // Current clan tag for the player. This value may be null or an empty string if the user does not have a clan.
    string clanTag = 5;
    // Details about the player as they are known in game (platform display name, Destiny emblem)
    message DestinyUserInfo {
    }
    DestinyUserInfo destinyUserInfo = 6;
    // Light Level of the character if available. Zero if it is not available.
    int32 lightLevel = 7;
}

message Destiny.HistoricalStats.DestinyPostGameCarnageReportData {
    // Details about the activity.
    message ActivityDetails {
    }
    ActivityDetails activityDetails = 1;
    // Collection of players and their data for this activity.
    repeated Destiny.HistoricalStats.DestinyPostGameCarnageReportEntry entries = 2;
    // Date and time for the activity.
    string period = 3;
    // Collection of stats for the player in this activity.
    repeated Destiny.HistoricalStats.DestinyPostGameCarnageReportTeamEntry teams = 4;
}

message Destiny.HistoricalStats.DestinyPostGameCarnageReportEntry {
    // ID of the player's character used in the activity.
    int64 characterId = 1;
    // Extended data extracted from the activity blob.
    message Extended {
    }
    Extended extended = 2;
    // Identity details of the player
    message Player {
    }
    Player player = 3;
    // Score of the player if available
    message Score {
    }
    Score score = 4;
    // Standing of the player
    int32 standing = 5;
    // Collection of stats for the player in this activity.
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> values = 6;
}

message Destiny.HistoricalStats.DestinyPostGameCarnageReportExtendedData {
    // Collection of stats for the player in this activity.
    map<string, Destiny.HistoricalStats.DestinyHistoricalStatsValue> values = 1;
    // List of weapons and their perspective values.
    repeated Destiny.HistoricalStats.DestinyHistoricalWeaponStats weapons = 2;
}

message Destiny.HistoricalStats.DestinyPostGameCarnageReportTeamEntry {
    // Score earned by the team
    message Score {
    }
    Score score = 1;
    // Team's standing relative to other teams.
    message Standing {
    }
    Standing standing = 2;
    // Integer ID for the team.
    int32 teamId = 3;
    // Alpha or Bravo
    string teamName = 4;
}

message Destiny.Milestones.DestinyMilestone {
    // Indicates what quests are available for this Milestone. Usually this will be only a single Quest, but some quests have multiple available that you can choose from at any given time. All possible quests for a milestone can be found in the DestinyMilestoneDefinition, but they must be combined with this Live data to determine which one(s) are actually active right now. It is possible for Milestones to not have any quests.
    repeated Destiny.Milestones.DestinyMilestoneQuest availableQuests = 1;
    // If known, this is the date when the event will next end or repeat. It will only be populated for events with fixed and repeating start and end dates.
    string endDate = 2;
    // The unique identifier for the Milestone. Use it to look up the DestinyMilestoneDefinition, so you can combine the other data in this contract with static definition data.
    uint32 milestoneHash = 3;
    // If the entity to which this component is attached has known active Rewards for the player, this will detail information about those rewards, keyed by the RewardEntry Hash. (See DestinyMilestoneDefinition for more information about Reward Entries) Note that these rewards are not for the Quests related to the Milestone. Think of these as "overview/checklist" rewards that may be provided for Milestones that may provide rewards for performing a variety of tasks that aren't under a specific Quest.
    repeated Destiny.Milestones.DestinyMilestoneRewardCategory rewards = 4;
    // If known, this is the date when the event last began or refreshed. It will only be populated for events with fixed and repeating start and end dates.
    string startDate = 5;
    // Milestones may have arbitrary key/value pairs associated with them, for data that users will want to know about but that doesn't fit neatly into any of the common components such as Quests. A good example of this would be - if this existed in Destiny 1 - the number of wins you currently have on your Trials of Osiris ticket. Looking in the DestinyMilestoneDefinition, you can use the string identifier of this dictionary to look up more info about the value, including localized string content for displaying the value. The value in the dictionary is the floating point number. The definition will tell you how to format this number.
    map<string, number> values = 6;
    // A milestone may have one or more active vendors that are "related" to it (that provide rewards, or that are the initiators of the Milestone). I already regret this, even as I'm typing it. You see, sometimes a milestone may be directly correlated with a set of vendors that provide varying tiers of rewards. The player may not be able to interact with one or more of those vendors. This will return the hashes of the Vendors that the player *can* interact with, allowing you to show their current inventory as rewards or related items to the Milestone or its activities.
    repeated uint32 vendorHashes = 7;
}

message Destiny.Milestones.DestinyMilestoneActivity {
    // The hash of an arbitrarily chosen variant of this activity. We'll go ahead and call that the "canonical" activity, because if you're using this value you should only use it for properties that are common across the variants: things like the name of the activity, it's location, etc... Use this hash to look up the DestinyActivityDefinition of this activity for rendering data.
    uint32 activityHash = 1;
    // If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data. Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what's really live.
    repeated uint32 modifierHashes = 2;
    // If you want more than just name/location/etc... you're going to have to dig into and show the variants of the conceptual activity. These will differ in seemingly arbitrary ways, like difficulty level and modifiers applied. Show it in whatever way tickles your fancy.
    repeated Destiny.Milestones.DestinyMilestoneActivityVariant variants = 3;
}

message Destiny.Milestones.DestinyMilestoneActivityCompletionStatus {
    // If the activity has been "completed", that information will be returned here.
    bool completed = 1;
    // If the Activity has discrete "phases" that we can track, that info will be here. Otherwise, this value will be NULL. Note that this is a list and not a dictionary: the order implies the ascending order of phases or progression in this activity.
    repeated Destiny.Milestones.DestinyMilestoneActivityPhase phases = 2;
}

message Destiny.Milestones.DestinyMilestoneActivityPhase {
    // Indicates if the phase has been completed.
    bool complete = 1;
}

message Destiny.Milestones.DestinyMilestoneActivityVariant {
    // The hash for the specific variant of the activity related to this milestone. You can pull more detailed static info from the DestinyActivityDefinition, such as difficulty level.
    uint32 activityHash = 1;
    // An OPTIONAL component: if it makes sense to talk about this activity variant in terms of whether or not it has been completed or what progress you have made in it, this will be returned. Otherwise, this will be NULL.
    message CompletionStatus {
    }
    CompletionStatus completionStatus = 2;
}

message Destiny.Milestones.DestinyMilestoneContent {
    // The "About this Milestone" text from the Firehose.
    string about = 1;
    // If DPS has defined items related to this Milestone, they can categorize those items in the Firehose. That data will then be returned as item categories here.
    repeated Destiny.Milestones.DestinyMilestoneContentItemCategory itemCategories = 2;
    // The Current Status of the Milestone, as driven by the Firehose.
    string status = 3;
    // A list of tips, provided by the Firehose.
    repeated string tips = 4;
}

message Destiny.Milestones.DestinyMilestoneContentItemCategory {
    repeated uint32 itemHashes = 1;
    string title = 2;
}

message Destiny.Milestones.DestinyMilestoneQuest {
    // *IF* the Milestone has an active Activity that can give you greater details about what you need to do, it will be returned here. Remember to associate this with the DestinyMilestoneDefinition's activities to get details about the activity, including what specific quest it is related to if you have multiple quests to choose from.
    message Activity {
    }
    Activity activity = 1;
    // The activities referred to by this quest can have many associated challenges. They are all contained here, with activityHashes so that you can associate them with the specific activity variants in which they can be found. In retrospect, I probably should have put these under the specific Activity Variants, but it's too late to change it now. Theoretically, a quest without Activities can still have Challenges, which is why this is on a higher level than activity/variants, but it probably should have been in both places. That may come as a later revision.
    repeated Destiny.Challenges.DestinyChallengeStatus challenges = 2;
    // Quests are defined as Items in content. As such, this is the hash identifier of the DestinyInventoryItemDefinition that represents this quest. It will have pointers to all of the steps in the quest, and display information for the quest (title, description, icon etc) Individual steps will be referred to in the Quest item's DestinyInventoryItemDefinition.setData property, and themselves are Items with their own renderable data.
    uint32 questItemHash = 3;
    // The current status of the quest for the character making the request.
    message Status {
    }
    Status status = 4;
}

message Destiny.Milestones.DestinyMilestoneRewardCategory {
    // The individual reward entries for this category, and their status.
    repeated Destiny.Milestones.DestinyMilestoneRewardEntry entries = 1;
    // Look up the relevant DestinyMilestoneDefinition, and then use rewardCategoryHash to look up the category info in DestinyMilestoneDefinition.rewards.
    uint32 rewardCategoryHash = 2;
}

message Destiny.Milestones.DestinyMilestoneRewardEntry {
    // If TRUE, the player has earned this reward.
    bool earned = 1;
    // If TRUE, the player has redeemed/picked up/obtained this reward. Feel free to alias this to "gotTheShinyBauble" in your own codebase.
    bool redeemed = 2;
    // The identifier for the reward entry in question. It is important to look up the related DestinyMilestoneRewardEntryDefinition to get the static details about the reward, which you can do by looking up the milestone's DestinyMilestoneDefinition and examining the DestinyMilestoneDefinition.rewards[rewardCategoryHash].rewardEntries[rewardEntryHash] data.
    uint32 rewardEntryHash = 3;
}

message Destiny.Milestones.DestinyPublicMilestone {
    // A milestone not need have even a single quest, but if there are active quests they will be returned here.
    repeated Destiny.Milestones.DestinyPublicMilestoneQuest availableQuests = 1;
    // If known, this is the date when the Milestone will expire/recycle/end.
    string endDate = 2;
    // The hash identifier for the milestone. Use it to look up the DestinyMilestoneDefinition for static data about the Milestone.
    uint32 milestoneHash = 3;
    // If known, this is the date when the Milestone started/became active.
    string startDate = 4;
    // Sometimes milestones - or activities active in milestones - will have relevant vendors. These are the vendors that are currently relevant.
    repeated uint32 vendorHashes = 5;
}

message Destiny.Milestones.DestinyPublicMilestoneActivity {
    // The hash identifier of the activity that's been chosen to be considered the canonical "conceptual" activity definition. This may have many variants, defined herein.
    uint32 activityHash = 1;
    // The activity may have 0-to-many modifiers: if it does, this will contain the hashes to the DestinyActivityModifierDefinition that defines the modifier being applied.
    repeated uint32 modifierHashes = 2;
    // Every relevant variation of this conceptual activity, including the conceptual activity itself, have variants defined here.
    repeated Destiny.Milestones.DestinyPublicMilestoneActivityVariant variants = 3;
}

message Destiny.Milestones.DestinyPublicMilestoneActivityVariant {
    // The hash identifier of this activity variant. Examine the activity's definition in the Manifest database to determine what makes it a distinct variant. Usually it will be difficulty level or whether or not it is a guided game variant of the activity, but theoretically it could be distinguished in any arbitrary way.
    uint32 activityHash = 1;
}

message Destiny.Milestones.DestinyPublicMilestoneChallenge {
    // IF the Objective is related to a specific Activity, this will be that activity's hash. Use it to look up the DestinyActivityDefinition for additional data to show.
    uint32 activityHash = 1;
    // The objective for the Challenge, which should have human-readable data about what needs to be done to accomplish the objective. Use this hash to look up the DestinyObjectiveDefinition.
    uint32 objectiveHash = 2;
}

message Destiny.Milestones.DestinyPublicMilestoneQuest {
    // A milestone need not have an active activity, but if there is one it will be returned here, along with any variant and additional information.
    message Activity {
    }
    Activity activity = 1;
    // For the given quest there could be 0-to-Many challenges: mini quests that you can perform in the course of doing this quest, that may grant you rewards and benefits.
    repeated Destiny.Milestones.DestinyPublicMilestoneChallenge challenges = 2;
    // Quests are defined as Items in content. As such, this is the hash identifier of the DestinyInventoryItemDefinition that represents this quest. It will have pointers to all of the steps in the quest, and display information for the quest (title, description, icon etc) Individual steps will be referred to in the Quest item's DestinyInventoryItemDefinition.setData property, and themselves are Items with their own renderable data.
    uint32 questItemHash = 3;
}

message Destiny.Perks.DestinyPerkReference {
    // The icon for the perk.
    string iconPath = 1;
    // Whether this perk is currently active. (We may return perks that you have not actually activated yet: these represent perks that you should show in the item's tooltip, but that the user has not yet activated.)
    bool isActive = 2;
    // The hash identifier for the perk, which can be used to look up DestinySandboxPerkDefinition if it exists. Be warned, perks frequently do not have user-viewable information. You should examine whether you actually found a name/description in the perk's definition before you show it to the user.
    uint32 perkHash = 3;
    // Some perks provide benefits, but aren't visible in the UI. This value will let you know if this is perk should be shown in your UI.
    bool visible = 4;
}

message Destiny.Progression.DestinyFactionProgression {
    // This is the total amount of progress obtained overall for this progression (for instance, the total amount of Character Level experience earned)
    int32 currentProgress = 1;
    // If this progression has a daily limit, this is that limit.
    int32 dailyLimit = 2;
    // The amount of progress earned today for this progression.
    int32 dailyProgress = 3;
    // The hash identifier of the Faction related to this progression. Use it to look up the DestinyFactionDefinition for more rendering info.
    uint32 factionHash = 4;
    // This is the level of the progression (for instance, the Character Level).
    int32 level = 5;
    // This is the maximum possible level you can achieve for this progression (for example, the maximum character level obtainable)
    int32 levelCap = 6;
    // The total amount of progression (i.e. "Experience") needed in order to reach the next level.
    int32 nextLevelAt = 7;
    // The amount of progression (i.e. "Experience") needed to reach the next level of this Progression. Jeez, progression is such an overloaded word.
    int32 progressToNextLevel = 8;
    // The hash identifier of the Progression in question. Use it to look up the DestinyProgressionDefinition in static data.
    uint32 progressionHash = 9;
    // Progressions define their levels in "steps". Since the last step may be repeatable, the user may be at a higher level than the actual Step achieved in the progression. Not necessarily useful, but potentially interesting for those cruising the API. Relate this to the "steps" property of the DestinyProgression to see which step the user is on, if you care about that. (Note that this is Content Version dependent since it refers to indexes.)
    int32 stepIndex = 10;
    // If this progression has a weekly limit, this is that limit.
    int32 weeklyLimit = 11;
    // The amount of progress earned toward this progression in the current week.
    int32 weeklyProgress = 12;
}

message Destiny.Quests.DestinyObjectiveProgress {
    // If the Objective has an Activity associated with it, this is the unique identifier of the Activity being referred to. Use to look up the DestinyActivityDefinition in static data. This will give localized data about *what* you should be playing for the objective to be achieved.
    uint32 activityHash = 1;
    // Whether or not the Objective is completed.
    bool complete = 2;
    // If the Objective has a Destination associated with it, this is the unique identifier of the Destination being referred to. Use to look up the DestinyDestinationDefinition in static data. This will give localized data about *where* in the universe the objective should be achieved.
    uint32 destinationHash = 3;
    // The unique identifier of the Objective being referred to. Use to look up the DestinyObjectiveDefinition in static data.
    uint32 objectiveHash = 4;
    // If progress has been made, and the progress can be measured numerically, this will be the value of that progress. You can compare it to the DestinyObjectiveDefinition.completionValue property for current vs. upper bounds, and use DestinyObjectiveDefinition.valueStyle to determine how this should be rendered. Note that progress, in Destiny 2, need not be a literal numeric progression. It could be one of a number of possible values, even a Timestamp. Always examine DestinyObjectiveDefinition.valueStyle before rendering progress.
    int32 progress = 5;
}

message Destiny.Quests.DestinyQuestStatus {
    // Whether or not the whole quest has been completed, regardless of whether or not you have redeemed the rewards for the quest.
    bool completed = 1;
    // The current Quest Step will be an instanced item in the player's inventory. If you care about that, this is the instance ID of that item.
    int64 itemInstanceId = 2;
    // The hash identifier for the Quest Item. (Note: Quests are defined as Items, and thus you would use this to look up the quest's DestinyInventoryItemDefinition). For information on all steps in the quest, you can then examine its DestinyInventoryItemDefinition.setData property for Quest Steps (which are *also* items). You can use the Item Definition to display human readable data about the overall quest.
    uint32 questHash = 3;
    // Whether or not you have redeemed rewards for this quest.
    bool redeemed = 4;
    // Whether or not you have started this quest.
    bool started = 5;
    // The hash identifier of the current Quest Step, which is also a DestinyInventoryItemDefinition. You can use this to get human readable data about the current step and what to do in that step.
    uint32 stepHash = 6;
    // A step can have multiple objectives. This will give you the progress for each objective in the current step, in the order in which they are rendered in-game.
    repeated Destiny.Quests.DestinyObjectiveProgress stepObjectives = 7;
    // Whether or not the quest is tracked
    bool tracked = 8;
    // If the quest has a related Vendor that you should talk to in order to initiate the quest/earn rewards/continue the quest, this will be the hash identifier of that Vendor. Look it up its DestinyVendorDefinition.
    uint32 vendorHash = 9;
}

message Destiny.Requests.Actions.DestinyActionRequest {
    integer membershipType = 1;
}

message Destiny.Requests.Actions.DestinyCharacterActionRequest {
    int64 characterId = 1;
    integer membershipType = 2;
}

message Destiny.Requests.Actions.DestinyItemActionRequest {
    int64 characterId = 1;
    int64 itemId = 2;
    integer membershipType = 3;
}

message Destiny.Requests.Actions.DestinyItemSetActionRequest {
    int64 characterId = 1;
    repeated int64 itemIds = 2;
    integer membershipType = 3;
}

message Destiny.Requests.Actions.DestinyItemStateRequest {
    int64 characterId = 1;
    int64 itemId = 2;
    integer membershipType = 3;
    bool state = 4;
}

message Destiny.Requests.DestinyItemTransferRequest {
    int64 characterId = 1;
    int64 itemId = 2;
    uint32 itemReferenceHash = 3;
    integer membershipType = 4;
    int32 stackSize = 5;
    bool transferToVault = 6;
}

message Destiny.Responses.DestinyCharacterResponse {
    // Activity data - info about current activities available to the player.
    // COMPONENT TYPE: CharacterActivities
    message Activities {
    }
    Activities activities = 1;
    // Base information about the character in question.
    // COMPONENT TYPE: Characters
    message Character {
    }
    Character character = 2;
    // Equipped items on the character.
    // COMPONENT TYPE: CharacterEquipment
    message Equipment {
    }
    Equipment equipment = 3;
    // The character-level non-equipped inventory items.
    // COMPONENT TYPE: CharacterInventories
    message Inventory {
    }
    Inventory inventory = 4;
    // The set of components belonging to the player's instanced items.
    // COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
    message ItemComponents {
    }
    ItemComponents itemComponents = 5;
    // Items available from Kiosks that are available to this specific character. 
    // COMPONENT TYPE: Kiosks
    message Kiosks {
    }
    Kiosks kiosks = 6;
    // Character progression data, including Milestones.
    // COMPONENT TYPE: CharacterProgressions
    message Progressions {
    }
    Progressions progressions = 7;
    // Character rendering data - a minimal set of information about equipment and dyes used for rendering.
    // COMPONENT TYPE: CharacterRenderData
    message RenderData {
    }
    RenderData renderData = 8;
}

message Destiny.Responses.DestinyItemResponse {
    // If the item is on a character, this will return the ID of the character that is holding the item.
    int64 characterId = 1;
    // Basic instance data for the item.
    // COMPONENT TYPE: ItemInstances
    message Instance {
    }
    Instance instance = 2;
    // Common data for the item relevant to its non-instanced properties.
    // COMPONENT TYPE: ItemCommonData
    message Item {
    }
    Item item = 3;
    // Information specifically about the item's objectives.
    // COMPONENT TYPE: ItemObjectives
    message Objectives {
    }
    Objectives objectives = 4;
    // Information specifically about the perks currently active on the item.
    // COMPONENT TYPE: ItemPerks
    message Perks {
    }
    Perks perks = 5;
    // Information about how to render the item in 3D.
    // COMPONENT TYPE: ItemRenderData
    message RenderData {
    }
    RenderData renderData = 6;
    // Information about the sockets of the item: which are currently active, what potential sockets you could have and the stats/abilities/perks you can gain from them.
    // COMPONENT TYPE: ItemSockets
    message Sockets {
    }
    Sockets sockets = 7;
    // Information about the computed stats of the item: power, defense, etc...
    // COMPONENT TYPE: ItemStats
    message Stats {
    }
    Stats stats = 8;
    // Information about the talent grid attached to the item. Talent nodes can provide a variety of benefits and abilities, and in Destiny 2 are used almost exclusively for the character's "Builds".
    // COMPONENT TYPE: ItemTalentGrids
    message TalentGrid {
    }
    TalentGrid talentGrid = 9;
}

message Destiny.Responses.DestinyProfileResponse {
    // Character activity data - the activities available to this character and its status, keyed by the Character's Id.
    // COMPONENT TYPE: CharacterActivities
    message CharacterActivities {
    }
    CharacterActivities characterActivities = 1;
    // The character's equipped items, keyed by the Character's Id.
    // COMPONENT TYPE: CharacterEquipment
    message CharacterEquipment {
    }
    CharacterEquipment characterEquipment = 2;
    // The character-level non-equipped inventory items, keyed by the Character's Id.
    // COMPONENT TYPE: CharacterInventories
    message CharacterInventories {
    }
    CharacterInventories characterInventories = 3;
    // Items available from Kiosks that are available to a specific character as opposed to the account as a whole. It must be combined with data from the profileKiosks property to get a full picture of the character's available items to check out of a kiosk.
    // This component returns information about what Kiosk items are available to you on a *Character* level. Usually, kiosk items will be earned for the entire Profile (all characters) at once. To find those, look in the profileKiosks property.
    // COMPONENT TYPE: Kiosks
    message CharacterKiosks {
    }
    CharacterKiosks characterKiosks = 4;
    // Character-level progression data, keyed by the Character's Id.
    // COMPONENT TYPE: CharacterProgressions
    message CharacterProgressions {
    }
    CharacterProgressions characterProgressions = 5;
    // Character rendering data - a minimal set of info needed to render a character in 3D - keyed by the Character's Id.
    // COMPONENT TYPE: CharacterRenderData
    message CharacterRenderData {
    }
    CharacterRenderData characterRenderData = 6;
    // Basic information about each character, keyed by the CharacterId.
    // COMPONENT TYPE: Characters
    message Characters {
    }
    Characters characters = 7;
    // Information about instanced items across all returned characters, keyed by the item's instance ID.
    // COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
    message ItemComponents {
    }
    ItemComponents itemComponents = 8;
    // The basic information about the Destiny Profile (formerly "Account").
    // COMPONENT TYPE: Profiles
    message Profile {
    }
    Profile profile = 9;
    // The profile-level currencies owned by the Destiny Profile.
    // COMPONENT TYPE: ProfileCurrencies
    message ProfileCurrencies {
    }
    ProfileCurrencies profileCurrencies = 10;
    // The profile-level inventory of the Destiny Profile.
    // COMPONENT TYPE: ProfileInventories
    message ProfileInventory {
    }
    ProfileInventory profileInventory = 11;
    // Items available from Kiosks that are available Profile-wide (i.e. across all characters)
    // This component returns information about what Kiosk items are available to you on a *Profile* level. It is theoretically possible for Kiosks to have items gated by specific Character as well. If you ever have those, you will find them on the characterKiosks property.
    // COMPONENT TYPE: Kiosks
    message ProfileKiosks {
    }
    ProfileKiosks profileKiosks = 12;
    // Recent, refundable purchases you have made from vendors. When will you use it? Couldn't say...
    // COMPONENT TYPE: VendorReceipts
    message VendorReceipts {
    }
    VendorReceipts vendorReceipts = 13;
}

message Destiny.Responses.DestinyVendorResponse {
    // Categories that the vendor has available, and references to the sales therein.
    // COMPONENT TYPE: VendorCategories
    message Categories {
    }
    Categories categories = 1;
    // Item components, keyed by the vendorItemIndex of the active sale items.
    // COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
    message Items {
    }
    Items items = 2;
    // Sales, keyed by the vendorItemIndex of the item being sold.
    // COMPONENT TYPE: VendorSales
    message Sales {
    }
    Sales sales = 3;
    // The base properties of the vendor.
    // COMPONENT TYPE: Vendors
    message Vendor {
    }
    Vendor vendor = 4;
}

message Destiny.Vendors.DestinyVendorReceipt {
    // The amount paid for the item, in terms of items that were consumed in the purchase and their quantity.
    repeated Destiny.DestinyItemQuantity currencyPaid = 1;
    // The date at which this receipt is rendered invalid.
    string expiresOn = 2;
    // The item that was received, and its quantity.
    message ItemReceived {
    }
    ItemReceived itemReceived = 3;
    // The unlock flag used to determine whether you still have the purchased item.
    uint32 licenseUnlockHash = 4;
    // The ID of the character who made the purchase.
    int64 purchasedByCharacterId = 5;
    // Whether you can get a refund, and what happens in order for the refund to be received. See the DestinyVendorItemRefundPolicy enum for details.
    message RefundPolicy {
    }
    RefundPolicy refundPolicy = 6;
    // The identifier of this receipt.
    int32 sequenceNumber = 7;
    // The seconds since epoch at which this receipt is rendered invalid.
    int64 timeToExpiration = 8;
}

message DestinyItemComponentSetOfint32 {
    DictionaryComponentResponseOfint32AndDestinyItemInstanceComponent instances = 1;
    DictionaryComponentResponseOfint32AndDestinyItemObjectivesComponent objectives = 2;
    DictionaryComponentResponseOfint32AndDestinyItemPerksComponent perks = 3;
    DictionaryComponentResponseOfuint32AndDestinyItemPlugComponent plugStates = 4;
    DictionaryComponentResponseOfint32AndDestinyItemRenderComponent renderData = 5;
    DictionaryComponentResponseOfint32AndDestinyItemSocketsComponent sockets = 6;
    DictionaryComponentResponseOfint32AndDestinyItemStatsComponent stats = 7;
    DictionaryComponentResponseOfint32AndDestinyItemTalentGridComponent talentGrids = 8;
}

message DestinyItemComponentSetOfint64 {
    DictionaryComponentResponseOfint64AndDestinyItemInstanceComponent instances = 1;
    DictionaryComponentResponseOfint64AndDestinyItemObjectivesComponent objectives = 2;
    DictionaryComponentResponseOfint64AndDestinyItemPerksComponent perks = 3;
    DictionaryComponentResponseOfuint32AndDestinyItemPlugComponent plugStates = 4;
    DictionaryComponentResponseOfint64AndDestinyItemRenderComponent renderData = 5;
    DictionaryComponentResponseOfint64AndDestinyItemSocketsComponent sockets = 6;
    DictionaryComponentResponseOfint64AndDestinyItemStatsComponent stats = 7;
    DictionaryComponentResponseOfint64AndDestinyItemTalentGridComponent talentGrids = 8;
}

message DictionaryComponentResponseOfint32AndDestinyItemInstanceComponent {
    map<string, Destiny.Entities.Items.DestinyItemInstanceComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyItemObjectivesComponent {
    map<string, Destiny.Entities.Items.DestinyItemObjectivesComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyItemPerksComponent {
    map<string, Destiny.Entities.Items.DestinyItemPerksComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyItemRenderComponent {
    map<string, Destiny.Entities.Items.DestinyItemRenderComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyItemSocketsComponent {
    map<string, Destiny.Entities.Items.DestinyItemSocketsComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyItemStatsComponent {
    map<string, Destiny.Entities.Items.DestinyItemStatsComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyItemTalentGridComponent {
    map<string, Destiny.Entities.Items.DestinyItemTalentGridComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint32AndDestinyVendorSaleItemComponent {
    map<string, Destiny.Entities.Vendors.DestinyVendorSaleItemComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyCharacterActivitiesComponent {
    map<string, Destiny.Entities.Characters.DestinyCharacterActivitiesComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyCharacterComponent {
    map<string, Destiny.Entities.Characters.DestinyCharacterComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyCharacterProgressionComponent {
    map<string, Destiny.Entities.Characters.DestinyCharacterProgressionComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyCharacterRenderComponent {
    map<string, Destiny.Entities.Characters.DestinyCharacterRenderComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyInventoryComponent {
    map<string, Destiny.Entities.Inventory.DestinyInventoryComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemInstanceComponent {
    map<string, Destiny.Entities.Items.DestinyItemInstanceComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemObjectivesComponent {
    map<string, Destiny.Entities.Items.DestinyItemObjectivesComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemPerksComponent {
    map<string, Destiny.Entities.Items.DestinyItemPerksComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemRenderComponent {
    map<string, Destiny.Entities.Items.DestinyItemRenderComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemSocketsComponent {
    map<string, Destiny.Entities.Items.DestinyItemSocketsComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemStatsComponent {
    map<string, Destiny.Entities.Items.DestinyItemStatsComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyItemTalentGridComponent {
    map<string, Destiny.Entities.Items.DestinyItemTalentGridComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfint64AndDestinyKiosksComponent {
    map<string, Destiny.Components.Kiosks.DestinyKiosksComponent> data = 1;
    integer privacy = 2;
}

message DictionaryComponentResponseOfuint32AndDestinyItemPlugComponent {
    map<string, Destiny.Components.Items.DestinyItemPlugComponent> data = 1;
    integer privacy = 2;
}

message Entities.EntityActionResult {
    int64 entityId = 1;
    integer result = 2;
}

message Forum.ForumRecruitmentDetail {
    repeated User.GeneralUser Fireteam = 1;
    bool approved = 2;
    int64 conversationId = 3;
    integer intensity = 4;
    repeated int64 kickedPlayerIds = 5;
    bool microphoneRequired = 6;
    int32 playerSlotsRemaining = 7;
    int32 playerSlotsTotal = 8;
    integer tone = 9;
    int64 topicId = 10;
}

message Forum.PollResponse {
    repeated Forum.PollResult results = 1;
    int64 topicId = 2;
    int32 totalVotes = 3;
}

message Forum.PollResult {
    int32 answerSlot = 1;
    string answerText = 2;
    string lastVoteDate = 3;
    bool requestingUserVoted = 4;
    int32 votes = 5;
}

message Forum.PostResponse {
    bool IsPinned = 1;
    Ignores.IgnoreResponse ignoreStatus = 2;
    bool isActive = 3;
    bool isAnnouncement = 4;
    string lastReplyTimestamp = 5;
    int64 latestReplyAuthorId = 6;
    int64 latestReplyPostId = 7;
    string locale = 8;
    integer popularity = 9;
    string thumbnail = 10;
    integer urlMediaType = 11;
    bool userHasMutedPost = 12;
    bool userHasRated = 13;
    int32 userRating = 14;
}

message Forum.PostSearchResponse {
    repeated User.GeneralUser authors = 1;
    int32 availablePages = 2;
    repeated GroupsV2.GroupResponse groups = 3;
    bool hasMore = 4;
    repeated Forum.PollResponse polls = 5;
    Queries.PagedQuery query = 6;
    repeated Forum.ForumRecruitmentDetail recruitmentDetails = 7;
    repeated Forum.PostResponse relatedPosts = 8;
    string replacementContinuationToken = 9;
    repeated Forum.PostResponse results = 10;
    repeated Tags.Models.Contracts.TagResponse searchedTags = 11;
    int32 totalResults = 12;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 13;
}

message GroupsV2.ClanBanner {
    uint32 decalBackgroundColorId = 1;
    uint32 decalColorId = 2;
    uint32 decalId = 3;
    uint32 gonfalonColorId = 4;
    uint32 gonfalonDetailColorId = 5;
    uint32 gonfalonDetailId = 6;
    uint32 gonfalonId = 7;
}

message GroupsV2.GroupAction {
    string about = 1;
    bool allowChat = 2;
    int32 avatarImageIndex = 3;
    string callsign = 4;
    integer chatSecurity = 5;
    // Type of group, either Bungie.net hosted group, or a game services hosted clan.
    message GroupType {
    }
    GroupType groupType = 6;
    integer homepage = 7;
    bool isDefaultPostAlliance = 8;
    bool isDefaultPostPublic = 9;
    bool isPublic = 10;
    bool isPublicTopicAdminOnly = 11;
    string locale = 12;
    integer membershipOption = 13;
    string motto = 14;
    string name = 15;
    // When operation needs a platform specific account ID for the present user, use this property. In particular, groupType of Clan requires this value to be set.
    message PlatformMembershipType {
    }
    PlatformMembershipType platformMembershipType = 16;
    string tags = 17;
    string theme = 18;
}

message GroupsV2.GroupApplicationListRequest {
    repeated User.UserMembership memberships = 1;
    string message = 2;
}

message GroupsV2.GroupApplicationRequest {
    string message = 1;
}

message GroupsV2.GroupApplicationResponse {
    integer resolution = 1;
}

message GroupsV2.GroupBan {
    User.UserInfoCard bungieNetUserInfo = 1;
    string comment = 2;
    User.UserInfoCard createdBy = 3;
    string dateBanned = 4;
    string dateExpires = 5;
    User.UserInfoCard destinyUserInfo = 6;
    int64 groupId = 7;
    User.UserInfoCard lastModifiedBy = 8;
}

message GroupsV2.GroupBanRequest {
    string comment = 1;
    integer length = 2;
}

message GroupsV2.GroupCreationResponse {
    int64 groupId = 1;
}

message GroupsV2.GroupEditAction {
    string about = 1;
    bool allowChat = 2;
    int32 avatarImageIndex = 3;
    string callsign = 4;
    int32 chatSecurity = 5;
    int32 defaultPublicity = 6;
    bool enableInvitationMessagingForAdmins = 7;
    int32 homepage = 8;
    bool isPublic = 9;
    bool isPublicTopicAdminOnly = 10;
    string locale = 11;
    int32 membershipOption = 12;
    string motto = 13;
    string name = 14;
    string tags = 15;
    string theme = 16;
}

message GroupsV2.GroupFeatures {
    integer capabilities = 1;
    // Minimum Member Level allowed to host guided games
    // Always Allowed: Founder, Acting Founder, Admin
    // Allowed Overrides: None, Member, Beginner
    // Default is Member for clans, None for groups, although this means nothing for groups.
    message HostGuidedGamePermissionOverride {
    }
    HostGuidedGamePermissionOverride hostGuidedGamePermissionOverride = 2;
    // Minimum Member Level allowed to invite new members to group
    // Always Allowed: Founder, Acting Founder
    // True means admins have this power, false means they don't
    // Default is false for clans, true for groups.
    bool invitePermissionOverride = 3;
    // Level to join a member at when accepting an invite, application, or joining an open clan
    // Default is Beginner.
    message JoinLevel {
    }
    JoinLevel joinLevel = 4;
    int32 maximumMembers = 5;
    // Maximum number of groups of this type a typical membership may join. For example, a user may join about 50 General groups with their Bungie.net account. They may join one clan per Destiny membership.
    int32 maximumMembershipsOfGroupType = 6;
    repeated integer membershipTypes = 7;
    // Minimum Member Level allowed to update banner
    // Always Allowed: Founder, Acting Founder
    // True means admins have this power, false means they don't
    // Default is false for clans, true for groups.
    bool updateBannerPermissionOverride = 8;
    // Minimum Member Level allowed to update group culture
    // Always Allowed: Founder, Acting Founder
    // True means admins have this power, false means they don't
    // Default is false for clans, true for groups.
    bool updateCulturePermissionOverride = 9;
}

message GroupsV2.GroupMember {
    User.UserInfoCard bungieNetUserInfo = 1;
    User.UserInfoCard destinyUserInfo = 2;
    int64 groupId = 3;
    bool isOnline = 4;
    string joinDate = 5;
    integer memberType = 6;
}

message GroupsV2.GroupMemberApplication {
    User.UserInfoCard bungieNetUserInfo = 1;
    string creationDate = 2;
    User.UserInfoCard destinyUserInfo = 3;
    int64 groupId = 4;
    string requestMessage = 5;
    string resolveDate = 6;
    string resolveMessage = 7;
    integer resolveState = 8;
    int64 resolvedByMembershipId = 9;
}

message GroupsV2.GroupMemberLeaveResult {
    GroupsV2.GroupV2 group = 1;
    bool groupDeleted = 2;
}

message GroupsV2.GroupMembership {
    GroupsV2.GroupV2 group = 1;
    GroupsV2.GroupMember member = 2;
}

message GroupsV2.GroupMembershipBase {
    GroupsV2.GroupV2 group = 1;
}

message GroupsV2.GroupMembershipSearchResponse {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupMembership results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message GroupsV2.GroupOptionalConversation {
    bool chatEnabled = 1;
    string chatName = 2;
    integer chatSecurity = 3;
    int64 conversationId = 4;
    int64 groupId = 5;
}

message GroupsV2.GroupOptionalConversationAddRequest {
    string chatName = 1;
    integer chatSecurity = 2;
}

message GroupsV2.GroupOptionalConversationEditRequest {
    bool chatEnabled = 1;
    string chatName = 2;
    int32 chatSecurity = 3;
}

message GroupsV2.GroupOptionsEditAction {
    // Minimum Member Level allowed to host guided games
    // Always Allowed: Founder, Acting Founder, Admin
    // Allowed Overrides: None, Member, Beginner
    // Default is Member for clans, None for groups, although this means nothing for groups.
    int32 HostGuidedGamePermissionOverride = 1;
    // Minimum Member Level allowed to invite new members to group
    // Always Allowed: Founder, Acting Founder
    // True means admins have this power, false means they don't
    // Default is false for clans, true for groups.
    bool InvitePermissionOverride = 2;
    // Level to join a member at when accepting an invite, application, or joining an open clan
    // Default is Beginner.
    int32 JoinLevel = 3;
    // Minimum Member Level allowed to update banner
    // Always Allowed: Founder, Acting Founder
    // True means admins have this power, false means they don't
    // Default is false for clans, true for groups.
    bool UpdateBannerPermissionOverride = 4;
    // Minimum Member Level allowed to update group culture
    // Always Allowed: Founder, Acting Founder
    // True means admins have this power, false means they don't
    // Default is false for clans, true for groups.
    bool UpdateCulturePermissionOverride = 5;
}

message GroupsV2.GroupPotentialMember {
    User.UserInfoCard bungieNetUserInfo = 1;
    User.UserInfoCard destinyUserInfo = 2;
    int64 groupId = 3;
    string joinDate = 4;
    integer potentialStatus = 5;
}

message GroupsV2.GroupPotentialMembership {
    GroupsV2.GroupV2 group = 1;
    GroupsV2.GroupPotentialMember member = 2;
}

message GroupsV2.GroupPotentialMembershipSearchResponse {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupPotentialMembership results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message GroupsV2.GroupQuery {
    integer creationDate = 1;
    int32 currentPage = 2;
    int32 groupMemberCountFilter = 3;
    integer groupType = 4;
    int32 itemsPerPage = 5;
    string localeFilter = 6;
    string name = 7;
    string requestContinuationToken = 8;
    integer sortBy = 9;
    string tagText = 10;
}

message GroupsV2.GroupResponse {
    integer allianceStatus = 1;
    repeated int64 alliedIds = 2;
    // This property will be populated if the authenticated user is a member of the group. Note that because of account linking, a user can sometimes be part of a clan more than once. As such, this returns the highest member type available.
    map<string, GroupsV2.GroupMember> currentUserMemberMap = 3;
    // This property will be populated if the authenticated user is an applicant or has an outstanding invitation to join. Note that because of account linking, a user can sometimes be part of a clan more than once.
    map<string, GroupsV2.GroupPotentialMember> currentUserPotentialMemberMap = 4;
    GroupsV2.GroupV2 detail = 5;
    GroupsV2.GroupMember founder = 6;
    int32 groupJoinInviteCount = 7;
    GroupsV2.GroupV2 parentGroup = 8;
}

message GroupsV2.GroupSearchResponse {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupV2Card results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message GroupsV2.GroupUserBase {
    User.UserInfoCard bungieNetUserInfo = 1;
    User.UserInfoCard destinyUserInfo = 2;
    int64 groupId = 3;
    string joinDate = 4;
}

message GroupsV2.GroupV2 {
    string about = 1;
    bool allowChat = 2;
    int32 avatarImageIndex = 3;
    string avatarPath = 4;
    string banExpireDate = 5;
    string bannerPath = 6;
    integer chatSecurity = 7;
    GroupsV2.GroupV2ClanInfoAndInvestment clanInfo = 8;
    int64 conversationId = 9;
    string creationDate = 10;
    integer defaultPublicity = 11;
    bool enableInvitationMessagingForAdmins = 12;
    GroupsV2.GroupFeatures features = 13;
    int64 groupId = 14;
    integer groupType = 15;
    integer homepage = 16;
    bool isAllianceOwner = 17;
    bool isDefaultPostPublic = 18;
    bool isPublic = 19;
    bool isPublicTopicAdminOnly = 20;
    string locale = 21;
    int32 memberCount = 22;
    int64 membershipIdCreated = 23;
    integer membershipOption = 24;
    string modificationDate = 25;
    string motto = 26;
    string name = 27;
    int64 primaryAlliedGroupId = 28;
    repeated string tags = 29;
    string theme = 30;
}

message GroupsV2.GroupV2Card {
    string about = 1;
    string avatarPath = 2;
    integer capabilities = 3;
    GroupsV2.GroupV2ClanInfo clanInfo = 4;
    string creationDate = 5;
    int64 groupId = 6;
    integer groupType = 7;
    string locale = 8;
    int32 memberCount = 9;
    integer membershipOption = 10;
    string motto = 11;
    string name = 12;
    string theme = 13;
}

message GroupsV2.GroupV2ClanInfo {
    GroupsV2.ClanBanner clanBannerData = 1;
    string clanCallsign = 2;
}

message GroupsV2.GroupV2ClanInfoAndInvestment {
    GroupsV2.ClanBanner clanBannerData = 1;
    string clanCallsign = 2;
    map<string, Destiny.DestinyProgression> d2ClanProgressions = 3;
}

message Ignores.IgnoreResponse {
    integer ignoreFlags = 1;
    bool isIgnored = 2;
}

message Interpolation.InterpolationPoint {
    int32 value = 1;
    int32 weight = 2;
}

message Interpolation.InterpolationPointFloat {
    float value = 1;
    float weight = 2;
}

message Links.HyperlinkReference {
    string title = 1;
    string url = 2;
}

message Messages.Responses.SaveMessageResult {
    int64 conversationId = 1;
    int64 messageId = 2;
}

message Partnerships.PublicPartnershipDetail {
    string icon = 1;
    string identifier = 2;
    string name = 3;
    integer partnerType = 4;
}

message Queries.PagedQuery {
    int32 currentPage = 1;
    int32 itemsPerPage = 2;
    string requestContinuationToken = 3;
}

message Queries.SearchResult {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    int32 totalResults = 4;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 5;
}

message SearchResultOfCommunityLiveStatus {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated Community.CommunityLiveStatus results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfDestinyEntitySearchResultItem {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated Destiny.Definitions.DestinyEntitySearchResultItem results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfGroupBan {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupBan results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfGroupMember {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupMember results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfGroupMemberApplication {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupMemberApplication results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfGroupMembership {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupMembership results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfGroupPotentialMembership {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupPotentialMembership results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfGroupV2Card {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated GroupsV2.GroupV2Card results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfPostResponse {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated Forum.PostResponse results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SearchResultOfTrendingEntry {
    bool hasMore = 1;
    Queries.PagedQuery query = 2;
    string replacementContinuationToken = 3;
    repeated Trending.TrendingEntry results = 4;
    int32 totalResults = 5;
    // If useTotalResults is true, then totalResults represents an accurate count.
    // If False, it does not, and may be estimated/only the size of the current page.
    // Either way, you should probably always only trust hasMore.
    // This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
    bool useTotalResults = 6;
}

message SingleComponentResponseOfDestinyCharacterActivitiesComponent {
    Destiny.Entities.Characters.DestinyCharacterActivitiesComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyCharacterComponent {
    Destiny.Entities.Characters.DestinyCharacterComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyCharacterProgressionComponent {
    Destiny.Entities.Characters.DestinyCharacterProgressionComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyCharacterRenderComponent {
    Destiny.Entities.Characters.DestinyCharacterRenderComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyInventoryComponent {
    Destiny.Entities.Inventory.DestinyInventoryComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemComponent {
    Destiny.Entities.Items.DestinyItemComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemInstanceComponent {
    Destiny.Entities.Items.DestinyItemInstanceComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemObjectivesComponent {
    Destiny.Entities.Items.DestinyItemObjectivesComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemPerksComponent {
    Destiny.Entities.Items.DestinyItemPerksComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemRenderComponent {
    Destiny.Entities.Items.DestinyItemRenderComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemSocketsComponent {
    Destiny.Entities.Items.DestinyItemSocketsComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemStatsComponent {
    Destiny.Entities.Items.DestinyItemStatsComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyItemTalentGridComponent {
    Destiny.Entities.Items.DestinyItemTalentGridComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyKiosksComponent {
    Destiny.Components.Kiosks.DestinyKiosksComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyProfileComponent {
    Destiny.Entities.Profiles.DestinyProfileComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyVendorCategoriesComponent {
    Destiny.Entities.Vendors.DestinyVendorCategoriesComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyVendorComponent {
    Destiny.Entities.Vendors.DestinyVendorComponent data = 1;
    integer privacy = 2;
}

message SingleComponentResponseOfDestinyVendorReceiptsComponent {
    Destiny.Entities.Profiles.DestinyVendorReceiptsComponent data = 1;
    integer privacy = 2;
}

message Tags.Models.Contracts.TagResponse {
    Ignores.IgnoreResponse ignoreStatus = 1;
    string tagText = 2;
}

message Trending.TrendingCategories {
    repeated Trending.TrendingCategory categories = 1;
}

message Trending.TrendingCategory {
    string categoryId = 1;
    string categoryName = 2;
    SearchResultOfTrendingEntry entries = 3;
}

message Trending.TrendingDetail {
    Trending.TrendingEntryCommunityCreation creation = 1;
    Trending.TrendingEntryDestinyActivity destinyActivity = 2;
    Trending.TrendingEntryDestinyItem destinyItem = 3;
    Trending.TrendingEntryDestinyRitual destinyRitual = 4;
    integer entityType = 5;
    string identifier = 6;
    Trending.TrendingEntryNews news = 7;
    Trending.TrendingEntryCommunityStream stream = 8;
    Trending.TrendingEntrySupportArticle support = 9;
}

message Trending.TrendingEntry {
    // The localized "display name/article title/'primary localized identifier'" of the entity.
    string displayName = 1;
    string endDate = 2;
    // An enum - unfortunately - dictating all of the possible kinds of trending items that you might get in your result set, in case you want to do custom rendering or call to get the details of the item.
    message EntityType {
    }
    EntityType entityType = 3;
    // If isFeatured, this image will be populated with whatever the featured image is. Note that this will likely be a very large image, so don't use it all the time.
    string featureImage = 4;
    // We don't know whether the identifier will be a string, a uint, or a long... so we're going to cast it all to a string. But either way, we need any trending item created to have a single unique identifier for its type.
    string identifier = 5;
    string image = 6;
    bool isFeatured = 7;
    string link = 8;
    // If this is populated, the entry has a related MP4 video to show. I am 100% certain I am going to regret putting this directly on TrendingEntry, but it will work so yolo
    string mp4Video = 9;
    string startDate = 10;
    // If the entity has a localized tagline/subtitle/motto/whatever, that is found here.
    string tagline = 11;
    // If this is populated, the entry has a related WebM video to show. I am 100% certain I am going to regret putting this directly on TrendingEntry, but it will work so yolo
    string webmVideo = 12;
    // The weighted score of this trending item.
    double weight = 13;
}

message Trending.TrendingEntryCommunityCreation {
    string author = 1;
    int64 authorMembershipId = 2;
    string body = 3;
    string media = 4;
    uint64 postId = 5;
    string title = 6;
    int32 upvotes = 7;
}

message Trending.TrendingEntryCommunityStream {
    string image = 1;
    string partnershipIdentifier = 2;
    integer partnershipType = 3;
    string title = 4;
}

message Trending.TrendingEntryDestinyActivity {
    uint32 activityHash = 1;
    Destiny.Activities.DestinyPublicActivityStatus status = 2;
}

message Trending.TrendingEntryDestinyItem {
    uint32 itemHash = 1;
}

message Trending.TrendingEntryDestinyRitual {
    string dateEnd = 1;
    string dateStart = 2;
    // A destiny event will not necessarily have milestone "custom content", but if it does the details will be here.
    message EventContent {
    }
    EventContent eventContent = 3;
    string icon = 4;
    string image = 5;
    // A destiny event does not necessarily have a related Milestone, but if it does the details will be returned here.
    message MilestoneDetails {
    }
    MilestoneDetails milestoneDetails = 6;
    string subtitle = 7;
    string title = 8;
}

message Trending.TrendingEntryNews {
    Content.ContentItemPublicContract article = 1;
}

message Trending.TrendingEntrySupportArticle {
    Content.ContentItemPublicContract article = 1;
}

message User.AckState {
    // Identifier to use when acknowledging the related item. [category]:[entityId]:[targetId]
    string ackId = 1;
    // Indicates the related item has not been acknowledged.
    bool needsAck = 2;
}

message User.GeneralUser {
    string about = 1;
    string blizzardDisplayName = 2;
    User.UserToUserContext context = 3;
    string displayName = 4;
    string fbDisplayName = 5;
    string firstAccess = 6;
    bool isDeleted = 7;
    int64 lastBanReportId = 8;
    string lastUpdate = 9;
    int64 legacyPortalUID = 10;
    string locale = 11;
    bool localeInheritDefault = 12;
    int64 membershipId = 13;
    string normalizedName = 14;
    string profileBanExpire = 15;
    int32 profilePicture = 16;
    string profilePicturePath = 17;
    string profilePictureWidePath = 18;
    int32 profileTheme = 19;
    string profileThemeName = 20;
    string psnDisplayName = 21;
    bool showActivity = 22;
    bool showGroupMessaging = 23;
    string statusDate = 24;
    string statusText = 25;
    int64 successMessageFlags = 26;
    string uniqueName = 27;
    int32 userTitle = 28;
    string userTitleDisplay = 29;
    string xboxDisplayName = 30;
}

message User.Models.UserAlias {
    string cachePrefix = 1;
}

message User.UserInfoCard {
    // Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.
    string displayName = 1;
    // URL the Icon if available.
    string iconPath = 2;
    // Membership ID as they user is known in the Accounts service
    int64 membershipId = 3;
    // Type of the membership.
    message MembershipType {
    }
    MembershipType membershipType = 4;
    // A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.
    string supplementalDisplayName = 5;
}

message User.UserMembership {
    // Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.
    string displayName = 1;
    // Membership ID as they user is known in the Accounts service
    int64 membershipId = 2;
    // Type of the membership.
    message MembershipType {
    }
    MembershipType membershipType = 3;
}

message User.UserMembershipData {
    User.GeneralUser bungieNetUser = 1;
    // this allows you to see destiny memberships that are visible and linked to this account (regardless of whether or not they have characters on the world server)
    repeated User.UserInfoCard destinyMemberships = 2;
}

message User.UserToUserContext {
    string globalIgnoreEndDate = 1;
    Ignores.IgnoreResponse ignoreStatus = 2;
    bool isFollowing = 3;
}

service Bungie.NetService {
    // Returns community content.
    rpc GetCommunityContentGetSortMediaFilterPage(GetCommunityContentGetSortMediaFilterPageRequest) returns (GetCommunityContentGetSortMediaFilterPageResponse) {
      option (google.api.http) = {
        get: "/Platform/CommunityContent/Get/{sort}/{mediaFilter}/{page}/"
      };
    }
    // Returns info about community members who are live streaming.
    rpc GetCommunityContentLiveAllPartnershipTypeSortPage(GetCommunityContentLiveAllPartnershipTypeSortPageRequest) returns (GetCommunityContentLiveAllPartnershipTypeSortPageResponse) {
      option (google.api.http) = {
        get: "/Platform/CommunityContent/Live/All/{partnershipType}/{sort}/{page}/"
      };
    }
    // Returns info about community members who are live streaming in your clans.
    rpc GetCommunityContentLiveClanPartnershipTypeSortPage(GetCommunityContentLiveClanPartnershipTypeSortPageRequest) returns (GetCommunityContentLiveClanPartnershipTypeSortPageResponse) {
      option (google.api.http) = {
        get: "/Platform/CommunityContent/Live/Clan/{partnershipType}/{sort}/{page}/"
      };
    }
    // Returns info about Featured live streams.
    rpc GetCommunityContentLiveFeaturedPartnershipTypeSortPage(GetCommunityContentLiveFeaturedPartnershipTypeSortPageRequest) returns (GetCommunityContentLiveFeaturedPartnershipTypeSortPageResponse) {
      option (google.api.http) = {
        get: "/Platform/CommunityContent/Live/Featured/{partnershipType}/{sort}/{page}/"
      };
    }
    // Returns info about community members who are live streaming among your friends.
    rpc GetCommunityContentLiveFriendsPartnershipTypeSortPage(GetCommunityContentLiveFriendsPartnershipTypeSortPageRequest) returns (GetCommunityContentLiveFriendsPartnershipTypeSortPageResponse) {
      option (google.api.http) = {
        get: "/Platform/CommunityContent/Live/Friends/{partnershipType}/{sort}/{page}/"
      };
    }
    // Gets the Live Streaming status of a particular Account and Membership Type.
    rpc GetCommunityContentLiveUsersPartnershipTypeMembershipTypeMembershipId(GetCommunityContentLiveUsersPartnershipTypeMembershipTypeMembershipIdRequest) returns (GetCommunityContentLiveUsersPartnershipTypeMembershipTypeMembershipIdResponse) {
      option (google.api.http) = {
        get: "/Platform/CommunityContent/Live/Users/{partnershipType}/{membershipType}/{membershipId}/"
      };
    }
    // Activate a Talent Node. Chill out, everyone: we haven't decided yet whether this will be able to activate nodes with costs, but if we do it will require special scope permission for an application attempting to do so. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline. PREVIEW: This service is not actually implemented yet, but we are returning the planned schema of the endpoint for review, comment, and preparation for its eventual implementation.
    rpc PostDestiny2ActionsItemsActivateTalentNode(google.protobuf.Empty) returns (PostDestiny2ActionsItemsActivateTalentNodeResponse) {
      option (google.api.http) = {
        post: "/Platform/Destiny2/Actions/Items/ActivateTalentNode/"
      };
    }
    // Equip an item. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline.
    rpc PostDestiny2ActionsItemsEquipItem(google.protobuf.Empty) returns (PostDestiny2ActionsItemsEquipItemResponse) {
      option (google.api.http) = {
        post: "/Platform/Destiny2/Actions/Items/EquipItem/"
      };
    }
    // Equip a list of items by itemInstanceIds. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline. Any items not found on your character will be ignored.
    rpc PostDestiny2ActionsItemsEquipItems(google.protobuf.Empty) returns (PostDestiny2ActionsItemsEquipItemsResponse) {
      option (google.api.http) = {
        post: "/Platform/Destiny2/Actions/Items/EquipItems/"
      };
    }
    // Insert a plug into a socketed item. I know how it sounds, but I assure you it's much more G-rated than you might be guessing. We haven't decided yet whether this will be able to insert plugs that have side effects, but if we do it will require special scope permission for an application attempting to do so. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline. PREVIEW: This service is not yet active, but we are returning the planned schema of the endpoint for review, comment, and preparation for its eventual implementation.
    rpc PostDestiny2ActionsItemsInsertSocketPlug(google.protobuf.Empty) returns (PostDestiny2ActionsItemsInsertSocketPlugResponse) {
      option (google.api.http) = {
        post: "/Platform/Destiny2/Actions/Items/InsertSocketPlug/"
      };
    }
    // Set the Lock State for an instanced item. You must have a valid Destiny Account.
    rpc PostDestiny2ActionsItemsSetLockState(google.protobuf.Empty) returns (PostDestiny2ActionsItemsSetLockStateResponse) {
      option (google.api.http) = {
        post: "/Platform/Destiny2/Actions/Items/SetLockState/"
      };
    }
    // Transfer an item to/from your vault. You must have a valid Destiny account. You must also pass BOTH a reference AND an instance ID if it's an instanced item. itshappening.gif
    rpc PostDestiny2ActionsItemsTransferItem(google.protobuf.Empty) returns (PostDestiny2ActionsItemsTransferItemResponse) {
      option (google.api.http) = {
        post: "/Platform/Destiny2/Actions/Items/TransferItem/"
      };
    }
    // Gets a page list of Destiny items.
    rpc GetDestiny2ArmorySearchTypeSearchTerm(GetDestiny2ArmorySearchTypeSearchTermRequest) returns (GetDestiny2ArmorySearchTypeSearchTermResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Armory/Search/{type}/{searchTerm}/"
      };
    }
    // Returns information on the weekly clan rewards and if the clan has earned them or not. Note that this will always report rewards as not redeemed.
    rpc GetDestiny2ClanGroupIdWeeklyRewardState(GetDestiny2ClanGroupIdWeeklyRewardStateRequest) returns (GetDestiny2ClanGroupIdWeeklyRewardStateResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Clan/{groupId}/WeeklyRewardState/"
      };
    }
    // Returns the current version of the manifest as a json object.
    rpc GetDestiny2Manifest(google.protobuf.Empty) returns (GetDestiny2ManifestResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Manifest/"
      };
    }
    // Returns the static definition of an entity of the given Type and hash identifier. Examine the API Documentation for the Type Names of entities that have their own definitions. Note that the return type will always *inherit from* DestinyDefinition, but the specific type returned will be the requested entity type if it can be found. Please don't use this as a chatty alternative to the Manifest database if you require large sets of data, but for simple and one-off accesses this should be handy.
    rpc GetDestiny2ManifestEntityTypeHashIdentifier(GetDestiny2ManifestEntityTypeHashIdentifierRequest) returns (GetDestiny2ManifestEntityTypeHashIdentifierResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Manifest/{entityType}/{hashIdentifier}/"
      };
    }
    // Gets public information about currently available Milestones.
    rpc GetDestiny2Milestones(google.protobuf.Empty) returns (GetDestiny2MilestonesResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Milestones/"
      };
    }
    // Gets custom localized content for the milestone of the given hash, if it exists.
    rpc GetDestiny2MilestonesMilestoneHashContent(GetDestiny2MilestonesMilestoneHashContentRequest) returns (GetDestiny2MilestonesMilestoneHashContentResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Milestones/{milestoneHash}/Content/"
      };
    }
    // Returns a list of Destiny memberships given a full Gamertag or PSN ID.
    rpc GetDestiny2SearchDestinyPlayerMembershipTypeDisplayName(GetDestiny2SearchDestinyPlayerMembershipTypeDisplayNameRequest) returns (GetDestiny2SearchDestinyPlayerMembershipTypeDisplayNameResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/SearchDestinyPlayer/{membershipType}/{displayName}/"
      };
    }
    // Gets aggregated stats for a clan using the same categories as the clan leaderboards. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2StatsAggregateClanStatsGroupId(GetDestiny2StatsAggregateClanStatsGroupIdRequest) returns (GetDestiny2StatsAggregateClanStatsGroupIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Stats/AggregateClanStats/{groupId}/"
      };
    }
    // Gets historical stats definitions.
    rpc GetDestiny2StatsDefinition(google.protobuf.Empty) returns (GetDestiny2StatsDefinitionResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Stats/Definition/"
      };
    }
    // Gets leaderboards with the signed in user's friends and the supplied destinyMembershipId as the focus. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2StatsLeaderboardsClansGroupId(GetDestiny2StatsLeaderboardsClansGroupIdRequest) returns (GetDestiny2StatsLeaderboardsClansGroupIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Stats/Leaderboards/Clans/{groupId}/"
      };
    }
    // Gets leaderboards with the signed in user's friends and the supplied destinyMembershipId as the focus. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2StatsLeaderboardsMembershipTypeDestinyMembershipIdCharacterId(GetDestiny2StatsLeaderboardsMembershipTypeDestinyMembershipIdCharacterIdRequest) returns (GetDestiny2StatsLeaderboardsMembershipTypeDestinyMembershipIdCharacterIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/"
      };
    }
    // Gets the available post game carnage report for the activity ID.
    rpc GetDestiny2StatsPostGameCarnageReportActivityId(GetDestiny2StatsPostGameCarnageReportActivityIdRequest) returns (GetDestiny2StatsPostGameCarnageReportActivityIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/Stats/PostGameCarnageReport/{activityId}/"
      };
    }
    // Gets historical stats for indicated character. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStats(GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsRequest) returns (GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/"
      };
    }
    // Gets activity history stats for indicated character. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsActivities(GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsActivitiesRequest) returns (GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsActivitiesResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/"
      };
    }
    // Gets all activities the character has participated in together with aggregate statistics for those activities. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsAggregateActivityStats(GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsAggregateActivityStatsRequest) returns (GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsAggregateActivityStatsResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/"
      };
    }
    // Gets details about unique weapon usage, including all exotic weapons. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsUniqueWeapons(GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsUniqueWeaponsRequest) returns (GetDestiny2MembershipTypeAccountDestinyMembershipIdCharacterCharacterIdStatsUniqueWeaponsResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/"
      };
    }
    // Gets aggregate historical stats organized around each character for a given account. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.
    rpc GetDestiny2MembershipTypeAccountDestinyMembershipIdStats(GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsRequest) returns (GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/"
      };
    }
    // Gets leaderboards with the signed in user's friends and the supplied destinyMembershipId as the focus. PREVIEW: This endpoint has not yet been implemented. It is being returned for a preview of future functionality, and for public comment/suggestion/preparation.
    rpc GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsLeaderboards(GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsLeaderboardsRequest) returns (GetDestiny2MembershipTypeAccountDestinyMembershipIdStatsLeaderboardsResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/"
      };
    }
    // Returns Destiny Profile information for the supplied membership.
    rpc GetDestiny2MembershipTypeProfileDestinyMembershipId(GetDestiny2MembershipTypeProfileDestinyMembershipIdRequest) returns (GetDestiny2MembershipTypeProfileDestinyMembershipIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Profile/{destinyMembershipId}/"
      };
    }
    // Returns character information for the supplied character.
    rpc GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterId(GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdRequest) returns (GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/"
      };
    }
    // Get currently available vendors. PREVIEW: This service is not yet active, but we are returning the planned schema of the endpoint for review, comment, and preparation for its eventual implementation.
    rpc GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendors(GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsRequest) returns (GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/"
      };
    }
    // Get the details of a specific Vendor. PREVIEW: This service is not yet active, but we are returning the planned schema of the endpoint for review, comment, and preparation for its eventual implementation.
    rpc GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsVendorHash(GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsVendorHashRequest) returns (GetDestiny2MembershipTypeProfileDestinyMembershipIdCharacterCharacterIdVendorsVendorHashResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/"
      };
    }
    // Retrieve the details of an instanced Destiny Item. An instanced Destiny item is one with an ItemInstanceId. Non-instanced items, such as materials, have no useful instance-specific details and thus are not queryable here.
    rpc GetDestiny2MembershipTypeProfileDestinyMembershipIdItemItemInstanceId(GetDestiny2MembershipTypeProfileDestinyMembershipIdItemItemInstanceIdRequest) returns (GetDestiny2MembershipTypeProfileDestinyMembershipIdItemItemInstanceIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/"
      };
    }
    // Gets a listing of all topics marked as part of the core group.
    rpc GetForumGetCoreTopicsPagedPageSortQuickDateCategoryFilter(GetForumGetCoreTopicsPagedPageSortQuickDateCategoryFilterRequest) returns (GetForumGetCoreTopicsPagedPageSortQuickDateCategoryFilterResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetCoreTopicsPaged/{page}/{sort}/{quickDate}/{categoryFilter}/"
      };
    }
    // Gets tag suggestions based on partial text entry, matching them with other tags previously used in the forums.
    rpc GetForumGetForumTagSuggestions(GetForumGetForumTagSuggestionsRequest) returns (GetForumGetForumTagSuggestionsResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetForumTagSuggestions/"
      };
    }
    // Returns the post specified and its immediate parent.
    rpc GetForumGetPostAndParentChildPostId(GetForumGetPostAndParentChildPostIdRequest) returns (GetForumGetPostAndParentChildPostIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetPostAndParent/{childPostId}/"
      };
    }
    // Returns the post specified and its immediate parent of posts that are awaiting approval.
    rpc GetForumGetPostAndParentAwaitingApprovalChildPostId(GetForumGetPostAndParentAwaitingApprovalChildPostIdRequest) returns (GetForumGetPostAndParentAwaitingApprovalChildPostIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetPostAndParentAwaitingApproval/{childPostId}/"
      };
    }
    // Returns a thread of posts at the given parent, optionally returning replies to those posts as well as the original parent.
    rpc GetForumGetPostsThreadedPagedParentPostIdPagePageSizeReplySizeGetParentPostRootThreadModeSortMode(GetForumGetPostsThreadedPagedParentPostIdPagePageSizeReplySizeGetParentPostRootThreadModeSortModeRequest) returns (GetForumGetPostsThreadedPagedParentPostIdPagePageSizeReplySizeGetParentPostRootThreadModeSortModeResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetPostsThreadedPaged/{parentPostId}/{page}/{pageSize}/{replySize}/{getParentPost}/{rootThreadMode}/{sortMode}/"
      };
    }
    // Returns a thread of posts starting at the topicId of the input childPostId, optionally returning replies to those posts as well as the original parent.
    rpc GetForumGetPostsThreadedPagedFromChildChildPostIdPagePageSizeReplySizeRootThreadModeSortMode(GetForumGetPostsThreadedPagedFromChildChildPostIdPagePageSizeReplySizeRootThreadModeSortModeRequest) returns (GetForumGetPostsThreadedPagedFromChildChildPostIdPagePageSizeReplySizeRootThreadModeSortModeResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetPostsThreadedPagedFromChild/{childPostId}/{page}/{pageSize}/{replySize}/{rootThreadMode}/{sortMode}/"
      };
    }
    // Gets the post Id for the given content item's comments, if it exists.
    rpc GetForumGetTopicForContentContentId(GetForumGetTopicForContentContentIdRequest) returns (GetForumGetTopicForContentContentIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetTopicForContent/{contentId}/"
      };
    }
    // Get topics from any forum.
    rpc GetForumGetTopicsPagedPagePageSizeGroupSortQuickDateCategoryFilter(GetForumGetTopicsPagedPagePageSizeGroupSortQuickDateCategoryFilterRequest) returns (GetForumGetTopicsPagedPagePageSizeGroupSortQuickDateCategoryFilterResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/GetTopicsPaged/{page}/{pageSize}/{group}/{sort}/{quickDate}/{categoryFilter}/"
      };
    }
    // Gets the specified forum poll.
    rpc GetForumPollTopicId(GetForumPollTopicIdRequest) returns (GetForumPollTopicIdResponse) {
      option (google.api.http) = {
        get: "/Platform/Forum/Poll/{topicId}/"
      };
    }
    // Allows the owner of a fireteam thread to approve all joined members and start a private message conversation with them.
    rpc PostForumRecruitApproveTopicId(PostForumRecruitApproveTopicIdRequest) returns (PostForumRecruitApproveTopicIdResponse) {
      option (google.api.http) = {
        post: "/Platform/Forum/Recruit/Approve/{topicId}/"
      };
    }
    // Allows a user to slot themselves into a recruitment thread fireteam slot. Returns the new state of the fireteam.
    rpc PostForumRecruitJoinTopicId(PostForumRecruitJoinTopicIdRequest) returns (PostForumRecruitJoinTopicIdResponse) {
      option (google.api.http) = {
        post: "/Platform/Forum/Recruit/Join/{topicId}/"
      };
    }
    // Allows a recruitment thread owner to kick a join user from the fireteam. Returns the new state of the fireteam.
    rpc PostForumRecruitKickBanTopicIdTargetMembershipId(PostForumRecruitKickBanTopicIdTargetMembershipIdRequest) returns (PostForumRecruitKickBanTopicIdTargetMembershipIdResponse) {
      option (google.api.http) = {
        post: "/Platform/Forum/Recruit/KickBan/{topicId}/{targetMembershipId}/"
      };
    }
    // Allows a user to remove themselves from a recruitment thread fireteam slot. Returns the new state of the fireteam.
    rpc PostForumRecruitLeaveTopicId(PostForumRecruitLeaveTopicIdRequest) returns (PostForumRecruitLeaveTopicIdResponse) {
      option (google.api.http) = {
        post: "/Platform/Forum/Recruit/Leave/{topicId}/"
      };
    }
    // Allows the caller to get a list of to 25 recruitment thread summary information objects.
    rpc PostForumRecruitSummaries(google.protobuf.Empty) returns (PostForumRecruitSummariesResponse) {
      option (google.api.http) = {
        post: "/Platform/Forum/Recruit/Summaries/"
      };
    }
    // Create a new group.
    rpc PostGroupV2Create(google.protobuf.Empty) returns (PostGroupV2CreateResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/Create/"
      };
    }
    // Returns a list of all available group avatars for the signed-in user.
    rpc GetGroupV2GetAvailableAvatars(google.protobuf.Empty) returns (GetGroupV2GetAvailableAvatarsResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/GetAvailableAvatars/"
      };
    }
    // Returns a list of all available group themes.
    rpc GetGroupV2GetAvailableThemes(google.protobuf.Empty) returns (GetGroupV2GetAvailableThemesResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/GetAvailableThemes/"
      };
    }
    // Gets the state of the user's clan invite preferences for a particular membership type - true if they wish to be invited to clans, false otherwise.
    rpc GetGroupV2GetUserClanInviteSettingMType(GetGroupV2GetUserClanInviteSettingMTypeRequest) returns (GetGroupV2GetUserClanInviteSettingMTypeResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/GetUserClanInviteSetting/{mType}/"
      };
    }
    // Get information about a specific group with the given name and type.
    rpc GetGroupV2NameGroupNameGroupType(GetGroupV2NameGroupNameGroupTypeRequest) returns (GetGroupV2NameGroupNameGroupTypeResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/Name/{groupName}/{groupType}/"
      };
    }
    // Gets groups recommended for you based on the groups to whom those you follow belong.
    rpc PostGroupV2Recommended(google.protobuf.Empty) returns (PostGroupV2RecommendedResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/Recommended/"
      };
    }
    // Search for Groups.
    rpc PostGroupV2Search(google.protobuf.Empty) returns (PostGroupV2SearchResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/Search/"
      };
    }
    // Sets the state of the user's clan invite preferences - true if they wish to be invited to clans, false otherwise.
    rpc PostGroupV2SetUserClanInviteSettingMTypeAllowInvites(PostGroupV2SetUserClanInviteSettingMTypeAllowInvitesRequest) returns (PostGroupV2SetUserClanInviteSettingMTypeAllowInvitesResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/SetUserClanInviteSetting/{mType}/{allowInvites}/"
      };
    }
    // Get information about the groups that a given member has applied to or been invited to.
    rpc GetGroupV2UserPotentialMembershipTypeMembershipIdFilterGroupType(GetGroupV2UserPotentialMembershipTypeMembershipIdFilterGroupTypeRequest) returns (GetGroupV2UserPotentialMembershipTypeMembershipIdFilterGroupTypeResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/User/Potential/{membershipType}/{membershipId}/{filter}/{groupType}/"
      };
    }
    // Get information about the groups that a given member has joined.
    rpc GetGroupV2UserMembershipTypeMembershipIdFilterGroupType(GetGroupV2UserMembershipTypeMembershipIdFilterGroupTypeRequest) returns (GetGroupV2UserMembershipTypeMembershipIdFilterGroupTypeResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/User/{membershipType}/{membershipId}/{filter}/{groupType}/"
      };
    }
    // Get information about a specific group of the given ID.
    rpc GetGroupV2GroupId(GetGroupV2GroupIdRequest) returns (GetGroupV2GroupIdResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/"
      };
    }
    // An administrative method to allow the founder of a group or clan to give up their position to another admin permanently.
    rpc PostGroupV2GroupIdAdminAbdicateFoundershipMembershipTypeFounderIdNew(PostGroupV2GroupIdAdminAbdicateFoundershipMembershipTypeFounderIdNewRequest) returns (PostGroupV2GroupIdAdminAbdicateFoundershipMembershipTypeFounderIdNewResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Admin/AbdicateFoundership/{membershipType}/{founderIdNew}/"
      };
    }
    // Get the list of members in a given group who are of admin level or higher.
    rpc GetGroupV2GroupIdAdminsAndFounder(GetGroupV2GroupIdAdminsAndFounderRequest) returns (GetGroupV2GroupIdAdminsAndFounderResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/AdminsAndFounder/"
      };
    }
    // Get the list of banned members in a given group. Only accessible to group Admins and above. Not applicable to all groups. Check group features.
    rpc GetGroupV2GroupIdBanned(GetGroupV2GroupIdBannedRequest) returns (GetGroupV2GroupIdBannedResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/Banned/"
      };
    }
    // Edit an existing group. You must have suitable permissions in the group to perform this operation. This latest revision will only edit the fields you pass in - pass null for properties you want to leave unaltered.
    rpc PostGroupV2GroupIdEdit(PostGroupV2GroupIdEditRequest) returns (PostGroupV2GroupIdEditResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Edit/"
      };
    }
    // Edit an existing group's clan banner. You must have suitable permissions in the group to perform this operation. All fields are required.
    rpc PostGroupV2GroupIdEditClanBanner(PostGroupV2GroupIdEditClanBannerRequest) returns (PostGroupV2GroupIdEditClanBannerResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/EditClanBanner/"
      };
    }
    // Edit group options only available to a founder. You must have suitable permissions in the group to perform this operation.
    rpc PostGroupV2GroupIdEditFounderOptions(PostGroupV2GroupIdEditFounderOptionsRequest) returns (PostGroupV2GroupIdEditFounderOptionsResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/EditFounderOptions/"
      };
    }
    // Get the list of members in a given group.
    rpc GetGroupV2GroupIdMembers(GetGroupV2GroupIdMembersRequest) returns (GetGroupV2GroupIdMembersResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/Members/"
      };
    }
    // Request permission to join the given group.
    rpc PostGroupV2GroupIdMembersApplyMembershipType(PostGroupV2GroupIdMembersApplyMembershipTypeRequest) returns (PostGroupV2GroupIdMembersApplyMembershipTypeResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/Apply/{membershipType}/"
      };
    }
    // Approve all of the pending users for the given group.
    rpc PostGroupV2GroupIdMembersApproveAll(PostGroupV2GroupIdMembersApproveAllRequest) returns (PostGroupV2GroupIdMembersApproveAllResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/ApproveAll/"
      };
    }
    // Approve all of the pending users for the given group.
    rpc PostGroupV2GroupIdMembersApproveList(PostGroupV2GroupIdMembersApproveListRequest) returns (PostGroupV2GroupIdMembersApproveListResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/ApproveList/"
      };
    }
    // Deny all of the pending users for the given group.
    rpc PostGroupV2GroupIdMembersDenyAll(PostGroupV2GroupIdMembersDenyAllRequest) returns (PostGroupV2GroupIdMembersDenyAllResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/DenyAll/"
      };
    }
    // Deny all of the pending users for the given group that match the passed-in .
    rpc PostGroupV2GroupIdMembersDenyList(PostGroupV2GroupIdMembersDenyListRequest) returns (PostGroupV2GroupIdMembersDenyListResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/DenyList/"
      };
    }
    // Invite a user to join this group.
    rpc PostGroupV2GroupIdMembersIndividualInviteMembershipTypeMembershipId(PostGroupV2GroupIdMembersIndividualInviteMembershipTypeMembershipIdRequest) returns (PostGroupV2GroupIdMembersIndividualInviteMembershipTypeMembershipIdResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/IndividualInvite/{membershipType}/{membershipId}/"
      };
    }
    // Cancels a pending invitation to join a group.
    rpc PostGroupV2GroupIdMembersIndividualInviteCancelMembershipTypeMembershipId(PostGroupV2GroupIdMembersIndividualInviteCancelMembershipTypeMembershipIdRequest) returns (PostGroupV2GroupIdMembersIndividualInviteCancelMembershipTypeMembershipIdResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/IndividualInviteCancel/{membershipType}/{membershipId}/"
      };
    }
    // Get the list of users who have been invited into the group.
    rpc GetGroupV2GroupIdMembersInvitedIndividuals(GetGroupV2GroupIdMembersInvitedIndividualsRequest) returns (GetGroupV2GroupIdMembersInvitedIndividualsResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/Members/InvitedIndividuals/"
      };
    }
    // Get the list of users who are awaiting a decision on their application to join a given group. Modified to include application info.
    rpc GetGroupV2GroupIdMembersPending(GetGroupV2GroupIdMembersPendingRequest) returns (GetGroupV2GroupIdMembersPendingResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/Members/Pending/"
      };
    }
    // Rescind your application to join the given group or leave the group if you are already a member..
    rpc PostGroupV2GroupIdMembersRescindMembershipType(PostGroupV2GroupIdMembersRescindMembershipTypeRequest) returns (PostGroupV2GroupIdMembersRescindMembershipTypeResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/Rescind/{membershipType}/"
      };
    }
    // Bans the requested member from the requested group for the specified period of time.
    rpc PostGroupV2GroupIdMembersMembershipTypeMembershipIdBan(PostGroupV2GroupIdMembersMembershipTypeMembershipIdBanRequest) returns (PostGroupV2GroupIdMembersMembershipTypeMembershipIdBanResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Ban/"
      };
    }
    // Kick a member from the given group, forcing them to reapply if they wish to re-join the group. You must have suitable permissions in the group to perform this operation.
    rpc PostGroupV2GroupIdMembersMembershipTypeMembershipIdKick(PostGroupV2GroupIdMembersMembershipTypeMembershipIdKickRequest) returns (PostGroupV2GroupIdMembersMembershipTypeMembershipIdKickResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Kick/"
      };
    }
    // Edit the membership type of a given member. You must have suitable permissions in the group to perform this operation.
    rpc PostGroupV2GroupIdMembersMembershipTypeMembershipIdSetMembershipTypeMemberType(PostGroupV2GroupIdMembersMembershipTypeMembershipIdSetMembershipTypeMemberTypeRequest) returns (PostGroupV2GroupIdMembersMembershipTypeMembershipIdSetMembershipTypeMemberTypeResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/SetMembershipType/{memberType}/"
      };
    }
    // Unbans the requested member, allowing them to re-apply for membership.
    rpc PostGroupV2GroupIdMembersMembershipTypeMembershipIdUnban(PostGroupV2GroupIdMembersMembershipTypeMembershipIdUnbanRequest) returns (PostGroupV2GroupIdMembersMembershipTypeMembershipIdUnbanResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Unban/"
      };
    }
    // Gets a list of available optional conversation channels and their settings.
    rpc GetGroupV2GroupIdOptionalConversations(GetGroupV2GroupIdOptionalConversationsRequest) returns (GetGroupV2GroupIdOptionalConversationsResponse) {
      option (google.api.http) = {
        get: "/Platform/GroupV2/{groupId}/OptionalConversations/"
      };
    }
    // Add a new optional conversation/chat channel. Requires admin permissions to the group.
    rpc PostGroupV2GroupIdOptionalConversationsAdd(PostGroupV2GroupIdOptionalConversationsAddRequest) returns (PostGroupV2GroupIdOptionalConversationsAddResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/OptionalConversations/Add/"
      };
    }
    // Edit the settings of an optional conversation/chat channel. Requires admin permissions to the group.
    rpc PostGroupV2GroupIdOptionalConversationsEditConversationId(PostGroupV2GroupIdOptionalConversationsEditConversationIdRequest) returns (PostGroupV2GroupIdOptionalConversationsEditConversationIdResponse) {
      option (google.api.http) = {
        post: "/Platform/GroupV2/{groupId}/OptionalConversations/Edit/{conversationId}/"
      };
    }
    // Returns trending items for Bungie.net, collapsed into the first page of items per category. For pagination within a category, call GetTrendingCategory.
    rpc GetTrendingCategories(google.protobuf.Empty) returns (GetTrendingCategoriesResponse) {
      option (google.api.http) = {
        get: "/Platform/Trending/Categories/"
      };
    }
    // Returns paginated lists of trending items for a category.
    rpc GetTrendingCategoriesCategoryIdPageNumber(GetTrendingCategoriesCategoryIdPageNumberRequest) returns (GetTrendingCategoriesCategoryIdPageNumberResponse) {
      option (google.api.http) = {
        get: "/Platform/Trending/Categories/{categoryId}/{pageNumber}/"
      };
    }
    // Returns the detailed results for a specific trending entry. Note that trending entries are uniquely identified by a combination of *both* the TrendingEntryType *and* the identifier: the identifier alone is not guaranteed to be globally unique.
    rpc GetTrendingDetailsTrendingEntryTypeIdentifier(GetTrendingDetailsTrendingEntryTypeIdentifierRequest) returns (GetTrendingDetailsTrendingEntryTypeIdentifierResponse) {
      option (google.api.http) = {
        get: "/Platform/Trending/Details/{trendingEntryType}/{identifier}/"
      };
    }
    // Returns a list of all available user themes.
    rpc GetUserGetAvailableThemes(google.protobuf.Empty) returns (GetUserGetAvailableThemesResponse) {
      option (google.api.http) = {
        get: "/Platform/User/GetAvailableThemes/"
      };
    }
    // Loads a bungienet user by membership id.
    rpc GetUserGetBungieNetUserByIdId(GetUserGetBungieNetUserByIdIdRequest) returns (GetUserGetBungieNetUserByIdIdResponse) {
      option (google.api.http) = {
        get: "/Platform/User/GetBungieNetUserById/{id}/"
      };
    }
    // Returns a list of accounts associated with the supplied membership ID and membership type. This will include all linked accounts (even when hidden) if supplied credentials permit it.
    rpc GetUserGetMembershipsByIdMembershipIdMembershipType(GetUserGetMembershipsByIdMembershipIdMembershipTypeRequest) returns (GetUserGetMembershipsByIdMembershipIdMembershipTypeResponse) {
      option (google.api.http) = {
        get: "/Platform/User/GetMembershipsById/{membershipId}/{membershipType}/"
      };
    }
    // Returns a list of accounts associated with signed in user. This is useful for OAuth implementations that do not give you access to the token response.
    rpc GetUserGetMembershipsForCurrentUser(google.protobuf.Empty) returns (GetUserGetMembershipsForCurrentUserResponse) {
      option (google.api.http) = {
        get: "/Platform/User/GetMembershipsForCurrentUser/"
      };
    }
    // Loads aliases of a bungienet membership id.
    rpc GetUserGetUserAliasesId(GetUserGetUserAliasesIdRequest) returns (GetUserGetUserAliasesIdResponse) {
      option (google.api.http) = {
        get: "/Platform/User/GetUserAliases/{id}/"
      };
    }
    // Returns a list of possible users based on the search string
    rpc GetUserSearchUsers(GetUserSearchUsersRequest) returns (GetUserSearchUsersResponse) {
      option (google.api.http) = {
        get: "/Platform/User/SearchUsers/"
      };
    }
    // Returns a user's linked Partnerships.
    rpc GetUserMembershipIdPartnerships(GetUserMembershipIdPartnershipsRequest) returns (GetUserMembershipIdPartnershipsResponse) {
      option (google.api.http) = {
        get: "/Platform/User/{membershipId}/Partnerships/"
      };
    }
}
