syntax = "proto3";

import "google/protobuf/empty.proto";

import "google/api/annotations.proto";

package stackexchange;

message GetAccessTokensAccessTokensRequest {
    // String list (semicolon delimited).
    string accessTokens = 1;
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 2;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 3;
    int32 page = 4;
    int32 pagesize = 5;
}

message GetAccessTokensAccessTokensInvalidateRequest {
    // String list (semicolon delimited).
    string accessTokens = 1;
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 2;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 3;
    int32 page = 4;
    int32 pagesize = 5;
}

message GetAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetAnswersRequest_Order {
        GETANSWERSREQUEST_ORDER_DESC = 0;
        GETANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetAnswersRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetAnswersRequest_Sort {
        GETANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETANSWERSREQUEST_SORT_CREATION = 1;
        GETANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetAnswersRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetAnswersIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetAnswersIdsRequest_Order {
        GETANSWERSIDSREQUEST_ORDER_DESC = 0;
        GETANSWERSIDSREQUEST_ORDER_ASC = 1;
    }
    GetAnswersIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetAnswersIdsRequest_Sort {
        GETANSWERSIDSREQUEST_SORT_ACTIVITY = 0;
        GETANSWERSIDSREQUEST_SORT_CREATION = 1;
        GETANSWERSIDSREQUEST_SORT_VOTES = 2;
    }
    GetAnswersIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetAnswersIdsCommentsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetAnswersIdsCommentsRequest_Order {
        GETANSWERSIDSCOMMENTSREQUEST_ORDER_DESC = 0;
        GETANSWERSIDSCOMMENTSREQUEST_ORDER_ASC = 1;
    }
    GetAnswersIdsCommentsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetAnswersIdsCommentsRequest_Sort {
        GETANSWERSIDSCOMMENTSREQUEST_SORT_CREATION = 0;
        GETANSWERSIDSCOMMENTSREQUEST_SORT_VOTES = 1;
    }
    GetAnswersIdsCommentsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetAppsAccessTokensDeAuthenticateRequest {
    // String list (semicolon delimited).
    string accessTokens = 1;
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 2;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 3;
    int32 page = 4;
    int32 pagesize = 5;
}

message GetBadgesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    string max = 5;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    string min = 6;
    enum GetBadgesRequest_Order {
        GETBADGESREQUEST_ORDER_DESC = 0;
        GETBADGESREQUEST_ORDER_ASC = 1;
    }
    GetBadgesRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetBadgesRequest_Sort {
        GETBADGESREQUEST_SORT_RANK = 0;
        GETBADGESREQUEST_SORT_NAME = 1;
        GETBADGESREQUEST_SORT_TYPE = 2;
    }
    GetBadgesRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetBadgesNameRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = rank => string
    // sort = name => string
    string max = 5;
    // sort = rank => string
    // sort = name => string
    string min = 6;
    enum GetBadgesNameRequest_Order {
        GETBADGESNAMEREQUEST_ORDER_DESC = 0;
        GETBADGESNAMEREQUEST_ORDER_ASC = 1;
    }
    GetBadgesNameRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetBadgesNameRequest_Sort {
        GETBADGESNAMEREQUEST_SORT_RANK = 0;
        GETBADGESNAMEREQUEST_SORT_NAME = 1;
    }
    GetBadgesNameRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetBadgesRecipientsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
    // Unix date.
    int32 todate = 7;
}

message GetBadgesTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = rank => string
    // sort = name => string
    string max = 5;
    // sort = rank => string
    // sort = name => string
    string min = 6;
    enum GetBadgesTagsRequest_Order {
        GETBADGESTAGSREQUEST_ORDER_DESC = 0;
        GETBADGESTAGSREQUEST_ORDER_ASC = 1;
    }
    GetBadgesTagsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetBadgesTagsRequest_Sort {
        GETBADGESTAGSREQUEST_SORT_RANK = 0;
        GETBADGESTAGSREQUEST_SORT_NAME = 1;
    }
    GetBadgesTagsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetBadgesIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    string max = 5;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    string min = 6;
    enum GetBadgesIdsRequest_Order {
        GETBADGESIDSREQUEST_ORDER_DESC = 0;
        GETBADGESIDSREQUEST_ORDER_ASC = 1;
    }
    GetBadgesIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetBadgesIdsRequest_Sort {
        GETBADGESIDSREQUEST_SORT_RANK = 0;
        GETBADGESIDSREQUEST_SORT_NAME = 1;
        GETBADGESIDSREQUEST_SORT_TYPE = 2;
    }
    GetBadgesIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetBadgesIdsRecipientsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    int32 page = 5;
    int32 pagesize = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
    // Unix date.
    int32 todate = 8;
}

message GetCommentsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetCommentsRequest_Order {
        GETCOMMENTSREQUEST_ORDER_DESC = 0;
        GETCOMMENTSREQUEST_ORDER_ASC = 1;
    }
    GetCommentsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetCommentsRequest_Sort {
        GETCOMMENTSREQUEST_SORT_CREATION = 0;
        GETCOMMENTSREQUEST_SORT_VOTES = 1;
    }
    GetCommentsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetCommentsIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetCommentsIdsRequest_Order {
        GETCOMMENTSIDSREQUEST_ORDER_DESC = 0;
        GETCOMMENTSIDSREQUEST_ORDER_ASC = 1;
    }
    GetCommentsIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetCommentsIdsRequest_Sort {
        GETCOMMENTSIDSREQUEST_SORT_CREATION = 0;
        GETCOMMENTSIDSREQUEST_SORT_VOTES = 1;
    }
    GetCommentsIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message PostCommentsIdDeleteRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    bool preview = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message PostCommentsIdEditRequest {
    string body = 1;
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 2;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 3;
    int32 id = 4;
    bool preview = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetErrorsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetErrorsIdRequest {
    int32 id = 1;
}

message GetEventsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Unix date.
    int32 since = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetFiltersCreateRequest {
    string base = 1;
    // String list (semicolon delimited).
    string exclude = 2;
    // String list (semicolon delimited).
    string include = 3;
    bool unsafe = 4;
}

message GetFiltersFiltersRequest {
    // String list (semicolon delimited).
    string filters = 1;
}

message GetInboxRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetInboxUnreadRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Unix date.
    int32 since = 5;
}

message GetInfoRequest {
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 1;
}

message GetMeRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string max = 4;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string min = 5;
    enum GetMeRequest_Order {
        GETMEREQUEST_ORDER_DESC = 0;
        GETMEREQUEST_ORDER_ASC = 1;
    }
    GetMeRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeRequest_Sort {
        GETMEREQUEST_SORT_REPUTATION = 0;
        GETMEREQUEST_SORT_CREATION = 1;
        GETMEREQUEST_SORT_NAME = 2;
        GETMEREQUEST_SORT_MODIFIED = 3;
    }
    GetMeRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeAnswersRequest_Order {
        GETMEANSWERSREQUEST_ORDER_DESC = 0;
        GETMEANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetMeAnswersRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeAnswersRequest_Sort {
        GETMEANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETMEANSWERSREQUEST_SORT_CREATION = 1;
        GETMEANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetMeAnswersRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeAssociatedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetMeBadgesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    string max = 4;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    string min = 5;
    enum GetMeBadgesRequest_Order {
        GETMEBADGESREQUEST_ORDER_DESC = 0;
        GETMEBADGESREQUEST_ORDER_ASC = 1;
    }
    GetMeBadgesRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeBadgesRequest_Sort {
        GETMEBADGESREQUEST_SORT_RANK = 0;
        GETMEBADGESREQUEST_SORT_NAME = 1;
        GETMEBADGESREQUEST_SORT_TYPE = 2;
    }
    GetMeBadgesRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeCommentsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeCommentsRequest_Order {
        GETMECOMMENTSREQUEST_ORDER_DESC = 0;
        GETMECOMMENTSREQUEST_ORDER_ASC = 1;
    }
    GetMeCommentsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeCommentsRequest_Sort {
        GETMECOMMENTSREQUEST_SORT_CREATION = 0;
        GETMECOMMENTSREQUEST_SORT_VOTES = 1;
    }
    GetMeCommentsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeCommentsToIdRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeCommentsToIdRequest_Order {
        GETMECOMMENTSTOIDREQUEST_ORDER_DESC = 0;
        GETMECOMMENTSTOIDREQUEST_ORDER_ASC = 1;
    }
    GetMeCommentsToIdRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeCommentsToIdRequest_Sort {
        GETMECOMMENTSTOIDREQUEST_SORT_CREATION = 0;
        GETMECOMMENTSTOIDREQUEST_SORT_VOTES = 1;
    }
    GetMeCommentsToIdRequest_Sort sort = 10;
    int32 toId = 11;
    // Unix date.
    int32 todate = 12;
}

message GetMeFavoritesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = added => date
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = added => date
    string min = 5;
    enum GetMeFavoritesRequest_Order {
        GETMEFAVORITESREQUEST_ORDER_DESC = 0;
        GETMEFAVORITESREQUEST_ORDER_ASC = 1;
    }
    GetMeFavoritesRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeFavoritesRequest_Sort {
        GETMEFAVORITESREQUEST_SORT_ACTIVITY = 0;
        GETMEFAVORITESREQUEST_SORT_CREATION = 1;
        GETMEFAVORITESREQUEST_SORT_VOTES = 2;
        GETMEFAVORITESREQUEST_SORT_ADDED = 3;
    }
    GetMeFavoritesRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeInboxRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeInboxUnreadRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Unix date.
    int32 since = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetMeMentionedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeMentionedRequest_Order {
        GETMEMENTIONEDREQUEST_ORDER_DESC = 0;
        GETMEMENTIONEDREQUEST_ORDER_ASC = 1;
    }
    GetMeMentionedRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeMentionedRequest_Sort {
        GETMEMENTIONEDREQUEST_SORT_CREATION = 0;
        GETMEMENTIONEDREQUEST_SORT_VOTES = 1;
    }
    GetMeMentionedRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeMergesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetMeNotificationsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeNotificationsUnreadRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMePrivilegesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeQuestionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeQuestionsRequest_Order {
        GETMEQUESTIONSREQUEST_ORDER_DESC = 0;
        GETMEQUESTIONSREQUEST_ORDER_ASC = 1;
    }
    GetMeQuestionsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeQuestionsRequest_Sort {
        GETMEQUESTIONSREQUEST_SORT_ACTIVITY = 0;
        GETMEQUESTIONSREQUEST_SORT_CREATION = 1;
        GETMEQUESTIONSREQUEST_SORT_VOTES = 2;
    }
    GetMeQuestionsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeQuestionsFeaturedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeQuestionsFeaturedRequest_Order {
        GETMEQUESTIONSFEATUREDREQUEST_ORDER_DESC = 0;
        GETMEQUESTIONSFEATUREDREQUEST_ORDER_ASC = 1;
    }
    GetMeQuestionsFeaturedRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeQuestionsFeaturedRequest_Sort {
        GETMEQUESTIONSFEATUREDREQUEST_SORT_ACTIVITY = 0;
        GETMEQUESTIONSFEATUREDREQUEST_SORT_CREATION = 1;
        GETMEQUESTIONSFEATUREDREQUEST_SORT_VOTES = 2;
    }
    GetMeQuestionsFeaturedRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeQuestionsNoAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeQuestionsNoAnswersRequest_Order {
        GETMEQUESTIONSNOANSWERSREQUEST_ORDER_DESC = 0;
        GETMEQUESTIONSNOANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetMeQuestionsNoAnswersRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeQuestionsNoAnswersRequest_Sort {
        GETMEQUESTIONSNOANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETMEQUESTIONSNOANSWERSREQUEST_SORT_CREATION = 1;
        GETMEQUESTIONSNOANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetMeQuestionsNoAnswersRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeQuestionsUnacceptedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeQuestionsUnacceptedRequest_Order {
        GETMEQUESTIONSUNACCEPTEDREQUEST_ORDER_DESC = 0;
        GETMEQUESTIONSUNACCEPTEDREQUEST_ORDER_ASC = 1;
    }
    GetMeQuestionsUnacceptedRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeQuestionsUnacceptedRequest_Sort {
        GETMEQUESTIONSUNACCEPTEDREQUEST_SORT_ACTIVITY = 0;
        GETMEQUESTIONSUNACCEPTEDREQUEST_SORT_CREATION = 1;
        GETMEQUESTIONSUNACCEPTEDREQUEST_SORT_VOTES = 2;
    }
    GetMeQuestionsUnacceptedRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeQuestionsUnansweredRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeQuestionsUnansweredRequest_Order {
        GETMEQUESTIONSUNANSWEREDREQUEST_ORDER_DESC = 0;
        GETMEQUESTIONSUNANSWEREDREQUEST_ORDER_ASC = 1;
    }
    GetMeQuestionsUnansweredRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeQuestionsUnansweredRequest_Sort {
        GETMEQUESTIONSUNANSWEREDREQUEST_SORT_ACTIVITY = 0;
        GETMEQUESTIONSUNANSWEREDREQUEST_SORT_CREATION = 1;
        GETMEQUESTIONSUNANSWEREDREQUEST_SORT_VOTES = 2;
    }
    GetMeQuestionsUnansweredRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeReputationRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 3;
}

message GetMeReputationHistoryRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeReputationHistoryFullRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeSuggestedEditsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string max = 4;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string min = 5;
    enum GetMeSuggestedEditsRequest_Order {
        GETMESUGGESTEDEDITSREQUEST_ORDER_DESC = 0;
        GETMESUGGESTEDEDITSREQUEST_ORDER_ASC = 1;
    }
    GetMeSuggestedEditsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeSuggestedEditsRequest_Sort {
        GETMESUGGESTEDEDITSREQUEST_SORT_CREATION = 0;
        GETMESUGGESTEDEDITSREQUEST_SORT_APPROVAL = 1;
        GETMESUGGESTEDEDITSREQUEST_SORT_REJECTION = 2;
    }
    GetMeSuggestedEditsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string max = 4;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string min = 5;
    enum GetMeTagsRequest_Order {
        GETMETAGSREQUEST_ORDER_DESC = 0;
        GETMETAGSREQUEST_ORDER_ASC = 1;
    }
    GetMeTagsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeTagsRequest_Sort {
        GETMETAGSREQUEST_SORT_POPULAR = 0;
        GETMETAGSREQUEST_SORT_ACTIVITY = 1;
        GETMETAGSREQUEST_SORT_NAME = 2;
    }
    GetMeTagsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetMeTagsTagsTopAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetMeTagsTagsTopAnswersRequest_Order {
        GETMETAGSTAGSTOPANSWERSREQUEST_ORDER_DESC = 0;
        GETMETAGSTAGSTOPANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetMeTagsTagsTopAnswersRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeTagsTagsTopAnswersRequest_Sort {
        GETMETAGSTAGSTOPANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETMETAGSTAGSTOPANSWERSREQUEST_SORT_CREATION = 1;
        GETMETAGSTAGSTOPANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetMeTagsTagsTopAnswersRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tags = 11;
    // Unix date.
    int32 todate = 12;
}

message GetMeTagsTagsTopQuestionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = hot => none
    // sort = week => none
    // sort = month => none
    // sort = relevance => none
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = hot => none
    // sort = week => none
    // sort = month => none
    // sort = relevance => none
    string min = 5;
    enum GetMeTagsTagsTopQuestionsRequest_Order {
        GETMETAGSTAGSTOPQUESTIONSREQUEST_ORDER_DESC = 0;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_ORDER_ASC = 1;
    }
    GetMeTagsTagsTopQuestionsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetMeTagsTagsTopQuestionsRequest_Sort {
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_ACTIVITY = 0;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_CREATION = 1;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_VOTES = 2;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_HOT = 3;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_WEEK = 4;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_MONTH = 5;
        GETMETAGSTAGSTOPQUESTIONSREQUEST_SORT_RELEVANCE = 6;
    }
    GetMeTagsTagsTopQuestionsRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tags = 11;
    // Unix date.
    int32 todate = 12;
}

message GetMeTimelineRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
    // Unix date.
    int32 todate = 7;
}

message GetMeTopAnswerTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeTopQuestionTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetMeWritePermissionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetNotificationsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetNotificationsUnreadRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetPostsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetPostsRequest_Order {
        GETPOSTSREQUEST_ORDER_DESC = 0;
        GETPOSTSREQUEST_ORDER_ASC = 1;
    }
    GetPostsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetPostsRequest_Sort {
        GETPOSTSREQUEST_SORT_ACTIVITY = 0;
        GETPOSTSREQUEST_SORT_CREATION = 1;
        GETPOSTSREQUEST_SORT_VOTES = 2;
    }
    GetPostsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetPostsIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetPostsIdsRequest_Order {
        GETPOSTSIDSREQUEST_ORDER_DESC = 0;
        GETPOSTSIDSREQUEST_ORDER_ASC = 1;
    }
    GetPostsIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetPostsIdsRequest_Sort {
        GETPOSTSIDSREQUEST_SORT_ACTIVITY = 0;
        GETPOSTSIDSREQUEST_SORT_CREATION = 1;
        GETPOSTSIDSREQUEST_SORT_VOTES = 2;
    }
    GetPostsIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetPostsIdsCommentsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetPostsIdsCommentsRequest_Order {
        GETPOSTSIDSCOMMENTSREQUEST_ORDER_DESC = 0;
        GETPOSTSIDSCOMMENTSREQUEST_ORDER_ASC = 1;
    }
    GetPostsIdsCommentsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetPostsIdsCommentsRequest_Sort {
        GETPOSTSIDSCOMMENTSREQUEST_SORT_CREATION = 0;
        GETPOSTSIDSCOMMENTSREQUEST_SORT_VOTES = 1;
    }
    GetPostsIdsCommentsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetPostsIdsRevisionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    int32 page = 5;
    int32 pagesize = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
    // Unix date.
    int32 todate = 8;
}

message GetPostsIdsSuggestedEditsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string max = 5;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string min = 6;
    enum GetPostsIdsSuggestedEditsRequest_Order {
        GETPOSTSIDSSUGGESTEDEDITSREQUEST_ORDER_DESC = 0;
        GETPOSTSIDSSUGGESTEDEDITSREQUEST_ORDER_ASC = 1;
    }
    GetPostsIdsSuggestedEditsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetPostsIdsSuggestedEditsRequest_Sort {
        GETPOSTSIDSSUGGESTEDEDITSREQUEST_SORT_CREATION = 0;
        GETPOSTSIDSSUGGESTEDEDITSREQUEST_SORT_APPROVAL = 1;
        GETPOSTSIDSSUGGESTEDEDITSREQUEST_SORT_REJECTION = 2;
    }
    GetPostsIdsSuggestedEditsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message PostPostsIdCommentsAddRequest {
    string body = 1;
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 2;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 3;
    int32 id = 4;
    bool preview = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetPrivilegesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
}

message GetQuestionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = hot => none
    // sort = week => none
    // sort = month => none
    // sort = relevance => none
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = hot => none
    // sort = week => none
    // sort = month => none
    // sort = relevance => none
    string min = 5;
    enum GetQuestionsRequest_Order {
        GETQUESTIONSREQUEST_ORDER_DESC = 0;
        GETQUESTIONSREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetQuestionsRequest_Sort {
        GETQUESTIONSREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSREQUEST_SORT_CREATION = 1;
        GETQUESTIONSREQUEST_SORT_VOTES = 2;
        GETQUESTIONSREQUEST_SORT_HOT = 3;
        GETQUESTIONSREQUEST_SORT_WEEK = 4;
        GETQUESTIONSREQUEST_SORT_MONTH = 5;
        GETQUESTIONSREQUEST_SORT_RELEVANCE = 6;
    }
    GetQuestionsRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tagged = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsFeaturedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetQuestionsFeaturedRequest_Order {
        GETQUESTIONSFEATUREDREQUEST_ORDER_DESC = 0;
        GETQUESTIONSFEATUREDREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsFeaturedRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetQuestionsFeaturedRequest_Sort {
        GETQUESTIONSFEATUREDREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSFEATUREDREQUEST_SORT_CREATION = 1;
        GETQUESTIONSFEATUREDREQUEST_SORT_VOTES = 2;
    }
    GetQuestionsFeaturedRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tagged = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsNoAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetQuestionsNoAnswersRequest_Order {
        GETQUESTIONSNOANSWERSREQUEST_ORDER_DESC = 0;
        GETQUESTIONSNOANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsNoAnswersRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetQuestionsNoAnswersRequest_Sort {
        GETQUESTIONSNOANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSNOANSWERSREQUEST_SORT_CREATION = 1;
        GETQUESTIONSNOANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetQuestionsNoAnswersRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tagged = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsUnansweredRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 5;
    enum GetQuestionsUnansweredRequest_Order {
        GETQUESTIONSUNANSWEREDREQUEST_ORDER_DESC = 0;
        GETQUESTIONSUNANSWEREDREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsUnansweredRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetQuestionsUnansweredRequest_Sort {
        GETQUESTIONSUNANSWEREDREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSUNANSWEREDREQUEST_SORT_CREATION = 1;
        GETQUESTIONSUNANSWEREDREQUEST_SORT_VOTES = 2;
    }
    GetQuestionsUnansweredRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tagged = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetQuestionsIdsRequest_Order {
        GETQUESTIONSIDSREQUEST_ORDER_DESC = 0;
        GETQUESTIONSIDSREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetQuestionsIdsRequest_Sort {
        GETQUESTIONSIDSREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSIDSREQUEST_SORT_CREATION = 1;
        GETQUESTIONSIDSREQUEST_SORT_VOTES = 2;
    }
    GetQuestionsIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsIdsAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetQuestionsIdsAnswersRequest_Order {
        GETQUESTIONSIDSANSWERSREQUEST_ORDER_DESC = 0;
        GETQUESTIONSIDSANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsIdsAnswersRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetQuestionsIdsAnswersRequest_Sort {
        GETQUESTIONSIDSANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSIDSANSWERSREQUEST_SORT_CREATION = 1;
        GETQUESTIONSIDSANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetQuestionsIdsAnswersRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsIdsCommentsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetQuestionsIdsCommentsRequest_Order {
        GETQUESTIONSIDSCOMMENTSREQUEST_ORDER_DESC = 0;
        GETQUESTIONSIDSCOMMENTSREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsIdsCommentsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetQuestionsIdsCommentsRequest_Sort {
        GETQUESTIONSIDSCOMMENTSREQUEST_SORT_CREATION = 0;
        GETQUESTIONSIDSCOMMENTSREQUEST_SORT_VOTES = 1;
    }
    GetQuestionsIdsCommentsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsIdsLinkedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = rank => none
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = rank => none
    string min = 6;
    enum GetQuestionsIdsLinkedRequest_Order {
        GETQUESTIONSIDSLINKEDREQUEST_ORDER_DESC = 0;
        GETQUESTIONSIDSLINKEDREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsIdsLinkedRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetQuestionsIdsLinkedRequest_Sort {
        GETQUESTIONSIDSLINKEDREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSIDSLINKEDREQUEST_SORT_CREATION = 1;
        GETQUESTIONSIDSLINKEDREQUEST_SORT_VOTES = 2;
        GETQUESTIONSIDSLINKEDREQUEST_SORT_RANK = 3;
    }
    GetQuestionsIdsLinkedRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsIdsRelatedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = rank => none
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = rank => none
    string min = 6;
    enum GetQuestionsIdsRelatedRequest_Order {
        GETQUESTIONSIDSRELATEDREQUEST_ORDER_DESC = 0;
        GETQUESTIONSIDSRELATEDREQUEST_ORDER_ASC = 1;
    }
    GetQuestionsIdsRelatedRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetQuestionsIdsRelatedRequest_Sort {
        GETQUESTIONSIDSRELATEDREQUEST_SORT_ACTIVITY = 0;
        GETQUESTIONSIDSRELATEDREQUEST_SORT_CREATION = 1;
        GETQUESTIONSIDSRELATEDREQUEST_SORT_VOTES = 2;
        GETQUESTIONSIDSRELATEDREQUEST_SORT_RANK = 3;
    }
    GetQuestionsIdsRelatedRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetQuestionsIdsTimelineRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    int32 page = 5;
    int32 pagesize = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
    // Unix date.
    int32 todate = 8;
}

message GetRevisionsIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Guid list (semicolon delimited).
    string ids = 4;
    int32 page = 5;
    int32 pagesize = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
    // Unix date.
    int32 todate = 8;
}

message GetSearchRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string intitle = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = relevance => none
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = relevance => none
    string min = 6;
    // String list (semicolon delimited).
    string nottagged = 7;
    enum GetSearchRequest_Order {
        GETSEARCHREQUEST_ORDER_DESC = 0;
        GETSEARCHREQUEST_ORDER_ASC = 1;
    }
    GetSearchRequest_Order order = 8;
    int32 page = 9;
    int32 pagesize = 10;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 11;
    enum GetSearchRequest_Sort {
        GETSEARCHREQUEST_SORT_ACTIVITY = 0;
        GETSEARCHREQUEST_SORT_CREATION = 1;
        GETSEARCHREQUEST_SORT_VOTES = 2;
        GETSEARCHREQUEST_SORT_RELEVANCE = 3;
    }
    GetSearchRequest_Sort sort = 12;
    // String list (semicolon delimited).
    string tagged = 13;
    // Unix date.
    int32 todate = 14;
}

message GetSearchAdvancedRequest {
    enum GetSearchAdvancedRequest_Accepted {
        GETSEARCHADVANCEDREQUEST_ACCEPTED_TRUE = 0;
        GETSEARCHADVANCEDREQUEST_ACCEPTED_FALSE = 1;
    }
    GetSearchAdvancedRequest_Accepted accepted = 1;
    int32 answers = 2;
    string body = 3;
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 4;
    enum GetSearchAdvancedRequest_Closed {
        GETSEARCHADVANCEDREQUEST_CLOSED_TRUE = 0;
        GETSEARCHADVANCEDREQUEST_CLOSED_FALSE = 1;
    }
    GetSearchAdvancedRequest_Closed closed = 5;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 6;
    // Unix date.
    int32 fromdate = 7;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = relevance => none
    string max = 8;
    enum GetSearchAdvancedRequest_Migrated {
        GETSEARCHADVANCEDREQUEST_MIGRATED_TRUE = 0;
        GETSEARCHADVANCEDREQUEST_MIGRATED_FALSE = 1;
    }
    GetSearchAdvancedRequest_Migrated migrated = 9;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = relevance => none
    string min = 10;
    enum GetSearchAdvancedRequest_Notice {
        GETSEARCHADVANCEDREQUEST_NOTICE_TRUE = 0;
        GETSEARCHADVANCEDREQUEST_NOTICE_FALSE = 1;
    }
    GetSearchAdvancedRequest_Notice notice = 11;
    // String list (semicolon delimited).
    string nottagged = 12;
    enum GetSearchAdvancedRequest_Order {
        GETSEARCHADVANCEDREQUEST_ORDER_DESC = 0;
        GETSEARCHADVANCEDREQUEST_ORDER_ASC = 1;
    }
    GetSearchAdvancedRequest_Order order = 13;
    int32 page = 14;
    int32 pagesize = 15;
    string q = 16;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 17;
    enum GetSearchAdvancedRequest_Sort {
        GETSEARCHADVANCEDREQUEST_SORT_ACTIVITY = 0;
        GETSEARCHADVANCEDREQUEST_SORT_CREATION = 1;
        GETSEARCHADVANCEDREQUEST_SORT_VOTES = 2;
        GETSEARCHADVANCEDREQUEST_SORT_RELEVANCE = 3;
    }
    GetSearchAdvancedRequest_Sort sort = 18;
    // String list (semicolon delimited).
    string tagged = 19;
    string title = 20;
    // Unix date.
    int32 todate = 21;
    string url = 22;
    int32 user = 23;
    int32 views = 24;
    enum GetSearchAdvancedRequest_Wiki {
        GETSEARCHADVANCEDREQUEST_WIKI_TRUE = 0;
        GETSEARCHADVANCEDREQUEST_WIKI_FALSE = 1;
    }
    GetSearchAdvancedRequest_Wiki wiki = 25;
}

message GetSimilarRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = relevance => none
    string max = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = relevance => none
    string min = 5;
    // String list (semicolon delimited).
    string nottagged = 6;
    enum GetSimilarRequest_Order {
        GETSIMILARREQUEST_ORDER_DESC = 0;
        GETSIMILARREQUEST_ORDER_ASC = 1;
    }
    GetSimilarRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetSimilarRequest_Sort {
        GETSIMILARREQUEST_SORT_ACTIVITY = 0;
        GETSIMILARREQUEST_SORT_CREATION = 1;
        GETSIMILARREQUEST_SORT_VOTES = 2;
        GETSIMILARREQUEST_SORT_RELEVANCE = 3;
    }
    GetSimilarRequest_Sort sort = 11;
    // String list (semicolon delimited).
    string tagged = 12;
    string title = 13;
    // Unix date.
    int32 todate = 14;
}

message GetSitesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
}

message GetSuggestedEditsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string max = 4;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string min = 5;
    enum GetSuggestedEditsRequest_Order {
        GETSUGGESTEDEDITSREQUEST_ORDER_DESC = 0;
        GETSUGGESTEDEDITSREQUEST_ORDER_ASC = 1;
    }
    GetSuggestedEditsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetSuggestedEditsRequest_Sort {
        GETSUGGESTEDEDITSREQUEST_SORT_CREATION = 0;
        GETSUGGESTEDEDITSREQUEST_SORT_APPROVAL = 1;
        GETSUGGESTEDEDITSREQUEST_SORT_REJECTION = 2;
    }
    GetSuggestedEditsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetSuggestedEditsIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string max = 5;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string min = 6;
    enum GetSuggestedEditsIdsRequest_Order {
        GETSUGGESTEDEDITSIDSREQUEST_ORDER_DESC = 0;
        GETSUGGESTEDEDITSIDSREQUEST_ORDER_ASC = 1;
    }
    GetSuggestedEditsIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetSuggestedEditsIdsRequest_Sort {
        GETSUGGESTEDEDITSIDSREQUEST_SORT_CREATION = 0;
        GETSUGGESTEDEDITSIDSREQUEST_SORT_APPROVAL = 1;
        GETSUGGESTEDEDITSIDSREQUEST_SORT_REJECTION = 2;
    }
    GetSuggestedEditsIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string max = 5;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string min = 6;
    enum GetTagsRequest_Order {
        GETTAGSREQUEST_ORDER_DESC = 0;
        GETTAGSREQUEST_ORDER_ASC = 1;
    }
    GetTagsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetTagsRequest_Sort {
        GETTAGSREQUEST_SORT_POPULAR = 0;
        GETTAGSREQUEST_SORT_ACTIVITY = 1;
        GETTAGSREQUEST_SORT_NAME = 2;
    }
    GetTagsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetTagsModeratorOnlyRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string max = 5;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string min = 6;
    enum GetTagsModeratorOnlyRequest_Order {
        GETTAGSMODERATORONLYREQUEST_ORDER_DESC = 0;
        GETTAGSMODERATORONLYREQUEST_ORDER_ASC = 1;
    }
    GetTagsModeratorOnlyRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetTagsModeratorOnlyRequest_Sort {
        GETTAGSMODERATORONLYREQUEST_SORT_POPULAR = 0;
        GETTAGSMODERATORONLYREQUEST_SORT_ACTIVITY = 1;
        GETTAGSMODERATORONLYREQUEST_SORT_NAME = 2;
    }
    GetTagsModeratorOnlyRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetTagsRequiredRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string max = 5;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string min = 6;
    enum GetTagsRequiredRequest_Order {
        GETTAGSREQUIREDREQUEST_ORDER_DESC = 0;
        GETTAGSREQUIREDREQUEST_ORDER_ASC = 1;
    }
    GetTagsRequiredRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetTagsRequiredRequest_Sort {
        GETTAGSREQUIREDREQUEST_SORT_POPULAR = 0;
        GETTAGSREQUIREDREQUEST_SORT_ACTIVITY = 1;
        GETTAGSREQUIREDREQUEST_SORT_NAME = 2;
    }
    GetTagsRequiredRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetTagsSynonymsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = applied => number
    // sort = activity => date
    string max = 4;
    // sort = creation => date
    // sort = applied => number
    // sort = activity => date
    string min = 5;
    enum GetTagsSynonymsRequest_Order {
        GETTAGSSYNONYMSREQUEST_ORDER_DESC = 0;
        GETTAGSSYNONYMSREQUEST_ORDER_ASC = 1;
    }
    GetTagsSynonymsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetTagsSynonymsRequest_Sort {
        GETTAGSSYNONYMSREQUEST_SORT_CREATION = 0;
        GETTAGSSYNONYMSREQUEST_SORT_APPLIED = 1;
        GETTAGSSYNONYMSREQUEST_SORT_ACTIVITY = 2;
    }
    GetTagsSynonymsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetTagsTagsFaqRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
    // String list (semicolon delimited).
    string tags = 6;
}

message GetTagsTagsInfoRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string max = 4;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string min = 5;
    enum GetTagsTagsInfoRequest_Order {
        GETTAGSTAGSINFOREQUEST_ORDER_DESC = 0;
        GETTAGSTAGSINFOREQUEST_ORDER_ASC = 1;
    }
    GetTagsTagsInfoRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetTagsTagsInfoRequest_Sort {
        GETTAGSTAGSINFOREQUEST_SORT_POPULAR = 0;
        GETTAGSTAGSINFOREQUEST_SORT_ACTIVITY = 1;
        GETTAGSTAGSINFOREQUEST_SORT_NAME = 2;
    }
    GetTagsTagsInfoRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tags = 11;
    // Unix date.
    int32 todate = 12;
}

message GetTagsTagsRelatedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
    // String list (semicolon delimited).
    string tags = 6;
}

message GetTagsTagsSynonymsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = creation => date
    // sort = applied => number
    // sort = activity => date
    string max = 4;
    // sort = creation => date
    // sort = applied => number
    // sort = activity => date
    string min = 5;
    enum GetTagsTagsSynonymsRequest_Order {
        GETTAGSTAGSSYNONYMSREQUEST_ORDER_DESC = 0;
        GETTAGSTAGSSYNONYMSREQUEST_ORDER_ASC = 1;
    }
    GetTagsTagsSynonymsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetTagsTagsSynonymsRequest_Sort {
        GETTAGSTAGSSYNONYMSREQUEST_SORT_CREATION = 0;
        GETTAGSTAGSSYNONYMSREQUEST_SORT_APPLIED = 1;
        GETTAGSTAGSSYNONYMSREQUEST_SORT_ACTIVITY = 2;
    }
    GetTagsTagsSynonymsRequest_Sort sort = 10;
    // String list (semicolon delimited).
    string tags = 11;
    // Unix date.
    int32 todate = 12;
}

message GetTagsTagsWikisRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 5;
    // String list (semicolon delimited).
    string tags = 6;
}

message GetTagsTagTopAnswerersPeriodRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    enum GetTagsTagTopAnswerersPeriodRequest_Period {
        GETTAGSTAGTOPANSWERERSPERIODREQUEST_PERIOD_ALL_TIME = 0;
        GETTAGSTAGTOPANSWERERSPERIODREQUEST_PERIOD_MONTH = 1;
    }
    GetTagsTagTopAnswerersPeriodRequest_Period period = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
    string tag = 7;
}

message GetTagsTagTopAskersPeriodRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 page = 3;
    int32 pagesize = 4;
    enum GetTagsTagTopAskersPeriodRequest_Period {
        GETTAGSTAGTOPASKERSPERIODREQUEST_PERIOD_ALL_TIME = 0;
        GETTAGSTAGTOPASKERSPERIODREQUEST_PERIOD_MONTH = 1;
    }
    GetTagsTagTopAskersPeriodRequest_Period period = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
    string tag = 7;
}

message GetUsersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    string inname = 4;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string max = 5;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string min = 6;
    enum GetUsersRequest_Order {
        GETUSERSREQUEST_ORDER_DESC = 0;
        GETUSERSREQUEST_ORDER_ASC = 1;
    }
    GetUsersRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersRequest_Sort {
        GETUSERSREQUEST_SORT_REPUTATION = 0;
        GETUSERSREQUEST_SORT_CREATION = 1;
        GETUSERSREQUEST_SORT_NAME = 2;
        GETUSERSREQUEST_SORT_MODIFIED = 3;
    }
    GetUsersRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersModeratorsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string max = 4;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string min = 5;
    enum GetUsersModeratorsRequest_Order {
        GETUSERSMODERATORSREQUEST_ORDER_DESC = 0;
        GETUSERSMODERATORSREQUEST_ORDER_ASC = 1;
    }
    GetUsersModeratorsRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetUsersModeratorsRequest_Sort {
        GETUSERSMODERATORSREQUEST_SORT_REPUTATION = 0;
        GETUSERSMODERATORSREQUEST_SORT_CREATION = 1;
        GETUSERSMODERATORSREQUEST_SORT_NAME = 2;
        GETUSERSMODERATORSREQUEST_SORT_MODIFIED = 3;
    }
    GetUsersModeratorsRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetUsersModeratorsElectedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string max = 4;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string min = 5;
    enum GetUsersModeratorsElectedRequest_Order {
        GETUSERSMODERATORSELECTEDREQUEST_ORDER_DESC = 0;
        GETUSERSMODERATORSELECTEDREQUEST_ORDER_ASC = 1;
    }
    GetUsersModeratorsElectedRequest_Order order = 6;
    int32 page = 7;
    int32 pagesize = 8;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 9;
    enum GetUsersModeratorsElectedRequest_Sort {
        GETUSERSMODERATORSELECTEDREQUEST_SORT_REPUTATION = 0;
        GETUSERSMODERATORSELECTEDREQUEST_SORT_CREATION = 1;
        GETUSERSMODERATORSELECTEDREQUEST_SORT_NAME = 2;
        GETUSERSMODERATORSELECTEDREQUEST_SORT_MODIFIED = 3;
    }
    GetUsersModeratorsElectedRequest_Sort sort = 10;
    // Unix date.
    int32 todate = 11;
}

message GetUsersIdsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string max = 5;
    // sort = reputation => number
    // sort = creation => date
    // sort = name => string
    // sort = modified => date
    string min = 6;
    enum GetUsersIdsRequest_Order {
        GETUSERSIDSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsRequest_Sort {
        GETUSERSIDSREQUEST_SORT_REPUTATION = 0;
        GETUSERSIDSREQUEST_SORT_CREATION = 1;
        GETUSERSIDSREQUEST_SORT_NAME = 2;
        GETUSERSIDSREQUEST_SORT_MODIFIED = 3;
    }
    GetUsersIdsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsAnswersRequest_Order {
        GETUSERSIDSANSWERSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsAnswersRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsAnswersRequest_Sort {
        GETUSERSIDSANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSANSWERSREQUEST_SORT_CREATION = 1;
        GETUSERSIDSANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdsAnswersRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsAssociatedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Number list (semicolon delimited).
    string ids = 3;
    int32 page = 4;
    int32 pagesize = 5;
}

message GetUsersIdsBadgesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    // sort = awarded => date
    string max = 5;
    // sort = rank => string
    // sort = name => string
    // sort = type => string
    // sort = awarded => date
    string min = 6;
    enum GetUsersIdsBadgesRequest_Order {
        GETUSERSIDSBADGESREQUEST_ORDER_DESC = 0;
        GETUSERSIDSBADGESREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsBadgesRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsBadgesRequest_Sort {
        GETUSERSIDSBADGESREQUEST_SORT_RANK = 0;
        GETUSERSIDSBADGESREQUEST_SORT_NAME = 1;
        GETUSERSIDSBADGESREQUEST_SORT_TYPE = 2;
        GETUSERSIDSBADGESREQUEST_SORT_AWARDED = 3;
    }
    GetUsersIdsBadgesRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsCommentsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsCommentsRequest_Order {
        GETUSERSIDSCOMMENTSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSCOMMENTSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsCommentsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsCommentsRequest_Sort {
        GETUSERSIDSCOMMENTSREQUEST_SORT_CREATION = 0;
        GETUSERSIDSCOMMENTSREQUEST_SORT_VOTES = 1;
    }
    GetUsersIdsCommentsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsCommentsToidRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsCommentsToidRequest_Order {
        GETUSERSIDSCOMMENTSTOIDREQUEST_ORDER_DESC = 0;
        GETUSERSIDSCOMMENTSTOIDREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsCommentsToidRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsCommentsToidRequest_Sort {
        GETUSERSIDSCOMMENTSTOIDREQUEST_SORT_CREATION = 0;
        GETUSERSIDSCOMMENTSTOIDREQUEST_SORT_VOTES = 1;
    }
    GetUsersIdsCommentsToidRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
    int32 toid = 13;
}

message GetUsersIdsFavoritesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = added => date
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    // sort = added => date
    string min = 6;
    enum GetUsersIdsFavoritesRequest_Order {
        GETUSERSIDSFAVORITESREQUEST_ORDER_DESC = 0;
        GETUSERSIDSFAVORITESREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsFavoritesRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsFavoritesRequest_Sort {
        GETUSERSIDSFAVORITESREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSFAVORITESREQUEST_SORT_CREATION = 1;
        GETUSERSIDSFAVORITESREQUEST_SORT_VOTES = 2;
        GETUSERSIDSFAVORITESREQUEST_SORT_ADDED = 3;
    }
    GetUsersIdsFavoritesRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsMentionedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsMentionedRequest_Order {
        GETUSERSIDSMENTIONEDREQUEST_ORDER_DESC = 0;
        GETUSERSIDSMENTIONEDREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsMentionedRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsMentionedRequest_Sort {
        GETUSERSIDSMENTIONEDREQUEST_SORT_CREATION = 0;
        GETUSERSIDSMENTIONEDREQUEST_SORT_VOTES = 1;
    }
    GetUsersIdsMentionedRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsMergesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Number list (semicolon delimited).
    string ids = 3;
    int32 page = 4;
    int32 pagesize = 5;
}

message GetUsersIdsQuestionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsQuestionsRequest_Order {
        GETUSERSIDSQUESTIONSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSQUESTIONSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsQuestionsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsQuestionsRequest_Sort {
        GETUSERSIDSQUESTIONSREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSQUESTIONSREQUEST_SORT_CREATION = 1;
        GETUSERSIDSQUESTIONSREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdsQuestionsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsQuestionsFeaturedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsQuestionsFeaturedRequest_Order {
        GETUSERSIDSQUESTIONSFEATUREDREQUEST_ORDER_DESC = 0;
        GETUSERSIDSQUESTIONSFEATUREDREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsQuestionsFeaturedRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsQuestionsFeaturedRequest_Sort {
        GETUSERSIDSQUESTIONSFEATUREDREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSQUESTIONSFEATUREDREQUEST_SORT_CREATION = 1;
        GETUSERSIDSQUESTIONSFEATUREDREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdsQuestionsFeaturedRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsQuestionsNoAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsQuestionsNoAnswersRequest_Order {
        GETUSERSIDSQUESTIONSNOANSWERSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSQUESTIONSNOANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsQuestionsNoAnswersRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsQuestionsNoAnswersRequest_Sort {
        GETUSERSIDSQUESTIONSNOANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSQUESTIONSNOANSWERSREQUEST_SORT_CREATION = 1;
        GETUSERSIDSQUESTIONSNOANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdsQuestionsNoAnswersRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsQuestionsUnacceptedRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsQuestionsUnacceptedRequest_Order {
        GETUSERSIDSQUESTIONSUNACCEPTEDREQUEST_ORDER_DESC = 0;
        GETUSERSIDSQUESTIONSUNACCEPTEDREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsQuestionsUnacceptedRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsQuestionsUnacceptedRequest_Sort {
        GETUSERSIDSQUESTIONSUNACCEPTEDREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSQUESTIONSUNACCEPTEDREQUEST_SORT_CREATION = 1;
        GETUSERSIDSQUESTIONSUNACCEPTEDREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdsQuestionsUnacceptedRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsQuestionsUnansweredRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdsQuestionsUnansweredRequest_Order {
        GETUSERSIDSQUESTIONSUNANSWEREDREQUEST_ORDER_DESC = 0;
        GETUSERSIDSQUESTIONSUNANSWEREDREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsQuestionsUnansweredRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsQuestionsUnansweredRequest_Sort {
        GETUSERSIDSQUESTIONSUNANSWEREDREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDSQUESTIONSUNANSWEREDREQUEST_SORT_CREATION = 1;
        GETUSERSIDSQUESTIONSUNANSWEREDREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdsQuestionsUnansweredRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsReputationRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    int32 page = 5;
    int32 pagesize = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
    // Unix date.
    int32 todate = 8;
}

message GetUsersIdsReputationHistoryRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Number list (semicolon delimited).
    string ids = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdsSuggestedEditsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string max = 5;
    // sort = creation => date
    // sort = approval => date
    // sort = rejection => date
    string min = 6;
    enum GetUsersIdsSuggestedEditsRequest_Order {
        GETUSERSIDSSUGGESTEDEDITSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSSUGGESTEDEDITSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsSuggestedEditsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsSuggestedEditsRequest_Sort {
        GETUSERSIDSSUGGESTEDEDITSREQUEST_SORT_CREATION = 0;
        GETUSERSIDSSUGGESTEDEDITSREQUEST_SORT_APPROVAL = 1;
        GETUSERSIDSSUGGESTEDEDITSREQUEST_SORT_REJECTION = 2;
    }
    GetUsersIdsSuggestedEditsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string max = 5;
    // sort = popular => number
    // sort = activity => date
    // sort = name => string
    string min = 6;
    enum GetUsersIdsTagsRequest_Order {
        GETUSERSIDSTAGSREQUEST_ORDER_DESC = 0;
        GETUSERSIDSTAGSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdsTagsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdsTagsRequest_Sort {
        GETUSERSIDSTAGSREQUEST_SORT_POPULAR = 0;
        GETUSERSIDSTAGSREQUEST_SORT_ACTIVITY = 1;
        GETUSERSIDSTAGSREQUEST_SORT_NAME = 2;
    }
    GetUsersIdsTagsRequest_Sort sort = 11;
    // Unix date.
    int32 todate = 12;
}

message GetUsersIdsTimelineRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    // Number list (semicolon delimited).
    string ids = 4;
    int32 page = 5;
    int32 pagesize = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
    // Unix date.
    int32 todate = 8;
}

message GetUsersIdInboxRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdInboxUnreadRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Unix date.
    int32 since = 6;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 7;
}

message GetUsersIdNotificationsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdNotificationsUnreadRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdPrivilegesRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdReputationHistoryFullRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdTagsTagsTopAnswersRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    int32 id = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdTagsTagsTopAnswersRequest_Order {
        GETUSERSIDTAGSTAGSTOPANSWERSREQUEST_ORDER_DESC = 0;
        GETUSERSIDTAGSTAGSTOPANSWERSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdTagsTagsTopAnswersRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdTagsTagsTopAnswersRequest_Sort {
        GETUSERSIDTAGSTAGSTOPANSWERSREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDTAGSTAGSTOPANSWERSREQUEST_SORT_CREATION = 1;
        GETUSERSIDTAGSTAGSTOPANSWERSREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdTagsTagsTopAnswersRequest_Sort sort = 11;
    // String list (semicolon delimited).
    string tags = 12;
    // Unix date.
    int32 todate = 13;
}

message GetUsersIdTagsTagsTopQuestionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    // Unix date.
    int32 fromdate = 3;
    int32 id = 4;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string max = 5;
    // sort = activity => date
    // sort = creation => date
    // sort = votes => number
    string min = 6;
    enum GetUsersIdTagsTagsTopQuestionsRequest_Order {
        GETUSERSIDTAGSTAGSTOPQUESTIONSREQUEST_ORDER_DESC = 0;
        GETUSERSIDTAGSTAGSTOPQUESTIONSREQUEST_ORDER_ASC = 1;
    }
    GetUsersIdTagsTagsTopQuestionsRequest_Order order = 7;
    int32 page = 8;
    int32 pagesize = 9;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 10;
    enum GetUsersIdTagsTagsTopQuestionsRequest_Sort {
        GETUSERSIDTAGSTAGSTOPQUESTIONSREQUEST_SORT_ACTIVITY = 0;
        GETUSERSIDTAGSTAGSTOPQUESTIONSREQUEST_SORT_CREATION = 1;
        GETUSERSIDTAGSTAGSTOPQUESTIONSREQUEST_SORT_VOTES = 2;
    }
    GetUsersIdTagsTagsTopQuestionsRequest_Sort sort = 11;
    // String list (semicolon delimited).
    string tags = 12;
    // Unix date.
    int32 todate = 13;
}

message GetUsersIdTopAnswerTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdTopQuestionTagsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message GetUsersIdWritePermissionsRequest {
    // All API responses are JSON, we do support JSONP with the callback query parameter.
    string callback = 1;
    // #Discussion
    // 
    // The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user's badge counts it could exclude user.badge_counts whenever it calls a method that returns users.
    // 
    // An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.
    // 
    // Filters are immutable and non-expiring. An application can safely "bake in" any filters that are created, it is not necessary (or advisable) to create filters at runtime.
    // 
    // The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).
    // 
    // #Safety
    // 
    // Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    // 
    // Note that this does not mean that "safe" filter is mearly an "unsafe" one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).
    // 
    // When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the "safe" data is the only accessible data it will be returned even in "unsafe" filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.
    // 
    // #Built In Filters
    // 
    // The following filters are built in:
    // 
    // default, each type documents which fields are returned under the default filter (for example, answers).
    // withbody, which is default plus the *.body fields
    // none, which is empty
    // total, which includes just .total
    // 
    // #Compatibility with V1.x
    // 
    // For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.
    string filter = 2;
    int32 id = 3;
    int32 page = 4;
    int32 pagesize = 5;
    // Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. "stackoverflow.com"), or a short form identified by api_site_parameter on the site object.
    string site = 6;
}

message Access_token {
    string access_token = 1;
    int32 account_id = 2;
    int32 expires_on_date = 3;
    message Scope {
    }
    repeated Scope scope = 4;
}
repeated Access_token access_tokens = 1

message Account_merge {
    int32 merge_date = 1;
    int32 new_account_id = 2;
    int32 old_account_id = 3;
}
repeated Account_merge account_merge = 1

message Answer {
    bool accepted = 1;
    int32 answer_id = 2;
    int32 awarded_bounty_amount = 3;
    message Awarded_bounty_user {
    }
    repeated Awarded_bounty_user awarded_bounty_users = 4;
    string body = 5;
    string body_markdown = 6;
    bool can_flag = 7;
    int32 comment_count = 8;
    message Comment {
    }
    repeated Comment comments = 9;
    int32 community_owned_date = 10;
    int32 creation_date = 11;
    int32 down_vote_count = 12;
    bool downvoted = 13;
    bool is_accepted = 14;
    int32 last_activity_date = 15;
    int32 last_edit_date = 16;
    message Last_editor {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Last_editor last_editor = 17;
    string link = 18;
    int32 locked_date = 19;
    message Owner {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Owner owner = 20;
    int32 question_id = 21;
    int32 score = 22;
    string share_link = 23;
    message Tag {
    }
    repeated Tag tags = 24;
    string title = 25;
    int32 up_vote_count = 26;
    bool upvoted = 27;
}
repeated Answer answers = 1

message Badge {
    int32 award_count = 1;
    int32 badge_id = 2;
    string badge_type = 3;
    string description = 4;
    string link = 5;
    string name = 6;
    string rank = 7;
    message User {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    User user = 8;
}
repeated Badge badges = 1

message Comment {
    string body = 1;
    string body_markdown = 2;
    bool can_flag = 3;
    int32 comment_id = 4;
    int32 creation_date = 5;
    bool edited = 6;
    string link = 7;
    message Owner {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Owner owner = 8;
    int32 post_id = 9;
    string post_type = 10;
    message Reply_to_user {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Reply_to_user reply_to_user = 11;
    int32 score = 12;
    bool upvoted = 13;
}
repeated Comment comments = 1

message Created_comment {
    string body = 1;
    string body_markdown = 2;
    bool can_flag = 3;
    int32 comment_id = 4;
    int32 creation_date = 5;
    bool edited = 6;
    string link = 7;
    message Owner {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Owner owner = 8;
    int32 post_id = 9;
    string post_type = 10;
    message Reply_to_user {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Reply_to_user reply_to_user = 11;
    int32 score = 12;
    bool upvoted = 13;
}

message Error {
    int32 error_id = 1;
    string error_message = 2;
    string error_name = 3;
}

message Error {
    string description = 1;
    int32 error_id = 2;
    string error_name = 3;
}
repeated Error errors = 1

message Event {
    int32 creation_date = 1;
    string event_type = 2;
    string excerpt = 3;
    string link = 4;
    int32 the id of the object (answer, comment, question, or user) the event describes = 5;
}
repeated Event events = 1

message Filter {
    string filter = 1;
    string filter_type = 2;
    message Included_field {
    }
    repeated Included_field included_fields = 3;
}
repeated Filter filters = 1

message Inbox_item {
    int32 answer_id = 1;
    string body = 2;
    int32 comment_id = 3;
    int32 creation_date = 4;
    bool is_unread = 5;
    string item_type = 6;
    string link = 7;
    int32 question_id = 8;
    message Site {
        message Aliase {
        }
        repeated Aliase aliases = 1;
        string api_site_parameter = 2;
        string audience = 3;
        int32 closed_beta_date = 4;
        string favicon_url = 5;
        string high_resolution_icon_url = 6;
        string icon_url = 7;
        int32 launch_date = 8;
        string logo_url = 9;
        message Markdown_extension {
        }
        repeated Markdown_extension markdown_extensions = 10;
        string name = 11;
        int32 open_beta_date = 12;
        message Related_site {
        }
        repeated Related_site related_sites = 13;
        string site_state = 14;
        string site_type = 15;
        string site_url = 16;
        message Styling {
            string link_color = 1;
            string tag_background_color = 2;
            string tag_foreground_color = 3;
        }
        Styling styling = 17;
        string twitter_account = 18;
    }
    Site site = 9;
    string title = 10;
}
repeated Inbox_item inbox_items = 1

message Info_object {
    int32 answers_per_minute = 1;
    string api_revision = 2;
    int32 badges_per_minute = 3;
    int32 new_active_users = 4;
    int32 questions_per_minute = 5;
    message Site {
        message Aliase {
        }
        repeated Aliase aliases = 1;
        string api_site_parameter = 2;
        string audience = 3;
        int32 closed_beta_date = 4;
        string favicon_url = 5;
        string high_resolution_icon_url = 6;
        string icon_url = 7;
        int32 launch_date = 8;
        string logo_url = 9;
        message Markdown_extension {
        }
        repeated Markdown_extension markdown_extensions = 10;
        string name = 11;
        int32 open_beta_date = 12;
        message Related_site {
        }
        repeated Related_site related_sites = 13;
        string site_state = 14;
        string site_type = 15;
        string site_url = 16;
        message Styling {
            string link_color = 1;
            string tag_background_color = 2;
            string tag_foreground_color = 3;
        }
        Styling styling = 17;
        string twitter_account = 18;
    }
    Site site = 6;
    int32 total_accepted = 7;
    int32 total_answers = 8;
    int32 total_badges = 9;
    int32 total_comments = 10;
    int32 total_questions = 11;
    int32 total_unanswered = 12;
    int32 total_users = 13;
    int32 total_votes = 14;
}

message Network_user {
    int32 account_id = 1;
    int32 answer_count = 2;
    message Badge_counts {
        int32 bronze = 1;
        int32 gold = 2;
        int32 silver = 3;
    }
    Badge_counts badge_counts = 3;
    int32 creation_date = 4;
    int32 last_access_date = 5;
    int32 question_count = 6;
    int32 reputation = 7;
    string site_name = 8;
    string site_url = 9;
    message Top_answer {
    }
    repeated Top_answer top_answers = 10;
    message Top_question {
    }
    repeated Top_question top_questions = 11;
    int32 user_id = 12;
    string user_type = 13;
}
repeated Network_user network_users = 1

message Notification {
    string body = 1;
    int32 creation_date = 2;
    bool is_unread = 3;
    string notification_type = 4;
    int32 post_id = 5;
    message Site {
        message Aliase {
        }
        repeated Aliase aliases = 1;
        string api_site_parameter = 2;
        string audience = 3;
        int32 closed_beta_date = 4;
        string favicon_url = 5;
        string high_resolution_icon_url = 6;
        string icon_url = 7;
        int32 launch_date = 8;
        string logo_url = 9;
        message Markdown_extension {
        }
        repeated Markdown_extension markdown_extensions = 10;
        string name = 11;
        int32 open_beta_date = 12;
        message Related_site {
        }
        repeated Related_site related_sites = 13;
        string site_state = 14;
        string site_type = 15;
        string site_url = 16;
        message Styling {
            string link_color = 1;
            string tag_background_color = 2;
            string tag_foreground_color = 3;
        }
        Styling styling = 17;
        string twitter_account = 18;
    }
    Site site = 6;
}
repeated Notification notifications = 1

message Post {
    string body = 1;
    string body_markdown = 2;
    int32 comment_count = 3;
    message Comment {
    }
    repeated Comment comments = 4;
    int32 creation_date = 5;
    int32 down_vote_count = 6;
    bool downvoted = 7;
    int32 last_activity_date = 8;
    int32 last_edit_date = 9;
    message Last_editor {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Last_editor last_editor = 10;
    string link = 11;
    message Owner {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Owner owner = 12;
    int32 post_id = 13;
    string post_type = 14;
    int32 score = 15;
    string share_link = 16;
    string title = 17;
    int32 up_vote_count = 18;
    bool upvoted = 19;
}
repeated Post posts = 1

message Privilege {
    string description = 1;
    int32 reputation = 2;
    string short_description = 3;
}
repeated Privilege privileges = 1

message Question_timeline_event {
    int32 comment_id = 1;
    int32 creation_date = 2;
    int32 down_vote_count = 3;
    message Owner {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Owner owner = 4;
    int32 post_id = 5;
    int32 question_id = 6;
    string revision_guid = 7;
    string timeline_type = 8;
    int32 up_vote_count = 9;
    message User {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    User user = 10;
}
repeated Question_timeline_event question_timeline_events = 1

message Question {
    int32 accepted_answer_id = 1;
    int32 answer_count = 2;
    message Answer {
    }
    repeated Answer answers = 3;
    string body = 4;
    string body_markdown = 5;
    int32 bounty_amount = 6;
    int32 bounty_closes_date = 7;
    message Bounty_user {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Bounty_user bounty_user = 8;
    bool can_close = 9;
    bool can_flag = 10;
    int32 close_vote_count = 11;
    int32 closed_date = 12;
    message Closed_details {
        message By_user {
        }
        repeated By_user by_users = 1;
        string description = 2;
        bool on_hold = 3;
        message Original_question {
        }
        repeated Original_question original_questions = 4;
        string reason = 5;
    }
    Closed_details closed_details = 13;
    string closed_reason = 14;
    int32 comment_count = 15;
    message Comment {
    }
    repeated Comment comments = 16;
    int32 community_owned_date = 17;
    int32 creation_date = 18;
    int32 delete_vote_count = 19;
    int32 down_vote_count = 20;
    bool downvoted = 21;
    int32 favorite_count = 22;
    bool favorited = 23;
    bool is_answered = 24;
    int32 last_activity_date = 25;
    int32 last_edit_date = 26;
    message Last_editor {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Last_editor last_editor = 27;
    string link = 28;
    int32 locked_date = 29;
    message Migrated_from {
        int32 on_date = 1;
        message Other_site {
            message Aliase {
            }
            repeated Aliase aliases = 1;
            string api_site_parameter = 2;
            string audience = 3;
            int32 closed_beta_date = 4;
            string favicon_url = 5;
            string high_resolution_icon_url = 6;
            string icon_url = 7;
            int32 launch_date = 8;
            string logo_url = 9;
            message Markdown_extension {
            }
            repeated Markdown_extension markdown_extensions = 10;
            string name = 11;
            int32 open_beta_date = 12;
            message Related_site {
            }
            repeated Related_site related_sites = 13;
            string site_state = 14;
            string site_type = 15;
            string site_url = 16;
            message Styling {
                string link_color = 1;
                string tag_background_color = 2;
                string tag_foreground_color = 3;
            }
            Styling styling = 17;
            string twitter_account = 18;
        }
        Other_site other_site = 2;
        int32 question_id = 3;
    }
    Migrated_from migrated_from = 30;
    message Migrated_to {
        int32 on_date = 1;
        message Other_site {
            message Aliase {
            }
            repeated Aliase aliases = 1;
            string api_site_parameter = 2;
            string audience = 3;
            int32 closed_beta_date = 4;
            string favicon_url = 5;
            string high_resolution_icon_url = 6;
            string icon_url = 7;
            int32 launch_date = 8;
            string logo_url = 9;
            message Markdown_extension {
            }
            repeated Markdown_extension markdown_extensions = 10;
            string name = 11;
            int32 open_beta_date = 12;
            message Related_site {
            }
            repeated Related_site related_sites = 13;
            string site_state = 14;
            string site_type = 15;
            string site_url = 16;
            message Styling {
                string link_color = 1;
                string tag_background_color = 2;
                string tag_foreground_color = 3;
            }
            Styling styling = 17;
            string twitter_account = 18;
        }
        Other_site other_site = 2;
        int32 question_id = 3;
    }
    Migrated_to migrated_to = 31;
    message Notice {
        string body = 1;
        int32 creation_date = 2;
        int32 owner_user_id = 3;
    }
    Notice notice = 32;
    message Owner {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Owner owner = 33;
    int32 protected_date = 34;
    int32 question_id = 35;
    int32 reopen_vote_count = 36;
    int32 score = 37;
    string share_link = 38;
    message Tag {
    }
    repeated Tag tags = 39;
    string title = 40;
    int32 up_vote_count = 41;
    bool upvoted = 42;
    int32 view_count = 43;
}
repeated Question questions = 1

message Reputation_change {
    string link = 1;
    int32 on_date = 2;
    int32 post_id = 3;
    string post_type = 4;
    int32 reputation_change = 5;
    string title = 6;
    int32 user_id = 7;
    string vote_type = 8;
}
repeated Reputation_change reputation_changes = 1

message Reputation_history {
    int32 creation_date = 1;
    int32 post_id = 2;
    int32 reputation_change = 3;
    string reputation_history_type = 4;
    int32 user_id = 5;
}
repeated Reputation_history reputation_history = 1

message Reputation_object {
    string link = 1;
    int32 on_date = 2;
    int32 post_id = 3;
    string post_type = 4;
    int32 reputation_change = 5;
    string title = 6;
    int32 user_id = 7;
    string vote_type = 8;
}
repeated Reputation_object reputation_objects = 1

message Revision {
    string body = 1;
    string comment = 2;
    int32 creation_date = 3;
    bool is_rollback = 4;
    string last_body = 5;
    message Last_tag {
    }
    repeated Last_tag last_tags = 6;
    string last_title = 7;
    int32 post_id = 8;
    string post_type = 9;
    string revision_guid = 10;
    int32 revision_number = 11;
    string revision_type = 12;
    bool set_community_wiki = 13;
    message Tag {
    }
    repeated Tag tags = 14;
    string title = 15;
    message User {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    User user = 16;
}
repeated Revision revisions = 1

message Single_filter {
    string filter = 1;
    string filter_type = 2;
    message Included_field {
    }
    repeated Included_field included_fields = 3;
}

message Site {
    message Aliase {
    }
    repeated Aliase aliases = 1;
    string api_site_parameter = 2;
    string audience = 3;
    int32 closed_beta_date = 4;
    string favicon_url = 5;
    string high_resolution_icon_url = 6;
    string icon_url = 7;
    int32 launch_date = 8;
    string logo_url = 9;
    message Markdown_extension {
    }
    repeated Markdown_extension markdown_extensions = 10;
    string name = 11;
    int32 open_beta_date = 12;
    message Related_site {
    }
    repeated Related_site related_sites = 13;
    string site_state = 14;
    string site_type = 15;
    string site_url = 16;
    message Styling {
        string link_color = 1;
        string tag_background_color = 2;
        string tag_foreground_color = 3;
    }
    Styling styling = 17;
    string twitter_account = 18;
}
repeated Site sites = 1

message Suggested_edit {
    int32 approval_date = 1;
    string body = 2;
    string comment = 3;
    int32 creation_date = 4;
    int32 post_id = 5;
    string post_type = 6;
    message Proposing_user {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Proposing_user proposing_user = 7;
    int32 rejection_date = 8;
    int32 suggested_edit_id = 9;
    message Tag {
    }
    repeated Tag tags = 10;
    string title = 11;
}
repeated Suggested_edit suggested_edits = 1

message Tag_score_object {
    int32 post_count = 1;
    int32 score = 2;
    message User {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    User user = 3;
}
repeated Tag_score_object tag_score_objects = 1

message Tag_synonym {
    int32 applied_count = 1;
    int32 creation_date = 2;
    string from_tag = 3;
    int32 last_applied_date = 4;
    string to_tag = 5;
}
repeated Tag_synonym tag_synonyms = 1

message Tag_wiki {
    string body = 1;
    int32 body_last_edit_date = 2;
    string excerpt = 3;
    int32 excerpt_last_edit_date = 4;
    message Last_body_editor {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Last_body_editor last_body_editor = 5;
    message Last_excerpt_editor {
        int32 accept_rate = 1;
        message Badge_counts {
            int32 bronze = 1;
            int32 gold = 2;
            int32 silver = 3;
        }
        Badge_counts badge_counts = 2;
        string display_name = 3;
        string link = 4;
        string profile_image = 5;
        int32 reputation = 6;
        int32 user_id = 7;
        string user_type = 8;
    }
    Last_excerpt_editor last_excerpt_editor = 6;
    string tag_name = 7;
}
repeated Tag_wiki tag_wikis = 1

message Tag {
    int32 count = 1;
    bool has_synonyms = 2;
    bool is_moderator_only = 3;
    bool is_required = 4;
    int32 last_activity_date = 5;
    string name = 6;
    message Synonym {
    }
    repeated Synonym synonyms = 7;
    int32 user_id = 8;
}
repeated Tag tags = 1

message Top_tag_object {
    int32 answer_count = 1;
    int32 answer_score = 2;
    int32 question_count = 3;
    int32 question_score = 4;
    string tag_name = 5;
    int32 user_id = 6;
}
repeated Top_tag_object top_tag_objects = 1

message User {
    string about_me = 1;
    int32 accept_rate = 2;
    int32 account_id = 3;
    int32 age = 4;
    int32 answer_count = 5;
    message Badge_counts {
        int32 bronze = 1;
        int32 gold = 2;
        int32 silver = 3;
    }
    Badge_counts badge_counts = 6;
    int32 creation_date = 7;
    string display_name = 8;
    int32 down_vote_count = 9;
    bool is_employee = 10;
    int32 last_access_date = 11;
    int32 last_modified_date = 12;
    string link = 13;
    string location = 14;
    string profile_image = 15;
    int32 question_count = 16;
    int32 reputation = 17;
    int32 reputation_change_day = 18;
    int32 reputation_change_month = 19;
    int32 reputation_change_quarter = 20;
    int32 reputation_change_week = 21;
    int32 reputation_change_year = 22;
    int32 timed_penalty_date = 23;
    int32 up_vote_count = 24;
    int32 user_id = 25;
    string user_type = 26;
    int32 view_count = 27;
    string website_url = 28;
}

message User_timeline_object {
    int32 badge_id = 1;
    int32 comment_id = 2;
    int32 creation_date = 3;
    string detail = 4;
    string link = 5;
    int32 post_id = 6;
    string post_type = 7;
    int32 suggested_edit_id = 8;
    string timeline_type = 9;
    string title = 10;
    int32 user_id = 11;
}
repeated User_timeline_object user_timeline_objects = 1

message User {
    string about_me = 1;
    int32 accept_rate = 2;
    int32 account_id = 3;
    int32 age = 4;
    int32 answer_count = 5;
    message Badge_counts {
        int32 bronze = 1;
        int32 gold = 2;
        int32 silver = 3;
    }
    Badge_counts badge_counts = 6;
    int32 creation_date = 7;
    string display_name = 8;
    int32 down_vote_count = 9;
    bool is_employee = 10;
    int32 last_access_date = 11;
    int32 last_modified_date = 12;
    string link = 13;
    string location = 14;
    string profile_image = 15;
    int32 question_count = 16;
    int32 reputation = 17;
    int32 reputation_change_day = 18;
    int32 reputation_change_month = 19;
    int32 reputation_change_quarter = 20;
    int32 reputation_change_week = 21;
    int32 reputation_change_year = 22;
    int32 timed_penalty_date = 23;
    int32 up_vote_count = 24;
    int32 user_id = 25;
    string user_type = 26;
    int32 view_count = 27;
    string website_url = 28;
}
repeated User users = 1

message Write_permission {
    bool can_add = 1;
    bool can_delete = 2;
    bool can_edit = 3;
    int32 max_daily_actions = 4;
    int32 min_seconds_between_actions = 5;
    string object_type = 6;
    int32 user_id = 7;
}
repeated Write_permission write_permissions = 1

service StackExchangeService {
    // Reads the properties for a set of access tokens.
    //  
    // {accessTokens} can contain up to 20 access tokens. These are obtained by authenticating a user using OAuth 2.0.
    //  
    // This method returns a list of access_tokens.
    rpc GetAccessTokensAccessTokens(GetAccessTokensAccessTokensRequest) returns (Access_tokens) {
      option (google.api.http) = {
        get: "/2.0/access-tokens/{accessTokens}"
      };
    }
    // Immediately expires the access tokens passed. This method is meant to allow an application to discard any active access tokens it no longer needs.
    //  
    // {accessTokens} can contain up to 20 access tokens. These are obtained by authenticating a user using OAuth 2.0.
    //  
    // This method returns a list of access_tokens.
    rpc GetAccessTokensAccessTokensInvalidate(GetAccessTokensAccessTokensInvalidateRequest) returns (Access_tokens) {
      option (google.api.http) = {
        get: "/2.0/access-tokens/{accessTokens}/invalidate"
      };
    }
    // Returns all the undeleted answers in the system.
    //  
    // The sorts accepted by this method operate on the follow fields of the answer object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of answers.
    rpc GetAnswers(GetAnswersRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/answers"
      };
    }
    // Gets the set of answers identified by ids.
    //  
    // This is meant for batch fetcing of questions. A useful trick to poll for updates is to sort by activity, with a minimum date of the last time you polled.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the answer object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of answers.
    rpc GetAnswersIds(GetAnswersIdsRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/answers/{ids}"
      };
    }
    // Gets the comments on a set of answers.
    //  
    // If you know that you have an answer id and need the comments, use this method. If you know you have a question id, use /questions/{id}/comments. If you are unsure, use /posts/{id}/comments.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for answer_id on answer objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetAnswersIdsComments(GetAnswersIdsCommentsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/answers/{ids}/comments"
      };
    }
    // Passing valid access_tokens to this method causes the application that created them to be de-authorized by the user associated with each access_token. This will remove the application from their apps tab, and cause all other existing access_tokens to be destroyed.
    //  
    // This method is meant for uninstalling applications, recovering from access_token leaks, or simply as a stronger form of /access-tokens/{accessTokens}/invalidate.
    //  
    // Nothing prevents a user from re-authenticate to an application that has de-authenticated itself, the user will be prompted to approve the application again however.
    //  
    // {accessTokens} can contain up to 20 access tokens. These are obtained by authenticating a user using OAuth 2.0.
    //  
    // This method returns a list of access_tokens.
    rpc GetAppsAccessTokensDeAuthenticate(GetAppsAccessTokensDeAuthenticateRequest) returns (Access_tokens) {
      option (google.api.http) = {
        get: "/2.0/apps/{accessTokens}/de-authenticate"
      };
    }
    // Returns all the badges in the system.
    //  
    // Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.
    //  
    // This means that you can get a list of all tag based badges by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.
    //  
    // For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.
    //  
    // rank is the default sort.
    //  
    // This method returns a list of badges.
    rpc GetBadges(GetBadgesRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/badges"
      };
    }
    // Gets all explicitly named badges in the system.
    //  
    // A named badged stands in opposition to a tag-based badge. These are referred to as general badges on the sites themselves.
    //  
    // For the rank sort, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.
    //  
    // rank is the default sort.
    //  
    // This method returns a list of badges.
    rpc GetBadgesName(GetBadgesNameRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/badges/name"
      };
    }
    // Returns recently awarded badges in the system.
    //  
    // As these badges have been awarded, they will have the badge.user property set.
    //  
    // This method returns a list of badges.
    rpc GetBadgesRecipients(GetBadgesRecipientsRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/badges/recipients"
      };
    }
    // Returns the badges that are awarded for participation in specific tags.
    //  
    // For the rank sort, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.
    //  
    // rank is the default sort.
    //  
    // This method returns a list of badges.
    rpc GetBadgesTags(GetBadgesTagsRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/badges/tags"
      };
    }
    // Gets the badges identified in id.
    //  
    // Note that badge ids are not constant across sites, and thus should be looked up via the /badges method. A badge id on a single site is, however, guaranteed to be stable.
    //  
    // Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.
    //  
    // This means that you can get a list of all tag based badges by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.
    //  
    // For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.
    //  
    // rank is the default sort.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for badge_id on badge objects.
    //  
    // This method returns a list of badges.
    rpc GetBadgesIds(GetBadgesIdsRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/badges/{ids}"
      };
    }
    // Returns recently awarded badges in the system, constrained to a certain set of badges.
    //  
    // As these badges have been awarded, they will have the badge.user property set.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for badge_id on badge objects.
    //  
    // This method returns a list of badges.
    rpc GetBadgesIdsRecipients(GetBadgesIdsRecipientsRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/badges/{ids}/recipients"
      };
    }
    // Gets all the comments on the site.
    //  
    // If you're filtering for interesting comments (by score, creation date, etc.) make use of the sort paramter with appropriate min and max values.
    //  
    // If you're looking to query conversations between users, instead use the /users/{ids}/mentioned and /users/{ids}/comments/{toid} methods.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetComments(GetCommentsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/comments"
      };
    }
    // Gets the comments identified in id.
    //  
    // This method is most useful if you have a cache of comment ids obtained through other means (such as /questions/{id}/comments) but suspect the data may be stale.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for comment_id on comment objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetCommentsIds(GetCommentsIdsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/comments/{ids}"
      };
    }
    // Deletes a comment.
    //  
    // Use an access_token with write_access to delete a comment.
    //  
    // In practice, this method will never return an object.
    rpc PostCommentsIdDelete(PostCommentsIdDeleteRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        post: "/2.0/comments/{id}/delete"
      };
    }
    // Edit an existing comment.
    //  
    // Use an access_token with write_access to edit an existing comment.
    //  
    // This method return the created comment.
    rpc PostCommentsIdEdit(PostCommentsIdEditRequest) returns (Created_comment) {
      option (google.api.http) = {
        post: "/2.0/comments/{id}/edit"
      };
    }
    // Returns the various error codes that can be produced by the API.
    //  
    // This method is provided for discovery, documentation, and testing purposes, it is not expected many applications will consume it during normal operation.
    //  
    // For testing purposes, look into the /errors/{id} method which simulates errors given a code.
    //  
    // This method returns a list of errors.
    rpc GetErrors(GetErrorsRequest) returns (Errors) {
      option (google.api.http) = {
        get: "/2.0/errors"
      };
    }
    // This method allows you to generate an error.
    //  
    // This method is only intended for use when testing an application or library. Unlike other methods in the API, its contract is not frozen, and new error codes may be added at any time.
    //  
    // This method results in an error, which will be expressed with a 400 HTTP status code and setting the error* properties on the wrapper object.
    rpc GetErrorsId(GetErrorsIdRequest) returns (Error) {
      option (google.api.http) = {
        get: "/2.0/errors/{id}"
      };
    }
    // Returns a stream of events that have occurred on the site.
    //  
    // The API considers the following "events":
    //  - posting a question
    //  - posting an answer
    //  - posting a comment
    //  - editing a post
    //  - creating a user
    //   
    //  
    // Events are only accessible for 15 minutes after they occurred, and by default only events in the last 5 minutes are returned. You can specify the age of the oldest event returned by setting the since parameter.
    //  
    // It is advised that developers batch events by ids and make as few subsequent requests to other methods as possible.
    //  
    // This method returns a list of events.
    rpc GetEvents(GetEventsRequest) returns (Events) {
      option (google.api.http) = {
        get: "/2.0/events"
      };
    }
    // Creates a new filter given a list of includes, excludes, a base filter, and whether or not this filter should be "unsafe".
    //  
    // Filter "safety" is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.
    //  
    // If no base filter is specified, the default filter is assumed. When building a filter from scratch, the none built-in filter is useful.
    //  
    // When the size of the parameters being sent to this method grows to large, problems can occur. This method will accept POST requests to mitigate this.
    //  
    // It is not expected that many applications will call this method at runtime, filters should be pre-calculated and "baked in" in the common cases. Furthermore, there are a number of built-in filters which cover common use cases.
    //  
    // This method returns a single filter.
    rpc GetFiltersCreate(GetFiltersCreateRequest) returns (Single_filter) {
      option (google.api.http) = {
        get: "/2.0/filters/create"
      };
    }
    // Returns the fields included by the given filters, and the "safeness" of those filters.
    //  
    // It is not expected that this method will be consumed by many applications at runtime, it is provided to aid in debugging.
    //  
    // {filters} can contain up to 20 semicolon delimited filters. Filters are obtained via calls to /filters/create, or by using a built-in filter.
    //  
    // This method returns a list of filters.
    rpc GetFiltersFilters(GetFiltersFiltersRequest) returns (Filters) {
      option (google.api.http) = {
        get: "/2.0/filters/{filters}"
      };
    }
    // Returns a user's inbox.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of inbox items.
    rpc GetInbox(GetInboxRequest) returns (Inbox_items) {
      option (google.api.http) = {
        get: "/2.0/inbox"
      };
    }
    // Returns the unread items in a user's inbox.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of inbox items.
    rpc GetInboxUnread(GetInboxUnreadRequest) returns (Inbox_items) {
      option (google.api.http) = {
        get: "/2.0/inbox/unread"
      };
    }
    // Returns a collection of statistics about the site.
    //  
    // Data to facilitate per-site customization, discover related sites, and aggregate statistics is all returned by this method.
    //  
    // This data is cached very aggressively, by design. Query sparingly, ideally no more than once an hour.
    //  
    // This method returns an info object.
    rpc GetInfo(GetInfoRequest) returns (Info_object) {
      option (google.api.http) = {
        get: "/2.0/info"
      };
    }
    // Returns the user associated with the passed access_token.
    //  
    // This method returns a user.
    rpc GetMe(GetMeRequest) returns (User) {
      option (google.api.http) = {
        get: "/2.0/me"
      };
    }
    // Returns the answers owned by the user associated with the given access_token.
    //  
    // This method returns a list of answers.
    rpc GetMeAnswers(GetMeAnswersRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/me/answers"
      };
    }
    // Returns all of a user's associated accounts, given an access_token for them.
    //  
    // This method returns a list of network users.
    rpc GetMeAssociated(GetMeAssociatedRequest) returns (Network_users) {
      option (google.api.http) = {
        get: "/2.0/me/associated"
      };
    }
    // Returns the badges earned by the user associated with the given access_token.
    //  
    // This method returns a list of badges.
    rpc GetMeBadges(GetMeBadgesRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/me/badges"
      };
    }
    // Returns the comments owned by the user associated with the given access_token.
    //  
    // This method returns a list of comments.
    rpc GetMeComments(GetMeCommentsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/me/comments"
      };
    }
    // Returns the comments owned by the user associated with the given access_token that are in reply to the user identified by {toId}.
    //  
    // This method returns a list of comments.
    rpc GetMeCommentsToId(GetMeCommentsToIdRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/me/comments/{toId}"
      };
    }
    // Returns the questions favorites by the user associated with the given access_token.
    //  
    // This method returns a list of questions.
    rpc GetMeFavorites(GetMeFavoritesRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/favorites"
      };
    }
    // Returns the user identified by access_token's inbox.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of inbox items.
    rpc GetMeInbox(GetMeInboxRequest) returns (Inbox_items) {
      option (google.api.http) = {
        get: "/2.0/me/inbox"
      };
    }
    // Returns the unread items in the user identified by access_token's inbox.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of inbox items.
    rpc GetMeInboxUnread(GetMeInboxUnreadRequest) returns (Inbox_items) {
      option (google.api.http) = {
        get: "/2.0/me/inbox/unread"
      };
    }
    // Returns the comments mentioning the user associated with the given access_token.
    //  
    // This method returns a list of comments.
    rpc GetMeMentioned(GetMeMentionedRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/me/mentioned"
      };
    }
    // Returns a record of merges that have occurred involving a user identified by an access_token.
    //  
    // This method allows you to take now invalid account ids and find what account they've become, or take currently valid account ids and find which ids were equivalent in the past.
    //  
    // This is most useful when confirming that an account_id is in fact "new" to an application.
    //  
    // Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.
    //  
    // Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.
    //  
    // This method returns a list of account_merge.
    rpc GetMeMerges(GetMeMergesRequest) returns (Account_merge) {
      option (google.api.http) = {
        get: "/2.0/me/merges"
      };
    }
    // Returns a user's notifications, given an access_token.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of notifications.
    rpc GetMeNotifications(GetMeNotificationsRequest) returns (Notifications) {
      option (google.api.http) = {
        get: "/2.0/me/notifications"
      };
    }
    // Returns a user's unread notifications, given an access_token.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of notifications.
    rpc GetMeNotificationsUnread(GetMeNotificationsUnreadRequest) returns (Notifications) {
      option (google.api.http) = {
        get: "/2.0/me/notifications/unread"
      };
    }
    // Returns the privileges the user identified by access_token has.
    //  
    // This method returns a list of privileges.
    rpc GetMePrivileges(GetMePrivilegesRequest) returns (Privileges) {
      option (google.api.http) = {
        get: "/2.0/me/privileges"
      };
    }
    // Returns the questions owned by the user associated with the given access_token.
    //  
    // This method returns a list of questions.
    rpc GetMeQuestions(GetMeQuestionsRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/questions"
      };
    }
    // Returns the questions that have active bounties offered by the user associated with the given access_token.
    //  
    // This method returns a list of questions.
    rpc GetMeQuestionsFeatured(GetMeQuestionsFeaturedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/questions/featured"
      };
    }
    // Returns the questions owned by the user associated with the given access_token that have no answers.
    //  
    // This method returns a list of questions.
    rpc GetMeQuestionsNoAnswers(GetMeQuestionsNoAnswersRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/questions/no-answers"
      };
    }
    // Returns the questions owned by the user associated with the given access_token that have no accepted answer.
    //  
    // This method returns a list of questions.
    rpc GetMeQuestionsUnaccepted(GetMeQuestionsUnacceptedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/questions/unaccepted"
      };
    }
    // Returns the questions owned by the user associated with the given access_token that are not considered answered.
    //  
    // This method returns a list of questions.
    rpc GetMeQuestionsUnanswered(GetMeQuestionsUnansweredRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/questions/unanswered"
      };
    }
    // Returns the reputation changed for the user associated with the given access_token.
    //  
    // This method returns a list of reputation changes.
    rpc GetMeReputation(GetMeReputationRequest) returns (Reputation_changes) {
      option (google.api.http) = {
        get: "/2.0/me/reputation"
      };
    }
    // Returns user's public reputation history.
    //  
    // This method returns a list of reputation_history.
    rpc GetMeReputationHistory(GetMeReputationHistoryRequest) returns (Reputation_history) {
      option (google.api.http) = {
        get: "/2.0/me/reputation-history"
      };
    }
    // Returns user's full reputation history, including private events.
    //  
    //  This method requires an access_token, with a scope containing "private_info".
    //  
    // This method returns a list of reputation_history.
    rpc GetMeReputationHistoryFull(GetMeReputationHistoryFullRequest) returns (Reputation_history) {
      option (google.api.http) = {
        get: "/2.0/me/reputation-history/full"
      };
    }
    // Returns the suggested edits the user identified by access_token has submitted.
    //  
    // This method returns a list of suggested-edits.
    rpc GetMeSuggestedEdits(GetMeSuggestedEditsRequest) returns (Suggested-Edits) {
      option (google.api.http) = {
        get: "/2.0/me/suggested-edits"
      };
    }
    // Returns the tags the user identified by the access_token passed is active in.
    //  
    // This method returns a list of tags.
    rpc GetMeTags(GetMeTagsRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/me/tags"
      };
    }
    // Returns the top 30 answers the user associated with the given access_token has posted in response to questions with the given tags.
    //  
    // This method returns a list of answers.
    rpc GetMeTagsTagsTopAnswers(GetMeTagsTagsTopAnswersRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/me/tags/{tags}/top-answers"
      };
    }
    // Returns the top 30 questions the user associated with the given access_token has posted in response to questions with the given tags.
    //  
    // This method returns a list of questions.
    rpc GetMeTagsTagsTopQuestions(GetMeTagsTagsTopQuestionsRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/me/tags/{tags}/top-questions"
      };
    }
    // Returns a subset of the actions the user identified by the passed access_token has taken on the site.
    //  
    // This method returns a list of user timeline objects.
    rpc GetMeTimeline(GetMeTimelineRequest) returns (User_timeline_objects) {
      option (google.api.http) = {
        get: "/2.0/me/timeline"
      };
    }
    // Returns the user identified by access_token's top 30 tags by answer score.
    //  
    // This method returns a list of top tag objects.
    rpc GetMeTopAnswerTags(GetMeTopAnswerTagsRequest) returns (Top_tag_objects) {
      option (google.api.http) = {
        get: "/2.0/me/top-answer-tags"
      };
    }
    // Returns the user identified by access_token's top 30 tags by question score.
    //  
    // This method returns a list of top tag objects.
    rpc GetMeTopQuestionTags(GetMeTopQuestionTagsRequest) returns (Top_tag_objects) {
      option (google.api.http) = {
        get: "/2.0/me/top-question-tags"
      };
    }
    // Returns the write permissions a user has via the api, given an access token.
    //  
    // The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.
    //  
    // This method does not consider the user's current quota (ie. if they've already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.
    //  
    // This method returns a list of write_permissions.
    rpc GetMeWritePermissions(GetMeWritePermissionsRequest) returns (Write_permissions) {
      option (google.api.http) = {
        get: "/2.0/me/write-permissions"
      };
    }
    // Returns a user's notifications.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of notifications.
    rpc GetNotifications(GetNotificationsRequest) returns (Notifications) {
      option (google.api.http) = {
        get: "/2.0/notifications"
      };
    }
    // Returns a user's unread notifications.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of notifications.
    rpc GetNotificationsUnread(GetNotificationsUnreadRequest) returns (Notifications) {
      option (google.api.http) = {
        get: "/2.0/notifications/unread"
      };
    }
    // Fetches all posts (questions and answers) on the site.
    //  
    // In many ways this method is the union of /questions and /answers, returning both sets of data albeit only the common fields.
    //  
    // Most applications should use the question or answer specific methods, but /posts is available for those rare cases where any activity is of intereset. Examples of such queries would be: "all posts on Jan. 1st 2011" or "top 10 posts by score of all time".
    //  
    // The sorts accepted by this method operate on the follow fields of the post object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of posts.
    rpc GetPosts(GetPostsRequest) returns (Posts) {
      option (google.api.http) = {
        get: "/2.0/posts"
      };
    }
    // Fetches a set of posts by ids.
    //  
    // This method is meant for grabbing an object when unsure whether an id identifies a question or an answer. This is most common with user entered data.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for post_id, answer_id, or question_id on post, answer, and question objects respectively.
    //  
    // The sorts accepted by this method operate on the follow fields of the post object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of posts.
    rpc GetPostsIds(GetPostsIdsRequest) returns (Posts) {
      option (google.api.http) = {
        get: "/2.0/posts/{ids}"
      };
    }
    // Gets the comments on the posts identified in ids, regardless of the type of the posts.
    //  
    // This method is meant for cases when you are unsure of the type of the post id provided. Generally, this would be due to obtaining the post id directly from a user.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for post_id, answer_id, or question_id on post, answer, and question objects respectively.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetPostsIdsComments(GetPostsIdsCommentsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/posts/{ids}/comments"
      };
    }
    // Returns edit revisions for the posts identified in ids.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for post_id, answer_id, or question_id on post, answer, and question objects respectively.
    //  
    // This method returns a list of revisions.
    rpc GetPostsIdsRevisions(GetPostsIdsRevisionsRequest) returns (Revisions) {
      option (google.api.http) = {
        get: "/2.0/posts/{ids}/revisions"
      };
    }
    // Returns suggsted edits on the posts identified in ids.
    //  
    //  - creation - creation_date
    //  - approval - approval_date
    //  - rejection - rejection_date
    //   creation is the default sort.
    //  
    //  {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for post_id, answer_id, or question_id on post, answer, and question objects respectively.
    //  
    // This method returns a list of suggested-edits.
    rpc GetPostsIdsSuggestedEdits(GetPostsIdsSuggestedEditsRequest) returns (Suggested-Edits) {
      option (google.api.http) = {
        get: "/2.0/posts/{ids}/suggested-edits"
      };
    }
    // Create a new comment.
    //  
    // Use an access_token with write_access to create a new comment on a post.
    //  
    // This method returns the created comment.
    rpc PostPostsIdCommentsAdd(PostPostsIdCommentsAddRequest) returns (Created_comment) {
      option (google.api.http) = {
        post: "/2.0/posts/{id}/comments/add"
      };
    }
    // Returns the earnable privileges on a site.
    //  
    // Privileges define abilities a user can earn (via reputation) on any Stack Exchange site.
    //  
    // While fairly stable, over time they do change. New ones are introduced with new features, and the reputation requirements change as a site matures.
    //  
    // This method returns a list of privileges.
    rpc GetPrivileges(GetPrivilegesRequest) returns (Privileges) {
      option (google.api.http) = {
        get: "/2.0/privileges"
      };
    }
    // Gets all the questions on the site.
    //  
    // This method allows you make fairly flexible queries across the entire corpus of questions on a site. For example, getting all questions asked in the the week of Jan 1st 2011 with scores of 10 or more is a single query with parameters sort=votes&min=10&fromdate=1293840000&todate=1294444800.
    //  
    // To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - hot - by the formula ordering the hot tab Does not accept min or max
    //  - week - by the formula ordering the week tab Does not accept min or max
    //  - month - by the formula ordering the month tab Does not accept min or max
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestions(GetQuestionsRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions"
      };
    }
    // Returns all the questions with active bounties in the system.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestionsFeatured(GetQuestionsFeaturedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions/featured"
      };
    }
    // Returns questions which have received no answers.
    //  
    // Compare with /questions/unanswered which mearly returns questions that the sites consider insufficiently well answered.
    //  
    // This method corresponds roughly with the this site tab.
    //  
    // To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestionsNoAnswers(GetQuestionsNoAnswersRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions/no-answers"
      };
    }
    // Returns questions the site considers to be unanswered.
    //  
    // Note that just because a question has an answer, that does not mean it is considered answered. While the rules are subject to change, at this time a question must have at least one upvoted answer to be considered answered.
    //  
    // To constrain questions returned to those with a set of tags, use the tagged parameter with a semi-colon delimited list of tags. This is an and contraint, passing tagged=c;java will return only those questions with both tags. As such, passing more than 5 tags will always return zero results.
    //  
    // Compare with /questions/no-answers.
    //  
    // This method corresponds roughly with the unanswered tab.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestionsUnanswered(GetQuestionsUnansweredRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions/unanswered"
      };
    }
    // Returns the questions identified in {ids}.
    //  
    // This is most useful for fetching fresh data when maintaining a cache of question ids, or polling for changes.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestionsIds(GetQuestionsIdsRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions/{ids}"
      };
    }
    // Gets the answers to a set of questions identified in id.
    //  
    // This method is most useful if you have a set of interesting questions, and you wish to obtain all of their answers at once or if you are polling for new or updates answers (in conjunction with sort=activity).
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the answer object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of answers.
    rpc GetQuestionsIdsAnswers(GetQuestionsIdsAnswersRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/questions/{ids}/answers"
      };
    }
    // Gets the comments on a question.
    //  
    // If you know that you have an question id and need the comments, use this method. If you know you have a answer id, use /answers/{ids}/comments. If you are unsure, use /posts/{ids}/comments.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetQuestionsIdsComments(GetQuestionsIdsCommentsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/questions/{ids}/comments"
      };
    }
    // Gets questions which link to those questions identified in {ids}.
    //  
    // This method only considers questions that are linked within a site, and will never return questions from another Stack Exchange site.
    //  
    // A question is considered "linked" when it explicitly includes a hyperlink to another question, there are no other heuristics.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - rank - a priority sort by site applies, subject to change at any time Does not accept min or max
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestionsIdsLinked(GetQuestionsIdsLinkedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions/{ids}/linked"
      };
    }
    // Returns questions that the site considers related to those identified in {ids}.
    //  
    // The algorithm for determining if questions are related is not documented, and subject to change at any time. Futhermore, these values are very heavily cached, and may not update immediately after a question has been editted. It is also not guaranteed that a question will be considered related to any number (even non-zero) of questions, and a consumer should be able to handle a variable number of returned questions.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - rank - a priority sort by site applies, subject to change at any time Does not accept min or max
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetQuestionsIdsRelated(GetQuestionsIdsRelatedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/questions/{ids}/related"
      };
    }
    // Returns a subset of the events that have happened to the questions identified in id.
    //  
    // This provides data similar to that found on a question's timeline page.
    //  
    // Voting data is scrubbed to deter inferencing of voter identity.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.
    //  
    // This method returns a list of question timeline events.
    rpc GetQuestionsIdsTimeline(GetQuestionsIdsTimelineRequest) returns (Question_timeline_events) {
      option (google.api.http) = {
        get: "/2.0/questions/{ids}/timeline"
      };
    }
    // Returns edit revisions identified by ids in {ids}.
    //  
    // {ids} can contain up to 20 semicolon delimited ids, to find ids programatically look for revision_guid on revision objects. Note that unlike most other id types in the API, revision_guid is a string.
    //  
    // This method returns a list of revisions.
    rpc GetRevisionsIds(GetRevisionsIdsRequest) returns (Revisions) {
      option (google.api.http) = {
        get: "/2.0/revisions/{ids}"
      };
    }
    // Searches a site for any questions which fit the given criteria.
    //  
    // This method is intentionally quite limited. For more general searching, you should use a proper internet search engine restricted to the domain of the site in question.
    //  
    // At least one of tagged or intitle must be set on this method. nottagged is only used if tagged is also set, for performance reasons.
    //  
    // tagged and nottagged are semi-colon delimited list of tags. At least 1 tag in tagged will be on each returned question if it is passed, making it the OR equivalent of the AND version of tagged on /questions.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - relevance - matches the relevance tab on the site itself Does not accept min or max
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetSearch(GetSearchRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/search"
      };
    }
    // Searches a site for any questions which fit the given criteria.
    //  
    // Search criteria are expressed using the following parameters:
    //   - q - a free form text parameter, will match all question properties based on an undocumented algorithm.
    //  - accepted - true to return only questions with accepted answers, false to return only those without. Omit to elide constraint.
    //  - answers - the minimum number of answers returned questions must have.
    //  - body - text which must appear in returned questions' bodies.
    //  - closed - true to return only closed questions, false to return only open ones. Omit to elide constraint.
    //  - migrated - true to return only questions migrated away from a site, false to return only those not. Omit to elide constraint.
    //  - notice - true to return only questions with post notices, false to return only those without. Omit to elide constraint.
    //  - nottagged - a semicolon delimited list of tags, none of which will be present on returned questions.
    //  - tagged - a semicolon delimited list of tags, of which at least one will be present on all returned questions.
    //  - title - text which must appear in returned questions' titles.
    //  - user - the id of the user who must own the questions returned.
    //  - url - a url which must be contained in a post, may include a wildcard.
    //  - views - the minimum number of views returned questions must have.
    //  - wiki - true to return only community wiki questions, false to return only non-community wiki ones. Omit to elide constraint.
    //   
    // At least one additional parameter must be set if nottagged is set, for performance reasons.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - relevance - matches the relevance tab on the site itself Does not accept min or max
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetSearchAdvanced(GetSearchAdvancedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/search/advanced"
      };
    }
    // Returns questions which are similar to a hypothetical one based on a title and tag combination.
    //  
    // This method is roughly equivalent to a site's related questions suggestion on the ask page.
    //  
    // This method is useful for correlating data outside of a Stack Exchange site with similar content within one.
    //  
    // Note that title must always be passed as a parameter. tagged and nottagged are optional, semi-colon delimited lists of tags.
    //  
    // If tagged is passed it is treated as a preference, there is no guarantee that questions returned will have any of those tags. nottagged is treated as a requirement, no questions will be returned with those tags.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - relevance - order by "how similar" the questions are, most likely candidate first with a descending order Does not accept min or max
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetSimilar(GetSimilarRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/similar"
      };
    }
    // Returns all sites in the network.
    //  
    // This method allows for discovery of new sites, and changes to existing ones. Be aware that unlike normal API methods, this method should be fetched very infrequently, it is very unusual for these values to change more than once on any given day. It is suggested that you cache its return for at least one day, unless your app encounters evidence that it has changed (such as from the /info method).
    //  
    // The pagesize parameter for this method is unbounded, in acknowledgement that for many applications repeatedly fetching from /sites would complicate start-up tasks needlessly.
    //  
    // This method returns a list of sites.
    rpc GetSites(GetSitesRequest) returns (Sites) {
      option (google.api.http) = {
        get: "/2.0/sites"
      };
    }
    // Returns all the suggested edits in the systems.
    //  
    // This method returns a list of suggested-edits.
    //  
    // The sorts accepted by this method operate on the follow fields of the suggested_edit object:
    //  - creation - creation_date
    //  - approval - approval_date Does not return unapproved suggested_edits
    //  - rejection - rejection_date Does not return unrejected suggested_edits
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    rpc GetSuggestedEdits(GetSuggestedEditsRequest) returns (Suggested-Edits) {
      option (google.api.http) = {
        get: "/2.0/suggested-edits"
      };
    }
    // Returns suggested edits identified in ids.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for suggested_edit_id on suggested_edit objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the suggested_edit object:
    //  - creation - creation_date
    //  - approval - approval_date Does not return unapproved suggested_edits
    //  - rejection - rejection_date Does not return unrejected suggested_edits
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of suggested-edits.
    rpc GetSuggestedEditsIds(GetSuggestedEditsIdsRequest) returns (Suggested-Edits) {
      option (google.api.http) = {
        get: "/2.0/suggested-edits/{ids}"
      };
    }
    // Returns the tags found on a site.
    //  
    // The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both "download" and "owner" amongst others.
    //  
    // This method returns a list of tags.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag object:
    //  - popular - count
    //  - activity - the creation_date of the last question asked with the tag
    //  - name - name
    //   popular is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    rpc GetTags(GetTagsRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/tags"
      };
    }
    // Returns the tags found on a site that only moderators can use.
    //  
    // The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both "download" and "owner" amongst others.
    //  
    // This method returns a list of tags.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag object:
    //  - popular - count
    //  - activity - the creation_date of the last question asked with the tag
    //  - name - name
    //   popular is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    rpc GetTagsModeratorOnly(GetTagsModeratorOnlyRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/tags/moderator-only"
      };
    }
    // Returns the tags found on a site that fulfill required tag constraints on questions.
    //  
    // The inname parameter lets a consumer filter down to tags that contain a certain substring. For example, inname=own would return both "download" and "owner" amongst others.
    //  
    // This method returns a list of tags.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag object:
    //  - popular - count
    //  - activity - the creation_date of the last question asked with the tag
    //  - name - name
    //   popular is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    rpc GetTagsRequired(GetTagsRequiredRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/tags/required"
      };
    }
    // Returns all tag synonyms found a site.
    //  
    // When searching for synonyms of specific tags, it is better to use /tags/{tags}/synonyms over this method.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag_synonym object:
    //  - creation - creation_date
    //  - applied - applied_count
    //  - activity - last_applied_date
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of tag_synonyms.
    rpc GetTagsSynonyms(GetTagsSynonymsRequest) returns (Tag_synonyms) {
      option (google.api.http) = {
        get: "/2.0/tags/synonyms"
      };
    }
    // Returns the frequently asked questions for the given set of tags in {tags}.
    //  
    // For a question to be returned, it must have all the tags in {tags} and be considered "frequently asked". The exact algorithm for determining whether a question is considered a FAQ is subject to change at any time.
    //  
    // {tags} can contain up to 5 individual tags per request.
    //  
    // This method returns a list of questions.
    rpc GetTagsTagsFaq(GetTagsTagsFaqRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/tags/{tags}/faq"
      };
    }
    // Returns tag objects representing the tags in {tags} found on the site.
    //  
    // This method diverges from the standard naming patterns to avoid to conflicting with existing methods, due to the free form nature of tag names.
    //  
    // This method returns a list of tags.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag object:
    //  - popular - count
    //  - activity - the creation_date of the last question asked with the tag
    //  - name - name
    //   popular is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    rpc GetTagsTagsInfo(GetTagsTagsInfoRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/tags/{tags}/info"
      };
    }
    // Returns the tags that are most related to those in {tags}.
    //  
    // Including multiple tags in {tags} is equivalent to asking for "tags related to tag #1 and tag #2" not "tags related to tag #1 or tag #2".
    //  
    // count on tag objects returned is the number of question with that tag that also share all those in {tags}.
    //  
    // {tags} can contain up to 4 individual tags per request.
    //  
    // This method returns a list of tags.
    rpc GetTagsTagsRelated(GetTagsTagsRelatedRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/tags/{tags}/related"
      };
    }
    // Gets all the synonyms that point to the tags identified in {tags}. If you're looking to discover all the tag synonyms on a site, use the /tags/synonyms methods instead of call this method on all tags.
    //  
    // {tags} can contain up to 20 individual tags per request.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag_synonym object:
    //  - creation - creation_date
    //  - applied - applied_count
    //  - activity - last_applied_date
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of tag synonyms.
    rpc GetTagsTagsSynonyms(GetTagsTagsSynonymsRequest) returns (Tag_synonyms) {
      option (google.api.http) = {
        get: "/2.0/tags/{tags}/synonyms"
      };
    }
    // Returns the wikis that go with the given set of tags in {tags}.
    //  
    // Be aware that not all tags have wikis.
    //  
    // {tags} can contain up to 20 individual tags per request.
    //  
    // This method returns a list of tag wikis.
    rpc GetTagsTagsWikis(GetTagsTagsWikisRequest) returns (Tag_wikis) {
      option (google.api.http) = {
        get: "/2.0/tags/{tags}/wikis"
      };
    }
    // Returns the top 30 answerers active in a single tag, of either all-time or the last 30 days.
    //  
    // This is a view onto the data presented on the tag info page on the sites.
    //  
    // This method returns a list of tag score objects.
    rpc GetTagsTagTopAnswerersPeriod(GetTagsTagTopAnswerersPeriodRequest) returns (Tag_score_objects) {
      option (google.api.http) = {
        get: "/2.0/tags/{tag}/top-answerers/{period}"
      };
    }
    // Returns the top 30 askers active in a single tag, of either all-time or the last 30 days.
    //  
    // This is a view onto the data presented on the tag info page on the sites.
    //  
    // This method returns a list of tag score objects.
    rpc GetTagsTagTopAskersPeriod(GetTagsTagTopAskersPeriodRequest) returns (Tag_score_objects) {
      option (google.api.http) = {
        get: "/2.0/tags/{tag}/top-askers/{period}"
      };
    }
    // Returns all users on a site.
    //  
    // This method returns a list of users.
    //  
    // The sorts accepted by this method operate on the follow fields of the user object:
    //  - reputation - reputation
    //  - creation - creation_date
    //  - name - display_name
    //  - modified - last_modified_date
    //   reputation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname=kevin will return all users with both users named simply "Kevin" or those with Kevin as one of (or part of) their names; such as "Kevin Montrose".
    rpc GetUsers(GetUsersRequest) returns (Users) {
      option (google.api.http) = {
        get: "/2.0/users"
      };
    }
    // Gets those users on a site who can exercise moderation powers.
    //  
    // Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.
    //  
    // The sorts accepted by this method operate on the follow fields of the user object:
    //  - reputation - reputation
    //  - creation - creation_date
    //  - name - display_name
    //  - modified - last_modified_date
    //   reputation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of users.
    rpc GetUsersModerators(GetUsersModeratorsRequest) returns (Users) {
      option (google.api.http) = {
        get: "/2.0/users/moderators"
      };
    }
    // Returns those users on a site who both have moderator powers, and were actually elected.
    //  
    // This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).
    //  
    // The sorts accepted by this method operate on the follow fields of the user object:
    //  - reputation - reputation
    //  - creation - creation_date
    //  - name - display_name
    //  - modified - last_modified_date
    //   reputation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of users.
    rpc GetUsersModeratorsElected(GetUsersModeratorsElectedRequest) returns (Users) {
      option (google.api.http) = {
        get: "/2.0/users/moderators/elected"
      };
    }
    // Gets the users identified in ids in {ids}.
    //  
    // Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the user object:
    //  - reputation - reputation
    //  - creation - creation_date
    //  - name - display_name
    //  - modified - last_modified_date
    //   reputation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of users.
    rpc GetUsersIds(GetUsersIdsRequest) returns (Users) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}"
      };
    }
    // Returns the answers the users in {ids} have posted.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the answer object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of answers.
    rpc GetUsersIdsAnswers(GetUsersIdsAnswersRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/answers"
      };
    }
    // Returns all of a user's associated accounts, given their account_ids in {ids}.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.
    //  
    // This method returns a list of network_users.
    rpc GetUsersIdsAssociated(GetUsersIdsAssociatedRequest) returns (Network_users) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/associated"
      };
    }
    // Get the badges the users in {ids} have earned.
    //  
    // Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.
    //  
    // This means that you can get a list of all tag based badges a user has by passing min=tag_based, and conversely all the named badges by passing max=named, with sort=type.
    //  
    // For ranks, bronze is greater than silver which is greater than gold. Along with sort=rank, set max=gold for just gold badges, max=silver&min=silver for just silver, and min=bronze for just bronze.
    //  
    // rank is the default sort.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of badges.
    rpc GetUsersIdsBadges(GetUsersIdsBadgesRequest) returns (Badges) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/badges"
      };
    }
    // Get the comments posted by users in {ids}.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetUsersIdsComments(GetUsersIdsCommentsRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/comments"
      };
    }
    // Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.
    //  
    // This method is useful for extracting conversations, especially over time or across multiple posts.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetUsersIdsCommentsToid(GetUsersIdsCommentsToidRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/comments/{toid}"
      };
    }
    // Get the questions that users in {ids} have favorited.
    //  
    // This method is effectively a view onto a user's favorites tab.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //  - added - when the user favorited the question
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdsFavorites(GetUsersIdsFavoritesRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/favorites"
      };
    }
    // Gets all the comments that the users in {ids} were mentioned in.
    //  
    // Note, to count as a mention the comment must be considered to be "in reply to" a user. Most importantly, this means that a comment can only be in reply to a single user.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the comment object:
    //  - creation - creation_date
    //  - votes - score
    //   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of comments.
    rpc GetUsersIdsMentioned(GetUsersIdsMentionedRequest) returns (Comments) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/mentioned"
      };
    }
    // Returns a record of merges that have occurred involving the passed account ids.
    //  
    // This method allows you to take now invalid account ids and find what account they've become, or take currently valid account ids and find which ids were equivalent in the past.
    //  
    // This is most useful when confirming that an account_id is in fact "new" to an application.
    //  
    // Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.
    //  
    // Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.
    //  
    // This method returns a list of account_merge.
    rpc GetUsersIdsMerges(GetUsersIdsMergesRequest) returns (Account_merge) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/merges"
      };
    }
    // Gets the questions asked by the users in {ids}.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdsQuestions(GetUsersIdsQuestionsRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/questions"
      };
    }
    // Gets the questions on which the users in {ids} have active bounties.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdsQuestionsFeatured(GetUsersIdsQuestionsFeaturedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/questions/featured"
      };
    }
    // Gets the questions asked by the users in {ids} which have no answers.
    //  
    // Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdsQuestionsNoAnswers(GetUsersIdsQuestionsNoAnswersRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/questions/no-answers"
      };
    }
    // Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.
    //  
    // Questions returned by this method have answers, but the owner has not opted to accept any of them.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdsQuestionsUnaccepted(GetUsersIdsQuestionsUnacceptedRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/questions/unaccepted"
      };
    }
    // Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.
    //  
    // These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.
    //  
    // To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdsQuestionsUnanswered(GetUsersIdsQuestionsUnansweredRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/questions/unanswered"
      };
    }
    // Gets a subset of the reputation changes for users in {ids}.
    //  
    // Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of reputation objects.
    rpc GetUsersIdsReputation(GetUsersIdsReputationRequest) returns (Reputation_changes) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/reputation"
      };
    }
    // Returns users' public reputation history.
    //  
    // This method returns a list of reputation_history.
    rpc GetUsersIdsReputationHistory(GetUsersIdsReputationHistoryRequest) returns (Reputation_history) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/reputation-history"
      };
    }
    // Returns the suggested edits a users in {ids} have submitted.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the suggested_edit object:
    //  - creation - creation_date
    //  - approval - approval_date Does not return unapproved suggested_edits
    //  - rejection - rejection_date Does not return unrejected suggested_edits
    //   creation is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of suggested-edits.
    rpc GetUsersIdsSuggestedEdits(GetUsersIdsSuggestedEditsRequest) returns (Suggested-Edits) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/suggested-edits"
      };
    }
    // Returns the tags the users identified in {ids} have been active in.
    //  
    // This route corresponds roughly to user's stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // The sorts accepted by this method operate on the follow fields of the tag object:
    //  - popular - count
    //  - activity - the creation_date of the last question asked with the tag
    //  - name - name
    //   popular is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of tags.
    rpc GetUsersIdsTags(GetUsersIdsTagsRequest) returns (Tags) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/tags"
      };
    }
    // Returns a subset of the actions the users in {ids} have taken on the site.
    //  
    // This method returns users' posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.
    //  
    // {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of user timeline objects.
    rpc GetUsersIdsTimeline(GetUsersIdsTimelineRequest) returns (User_timeline_objects) {
      option (google.api.http) = {
        get: "/2.0/users/{ids}/timeline"
      };
    }
    // Returns a user's inbox.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.
    //  
    // {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of inbox items.
    rpc GetUsersIdInbox(GetUsersIdInboxRequest) returns (Inbox_items) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/inbox"
      };
    }
    // Returns the unread items in a user's inbox.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.
    //  
    // {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of inbox items.
    rpc GetUsersIdInboxUnread(GetUsersIdInboxUnreadRequest) returns (Inbox_items) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/inbox/unread"
      };
    }
    // Returns a user's notifications.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of notifications.
    rpc GetUsersIdNotifications(GetUsersIdNotificationsRequest) returns (Notifications) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/notifications"
      };
    }
    // Returns a user's unread notifications.
    //  
    // This method requires an access_token, with a scope containing "read_inbox".
    //  
    // This method returns a list of notifications.
    rpc GetUsersIdNotificationsUnread(GetUsersIdNotificationsUnreadRequest) returns (Notifications) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/notifications/unread"
      };
    }
    // Returns the privileges a user has.
    //  
    // Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.
    //  
    // {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of privileges.
    rpc GetUsersIdPrivileges(GetUsersIdPrivilegesRequest) returns (Privileges) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/privileges"
      };
    }
    // Returns a user's full reputation history, including private events.
    //  
    // This method requires an access_token, with a scope containing "private_info".
    //  
    // This method returns a list of reputation_history.
    rpc GetUsersIdReputationHistoryFull(GetUsersIdReputationHistoryFullRequest) returns (Reputation_history) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/reputation-history/full"
      };
    }
    // Returns the top 30 answers a user has posted in response to questions with the given tags.
    //  
    // {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.
    //  
    // The sorts accepted by this method operate on the follow fields of the answer object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of answers.
    rpc GetUsersIdTagsTagsTopAnswers(GetUsersIdTagsTagsTopAnswersRequest) returns (Answers) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/tags/{tags}/top-answers"
      };
    }
    // Returns the top 30 questions a user has asked with the given tags.
    //  
    // {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.
    //  
    // The sorts accepted by this method operate on the follow fields of the question object:
    //  - activity - last_activity_date
    //  - creation - creation_date
    //  - votes - score
    //   activity is the default sort.
    //  
    //  It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.
    //  
    // This method returns a list of questions.
    rpc GetUsersIdTagsTagsTopQuestions(GetUsersIdTagsTagsTopQuestionsRequest) returns (Questions) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/tags/{tags}/top-questions"
      };
    }
    // Returns a single user's top tags by answer score.
    //  
    // This a subset of the data returned on a user's tags tab.
    //  
    // {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of top_tag objects.
    rpc GetUsersIdTopAnswerTags(GetUsersIdTopAnswerTagsRequest) returns (Top_tag_objects) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/top-answer-tags"
      };
    }
    // Returns a single user's top tags by question score.
    //  
    // This a subset of the data returned on a user's tags tab.
    //  
    // {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.
    //  
    // This method returns a list of top_tag objects.
    rpc GetUsersIdTopQuestionTags(GetUsersIdTopQuestionTagsRequest) returns (Top_tag_objects) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/top-question-tags"
      };
    }
    // Returns the write permissions a user has via the api.
    //  
    // The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.
    //  
    // This method does not consider the user's current quota (ie. if they've already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.
    //  
    // This method returns a list of write_permissions.
    rpc GetUsersIdWritePermissions(GetUsersIdWritePermissionsRequest) returns (Write_permissions) {
      option (google.api.http) = {
        get: "/2.0/users/{id}/write-permissions"
      };
    }
}
