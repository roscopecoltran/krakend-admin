syntax = "proto3";

import "google/protobuf/empty.proto";

import "google/api/annotations.proto";

package transportforlondonunified;

message GetAccidentStatsYearRequest {
    // The year for which to filter the accidents on.
    int32 year = 1;
}

message GetAccidentStatsYearResponse {
    repeated AccidentDetail items = 1;
}

message GetBikePointResponse {
    repeated Place items = 1;
}

message GetBikePointSearchRequest {
    // The search term e.g. "St. James"
    string query = 1;
}

message GetBikePointSearchResponse {
    repeated Place items = 1;
}

message GetBikePointIdRequest {
    // A bike point id (a list of ids can be obtained from the above BikePoint call)
    string id = 1;
}

message GetCabwiseSearchRequest {
    // Force Xml
    bool forceXml = 1;
    // Latitude
    double lat = 2;
    // Legacy Format
    bool legacyFormat = 3;
    // Longitude
    double lon = 4;
    // An optional parameter to limit the number of results return. Default and maximum is 20.
    int32 maxResults = 5;
    // Trading name of operating company
    string name = 6;
    // Operator Type e.g Minicab, Executive, Limousine
    string optype = 7;
    // The radius of the bounding circle in metres
    double radius = 8;
    // Twenty Four Seven Only
    bool twentyFourSevenOnly = 9;
    // Wheelchair accessible
    string wc = 10;
}

message GetJourneyJourneyResultsFromToToRequest {
    // The accessibility preference must be a comma separated list eg. "noSolidStairs,noEscalators,noElevators,stepFreeToVehicle,stepFreeToPlatform"
    repeated string accessibilityPreference = 1;
    // Time adjustment command. eg possible options: "TripFirst" | "TripLast"
    string adjustment = 2;
    // Option to determine whether to return alternative cycling journey
    bool alternativeCycle = 3;
    // Option to determine whether to return alternative walking journey
    bool alternativeWalking = 4;
    // Flag to determine whether certain text (e.g. walking instructions) should be output with HTML tags or not.
    bool applyHtmlMarkup = 5;
    // A comma separated list of cycling proficiency levels. eg possible options: "easy,moderate,fast"
    repeated string bikeProficiency = 6;
    // The cycle preference. eg possible options: "allTheWay" | "leaveAtStation" | "takeOnTransport" | "cycleHire"
    enum GetJourneyJourneyResultsFromToToRequest_CyclePreference {
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_CYCLEPREFERENCE_NONE = 0;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_CYCLEPREFERENCE_LEAVEATSTATION = 1;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_CYCLEPREFERENCE_TAKEONTRANSPORT = 2;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_CYCLEPREFERENCE_ALLTHEWAY = 3;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_CYCLEPREFERENCE_CYCLEHIRE = 4;
    }
    GetJourneyJourneyResultsFromToToRequest_CyclePreference cyclePreference = 7;
    // The date must be in yyyyMMdd format
    string date = 8;
    // Origin of the journey. Can be WGS84 coordinates expressed as "lat,long", a UK postcode, a Naptan (StopPoint) id, an ICS StopId, or a free-text string (will cause disambiguation unless it exactly matches a point of interest name).
    string from = 9;
    // An optional name to associate with the origin of the journey in the results.
    string fromName = 10;
    // The journey preference eg possible options: "leastinterchange" | "leasttime" | "leastwalking"
    enum GetJourneyJourneyResultsFromToToRequest_JourneyPreference {
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_JOURNEYPREFERENCE_LEASTINTERCHANGE = 0;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_JOURNEYPREFERENCE_LEASTTIME = 1;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_JOURNEYPREFERENCE_LEASTWALKING = 2;
    }
    GetJourneyJourneyResultsFromToToRequest_JourneyPreference journeyPreference = 11;
    // The max walking time in minutes for transfer eg. "120"
    string maxTransferMinutes = 12;
    // The max walking time in minutes for journeys eg. "120"
    string maxWalkingMinutes = 13;
    // The mode must be a comma separated list of modes. eg possible options: "public-bus,overground,train,tube,coach,dlr,cablecar,tram,river,walking,cycle"
    repeated string mode = 14;
    // Does the journey cover stops outside London? eg. "nationalSearch=true"
    bool nationalSearch = 15;
    // A boolean to indicate whether to return one or more taxi journeys. Note, setting this to true will override "useMultiModalCall".
    bool taxiOnlyTrip = 16;
    // The time must be in HHmm format
    string time = 17;
    // Does the time given relate to arrival or leaving time? Possible options: "departing" | "arriving"
    enum GetJourneyJourneyResultsFromToToRequest_TimeI {
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_TIMEI_ARRIVING = 0;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_TIMEI_DEPARTING = 1;
    }
    GetJourneyJourneyResultsFromToToRequest_TimeI timeIs = 18;
    // Destination of the journey. Can be WGS84 coordinates expressed as "lat,long", a UK postcode, a Naptan (StopPoint) id, an ICS StopId, or a free-text string (will cause disambiguation unless it exactly matches a point of interest name).
    string to = 19;
    // An optional name to associate with the destination of the journey in the results.
    string toName = 20;
    // A boolean to indicate whether or not to return 3 public transport journeys, a bus journey, a cycle hire journey, a personal cycle journey and a walking journey
    bool useMultiModalCall = 21;
    // Travel through point on the journey. Can be WGS84 coordinates expressed as "lat,long", a UK postcode, a Naptan (StopPoint) id, an ICS StopId, or a free-text string (will cause disambiguation unless it exactly matches a point of interest name).
    string via = 22;
    // An optional name to associate with the via point of the journey in the results.
    string viaName = 23;
    // A boolean to indicate whether to optimize journeys using walking
    bool walkingOptimization = 24;
    // The walking speed. eg possible options: "slow" | "average" | "fast".
    enum GetJourneyJourneyResultsFromToToRequest_WalkingSpeed {
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_WALKINGSPEED_SLOW = 0;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_WALKINGSPEED_AVERAGE = 1;
        GETJOURNEYJOURNEYRESULTSFROMTOTOREQUEST_WALKINGSPEED_FAST = 2;
    }
    GetJourneyJourneyResultsFromToToRequest_WalkingSpeed walkingSpeed = 25;
}

message GetJourneyMetaModesResponse {
    repeated Mode items = 1;
}

message GetLineMetaDisruptionCategoriesResponse {
    repeated string items = 1;
}

message GetLineMetaModesResponse {
    repeated Mode items = 1;
}

message GetLineMetaServiceTypesResponse {
    repeated string items = 1;
}

message GetLineMetaSeverityResponse {
    repeated StatusSeverity items = 1;
}

message GetLineModeModesRequest {
    // A comma-separated list of modes e.g. tube,dlr
    repeated string modes = 1;
}

message GetLineModeModesResponse {
    repeated Line items = 1;
}

message GetLineModeModesDisruptionRequest {
    // A comma-separated list of modes e.g. tube,dlr
    repeated string modes = 1;
}

message GetLineModeModesDisruptionResponse {
    repeated Disruption items = 1;
}

message GetLineModeModesRouteRequest {
    // A comma-separated list of modes e.g. tube,dlr
    repeated string modes = 1;
    // A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 2;
}

message GetLineModeModesRouteResponse {
    repeated Line items = 1;
}

message GetLineModeModesStatusRequest {
    // Include details of the disruptions that are causing the line status including the affected stops and routes
    bool detail = 1;
    // A comma-separated list of modes to filter by. e.g. tube,dlr
    repeated string modes = 2;
}

message GetLineModeModesStatusResponse {
    repeated Line items = 1;
}

message GetLineRouteRequest {
    // A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 1;
}

message GetLineRouteResponse {
    repeated Line items = 1;
}

message GetLineSearchQueryRequest {
    // Optionally filter by the specified modes
    repeated string modes = 1;
    // Search term e.g victoria
    string query = 2;
    // A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 3;
}

message GetLineStatusSeverityRequest {
    // The level of severity (eg: a number from 0 to 14)
    int32 severity = 1;
}

message GetLineStatusSeverityResponse {
    repeated Line items = 1;
}

message GetLineIdsRequest {
    // A comma-separated list of line ids e.g. victoria,circle,N133. Max. approx. 20 ids.
    repeated string ids = 1;
}

message GetLineIdsResponse {
    repeated Line items = 1;
}

message GetLineIdsArrivalsStopPointIdRequest {
    // Optional. Id of destination stop
    string destinationStationId = 1;
    // Optional. The direction of travel. Can be inbound or outbound or all. If left blank, and destinationStopId is set, will default to all
    enum GetLineIdsArrivalsStopPointIdRequest_Direction {
        GETLINEIDSARRIVALSSTOPPOINTIDREQUEST_DIRECTION_INBOUND = 0;
        GETLINEIDSARRIVALSSTOPPOINTIDREQUEST_DIRECTION_OUTBOUND = 1;
        GETLINEIDSARRIVALSSTOPPOINTIDREQUEST_DIRECTION_ALL = 2;
    }
    GetLineIdsArrivalsStopPointIdRequest_Direction direction = 2;
    // A comma-separated list of line ids e.g. victoria,circle,N133. Max. approx. 20 ids.
    repeated string ids = 3;
    // Optional. Id of stop to get arrival predictions for (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string stopPointId = 4;
}

message GetLineIdsArrivalsStopPointIdResponse {
    repeated Prediction items = 1;
}

message GetLineIdsDisruptionRequest {
    // A comma-separated list of line ids e.g. victoria,circle,N133. Max. approx. 20 ids.
    repeated string ids = 1;
}

message GetLineIdsDisruptionResponse {
    repeated Disruption items = 1;
}

message GetLineIdsRouteRequest {
    // A comma-separated list of line ids e.g. victoria,circle,N133. Max. approx. 20 ids.
    repeated string ids = 1;
    // A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 2;
}

message GetLineIdsRouteResponse {
    repeated Line items = 1;
}

message GetLineIdsStatusRequest {
    // Include details of the disruptions that are causing the line status including the affected stops and routes
    bool detail = 1;
    // A comma-separated list of line ids e.g. victoria,circle,N133. Max. approx. 20 ids.
    repeated string ids = 2;
}

message GetLineIdsStatusResponse {
    repeated Line items = 1;
}

message GetLineIdsStatusStartDateToEndDateRequest {
    string EndDate = 1;
    string StartDate = 2;
    string dateRange.endDate = 3;
    string dateRange.startDate = 4;
    // Include details of the disruptions that are causing the line status including the affected stops and routes
    bool detail = 5;
    string endDate = 6;
    // A comma-separated list of line ids e.g. victoria,circle,N133. Max. approx. 20 ids.
    repeated string ids = 7;
    string startDate = 8;
}

message GetLineIdsStatusStartDateToEndDateResponse {
    repeated Line items = 1;
}

message GetLineIdRouteSequenceDirectionRequest {
    // The direction of travel. Can be inbound or outbound.
    enum GetLineIdRouteSequenceDirectionRequest_Direction {
        GETLINEIDROUTESEQUENCEDIRECTIONREQUEST_DIRECTION_INBOUND = 0;
        GETLINEIDROUTESEQUENCEDIRECTIONREQUEST_DIRECTION_OUTBOUND = 1;
        GETLINEIDROUTESEQUENCEDIRECTIONREQUEST_DIRECTION_ALL = 2;
    }
    GetLineIdRouteSequenceDirectionRequest_Direction direction = 1;
    // That excludes crowding from line disruptions. Can be true or false.
    bool excludeCrowding = 2;
    // A single line id e.g. victoria
    string id = 3;
    // A comma seperated list of service types to filter on. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 4;
}

message GetLineIdStopPointsRequest {
    // A single line id e.g. victoria
    string id = 1;
}

message GetLineIdStopPointsResponse {
    repeated StopPoint items = 1;
}

message GetLineIdTimetableFromStopPointIdRequest {
    // The originating station's stop point id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string fromStopPointId = 1;
    // A single line id e.g. victoria
    string id = 2;
}

message GetLineIdTimetableFromStopPointIdToToStopPointIdRequest {
    // The originating station's stop point id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string fromStopPointId = 1;
    // A single line id e.g. victoria
    string id = 2;
    // The destination stations's Naptan code
    string toStopPointId = 3;
}

message GetModeActiveServiceTypesResponse {
    repeated ActiveServiceType items = 1;
}

message GetModeModeArrivalsRequest {
    // A number of arrivals to return for each stop, -1 to return all available.
    int32 count = 1;
    // A mode name e.g. tube, dlr
    string mode = 2;
}

message GetModeModeArrivalsResponse {
    repeated Prediction items = 1;
}

message GetOccupancyBikePointsIdsRequest {
    repeated string ids = 1;
}

message GetOccupancyBikePointsIdsResponse {
    repeated BikePointOccupancy items = 1;
}

message GetOccupancyCarParkResponse {
    repeated CarParkOccupancy items = 1;
}

message GetOccupancyCarParkIdRequest {
    string id = 1;
}

message GetOccupancyChargeConnectorResponse {
    repeated ChargeConnectorOccupancy items = 1;
}

message GetOccupancyChargeConnectorIdsRequest {
    repeated string ids = 1;
}

message GetOccupancyChargeConnectorIdsResponse {
    repeated ChargeConnectorOccupancy items = 1;
}

message GetPlaceRequest {
    // An optional parameter to limit the results to active records only (Currently only the 'VariableMessageSign' place type is supported)
    bool activeOnly = 1;
    double bbBoxpoints.neLat = 2;
    double bbBoxpoints.neLon = 3;
    double bbBoxpoints.swLat = 4;
    double bbBoxpoints.swLon = 5;
    // an optional list of comma separated property categories to return in the Place's property bag. If null or empty, all categories of property are returned. Pass the keyword "none" to return no properties (a valid list of categories can be obtained from the /Place/Meta/categories endpoint)
    repeated string categories = 6;
    // Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned
    bool includeChildren = 7;
    // place types to filter on, or null to return all types
    repeated string type = 8;
}

message GetPlaceResponse {
    repeated StopPoint items = 1;
}

message GetPlaceAddressStreetsPostcodeRequest {
    string Postcode = 1;
    string postcode = 2;
    string postcodeInput.postcode = 3;
}

message GetPlaceMetaCategoriesResponse {
    repeated PlaceCategory items = 1;
}

message GetPlaceMetaPlaceTypesResponse {
    repeated PlaceCategory items = 1;
}

message GetPlaceSearchRequest {
    // The name of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their names.
    string name = 1;
    // A comma-separated list of the types to return. Max. approx 12 types.
    repeated string types = 2;
}

message GetPlaceSearchResponse {
    repeated Place items = 1;
}

message GetPlaceTypeTypesRequest {
    // An optional parameter to limit the results to active records only (Currently only the 'VariableMessageSign' place type is supported)
    bool activeOnly = 1;
    // A comma-separated list of the types to return. Max. approx 12 types.
    //             A valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint.
    repeated string types = 2;
}

message GetPlaceTypeTypesResponse {
    repeated Place items = 1;
}

message GetPlaceIdRequest {
    // The id of the place, you can use the /Place/Types/{types} endpoint to get a list of places for a given type including their ids
    string id = 1;
    // Defaults to false. If true child places e.g. individual charging stations at a charge point while be included, otherwise just the URLs of any child places will be returned
    bool includeChildren = 2;
}

message GetPlaceIdResponse {
    repeated Place items = 1;
}

message GetPlaceTypeAtLatLonRequest {
    string Lat = 1;
    string Lon = 2;
    string lat = 3;
    double location.lat = 4;
    double location.lon = 5;
    string lon = 6;
    // The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint)
    repeated string type = 7;
}

message GetPlaceTypeOverlayZLatLonWidthHeightRequest {
    string Lat = 1;
    string Lon = 2;
    // The height of the requested overlay.
    int32 height = 3;
    string lat = 4;
    double location.lat = 5;
    double location.lon = 6;
    string lon = 7;
    // The place type (a valid list of place types can be obtained from the /Place/Meta/placeTypes endpoint)
    repeated string type = 8;
    // The width of the requested overlay.
    int32 width = 9;
    // The zoom level
    int32 z = 10;
}

message GetRoadResponse {
    repeated RoadCorridor items = 1;
}

message GetRoadMetaCategoriesResponse {
    repeated string items = 1;
}

message GetRoadMetaSeveritiesResponse {
    repeated StatusSeverity items = 1;
}

message GetRoadAllDisruptionDisruptionIdsRequest {
    // Comma-separated list of disruption identifiers to filter by.
    repeated string disruptionIds = 1;
    // Optional, defaults to false. When true, removes every property/node except for id, point, severity, severityDescription, startDate, endDate, corridor details, location and comments.
    bool stripContent = 2;
}

message GetRoadAllStreetDisruptionRequest {
    // Optional, The end time to filter on.
    string endDate = 1;
    // Optional, the start time to filter on.
    string startDate = 2;
}

message GetRoadIdsRequest {
    // Comma-separated list of road identifiers e.g. "A406, A2" (a full list of supported road identifiers can be found at the /Road/ endpoint)
    repeated string ids = 1;
}

message GetRoadIdsResponse {
    repeated RoadCorridor items = 1;
}

message GetRoadIdsDisruptionRequest {
    // an optional list of category names to filter on (a valid list of categories can be obtained from the /Road/Meta/categories endpoint)
    repeated string categories = 1;
    // Optional, defaults to true. When true, always includes disruptions that have road closures, regardless of the severity filter. When false, the severity filter works as normal.
    bool closures = 2;
    // Comma-separated list of road identifiers e.g. "A406, A2" use all for all to ignore id filter (a full list of supported road identifiers can be found at the /Road/ endpoint)
    repeated string ids = 3;
    // an optional list of Severity names to filter on (a valid list of severities can be obtained from the /Road/Meta/severities endpoint)
    repeated string severities = 4;
    // Optional, defaults to false. When true, removes every property/node except for id, point, severity, severityDescription, startDate, endDate, corridor details, location, comments and streets
    bool stripContent = 5;
}

message GetRoadIdsDisruptionResponse {
    repeated RoadDisruption items = 1;
}

message GetRoadIdsStatusRequest {
    string dateRangeNullable.endDate = 1;
    string dateRangeNullable.startDate = 2;
    // Comma-separated list of road identifiers e.g. "A406, A2" or use "all" to ignore id filter (a full list of supported road identifiers can be found at the /Road/ endpoint)
    repeated string ids = 3;
}

message GetRoadIdsStatusResponse {
    repeated RoadCorridor items = 1;
}

message GetSearchRequest {
    // The search query
    string query = 1;
}

message GetSearchBusSchedulesRequest {
    // The search query
    string query = 1;
}

message GetSearchMetaCategoriesResponse {
    repeated string items = 1;
}

message GetSearchMetaSearchProvidersResponse {
    repeated string items = 1;
}

message GetSearchMetaSortsResponse {
    repeated string items = 1;
}

message GetStopPointRequest {
    // an optional list of comma separated property categories to return in the StopPoint's property bag. If null or empty, all categories of property are returned. Pass the keyword "none" to return no properties (a valid list of categories can be obtained from the /StopPoint/Meta/categories endpoint)
    repeated string categories = 1;
    double location.lat = 2;
    double location.lon = 3;
    // the list of modes to search (comma separated mode names e.g. tube,dlr)
    repeated string modes = 4;
    // the radius of the bounding circle in metres (default : 200)
    int32 radius = 5;
    // true to return the lines that each stop point serves as a nested resource
    bool returnLines = 6;
    // a list of stopTypes that should be returned (a list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint)
    repeated string stopTypes = 7;
    // Re-arrange the output into a parent/child hierarchy
    bool useStopPointHierarchy = 8;
}

message GetStopPointMetaCategoriesResponse {
    repeated StopPointCategory items = 1;
}

message GetStopPointMetaModesResponse {
    repeated Mode items = 1;
}

message GetStopPointMetaStopTypesResponse {
    repeated string items = 1;
}

message GetStopPointModeModesRequest {
    // A comma-seperated list of modes e.g. tube,dlr
    repeated string modes = 1;
    // The data set page to return. Page 1 equates to the first 1000 stop points, page 2 equates to 1001-2000 etc. Must be entered for bus mode as data set is too large.
    int32 page = 2;
}

message GetStopPointModeModesDisruptionRequest {
    bool includeRouteBlockedStops = 1;
    // A comma-seperated list of modes e.g. tube,dlr
    repeated string modes = 2;
}

message GetStopPointModeModesDisruptionResponse {
    repeated DisruptedPoint items = 1;
}

message GetStopPointSearchRequest {
    // True to only return stations in that have Fares data available for single fares to another station.
    bool faresOnly = 1;
    // If true, returns results including HUBs.
    bool includeHubs = 2;
    // An optional, parameter separated list of the lines to filter by
    repeated string lines = 3;
    // An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,
    //             it is possible that the flattened result set will contain more than 50 items.
    int32 maxResults = 4;
    // An optional, parameter separated list of the modes to filter by
    repeated string modes = 5;
    // The query string, case-insensitive. Leading and trailing wildcards are applied automatically.
    string query = 6;
}

message GetStopPointSearchQueryRequest {
    // True to only return stations in that have Fares data available for single fares to another station.
    bool faresOnly = 1;
    // If true, returns results including HUBs.
    bool includeHubs = 2;
    // An optional, parameter separated list of the lines to filter by
    repeated string lines = 3;
    // An optional result limit, defaulting to and with a maximum of 50. Since children of the stop point heirarchy are returned for matches,
    //             it is possible that the flattened result set will contain more than 50 items.
    int32 maxResults = 4;
    // An optional, parameter separated list of the modes to filter by
    repeated string modes = 5;
    // The query string, case-insensitive. Leading and trailing wildcards are applied automatically.
    string query = 6;
}

message GetStopPointServiceTypesRequest {
    // The Naptan id of the stop
    string id = 1;
    // The lines which contain the given Naptan id (all lines relevant to the given stoppoint if empty)
    repeated string lineIds = 2;
    // The modes which the lines are relevant to (all if empty)
    repeated string modes = 3;
}

message GetStopPointServiceTypesResponse {
    repeated LineServiceType items = 1;
}

message GetStopPointSmsIdRequest {
    // A 5-digit Countdown Bus Stop Code e.g. 73241, 50435, 56334.
    string id = 1;
    // If set to "web", a 302 redirect to relevant website bus stop page is returned. Valid values are : web. All other values are ignored.
    string output = 2;
}

message GetStopPointTypeTypesRequest {
    // A comma-separated list of the types to return. Max. approx. 12 types. 
    //             A list of valid stop types can be obtained from the StopPoint/meta/stoptypes endpoint.
    repeated string types = 1;
}

message GetStopPointTypeTypesResponse {
    repeated StopPoint items = 1;
}

message GetStopPointIdsRequest {
    // A comma-separated list of stop point ids (station naptan code e.g. 940GZZLUASL). Max. approx. 20 ids.
    //             You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name.
    repeated string ids = 1;
    // Include the crowding data (static). To Filter further use: /StopPoint/{ids}/Crowding/{line}
    bool includeCrowdingData = 2;
}

message GetStopPointIdsResponse {
    repeated StopPoint items = 1;
}

message GetStopPointIdsDisruptionRequest {
    // Specify true to associate all disruptions with parent stop point. (Only applicable when getFamily is true).
    bool flattenResponse = 1;
    // Specify true to return disruptions for entire family, or false to return disruptions for just this stop point. Defaults to false.
    bool getFamily = 2;
    // A comma-seperated list of stop point ids. Max. approx. 20 ids.
    //             You can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name.
    repeated string ids = 3;
    bool includeRouteBlockedStops = 4;
}

message GetStopPointIdsDisruptionResponse {
    repeated DisruptedPoint items = 1;
}

message GetStopPointIdArrivalsRequest {
    // A StopPoint id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string id = 1;
}

message GetStopPointIdArrivalsResponse {
    repeated Prediction items = 1;
}

message GetStopPointIdCanReachOnLineLineIdRequest {
    // The id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name) of the stop point to filter by
    string id = 1;
    // Line id of the line to filter by (e.g. victoria)
    string lineId = 2;
    // A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 3;
}

message GetStopPointIdCanReachOnLineLineIdResponse {
    repeated StopPoint items = 1;
}

message GetStopPointIdCrowdingLineRequest {
    // The direction of travel. Can be inbound or outbound.
    enum GetStopPointIdCrowdingLineRequest_Direction {
        GETSTOPPOINTIDCROWDINGLINEREQUEST_DIRECTION_INBOUND = 0;
        GETSTOPPOINTIDCROWDINGLINEREQUEST_DIRECTION_OUTBOUND = 1;
        GETSTOPPOINTIDCROWDINGLINEREQUEST_DIRECTION_ALL = 2;
    }
    GetStopPointIdCrowdingLineRequest_Direction direction = 1;
    // The Naptan id of the stop
    string id = 2;
    // A particular line e.g. victoria, circle, northern etc.
    string line = 3;
}

message GetStopPointIdCrowdingLineResponse {
    repeated StopPoint items = 1;
}

message GetStopPointIdDirectionToToStopPointIdRequest {
    // Originating stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string id = 1;
    // Optional line id filter e.g. victoria
    string lineId = 2;
    // Destination stop id (station naptan code e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string toStopPointId = 3;
}

message GetStopPointIdRouteRequest {
    // A stop point id (station naptan codes e.g. 940GZZLUASL, you can use /StopPoint/Search/{query} endpoint to find a stop point id from a station name)
    string id = 1;
    // A comma-separated list of service types to filter on. If not specified. Supported values: Regular, Night. Defaulted to 'Regular' if not specified
    repeated string serviceTypes = 2;
}

message GetStopPointIdRouteResponse {
    repeated StopPointRouteSection items = 1;
}

message GetStopPointIdPlaceTypesRequest {
    // A naptan id for a stop point (station naptan code e.g. 940GZZLUASL).
    string id = 1;
    // A comcomma-separated value representing the place types.
    repeated string placeTypes = 2;
}

message GetStopPointIdPlaceTypesResponse {
    repeated Place items = 1;
}

message GetStopPointStopPointIdCarParksRequest {
    // stopPointId is required to get the car parks.
    string stopPointId = 1;
}

message GetStopPointStopPointIdCarParksResponse {
    repeated Place items = 1;
}

message GetStopPointStopPointIdTaxiRanksRequest {
    // stopPointId is required to get the taxi ranks.
    string stopPointId = 1;
}

message GetStopPointStopPointIdTaxiRanksResponse {
    repeated Place items = 1;
}

message GetTravelTimesCompareOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest {
    string compareType = 1;
    string compareValue = 2;
    // The direction of travel.
    enum GetTravelTimesCompareOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest_Direction {
        GETTRAVELTIMESCOMPAREOVERLAYZMAPCENTERMAPCENTERLATMAPCENTERLONPINLOCATIONPINLATPINLONDIMENSIONSWIDTHHEIGHTREQUEST_DIRECTION_AVERAGE = 0;
        GETTRAVELTIMESCOMPAREOVERLAYZMAPCENTERMAPCENTERLATMAPCENTERLONPINLOCATIONPINLATPINLONDIMENSIONSWIDTHHEIGHTREQUEST_DIRECTION_FROM = 1;
        GETTRAVELTIMESCOMPAREOVERLAYZMAPCENTERMAPCENTERLATMAPCENTERLONPINLOCATIONPINLATPINLONDIMENSIONSWIDTHHEIGHTREQUEST_DIRECTION_TO = 2;
    }
    GetTravelTimesCompareOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest_Direction direction = 3;
    // The height of the requested overlay.
    int32 height = 4;
    // The map center latitude.
    double mapCenterLat = 5;
    // The map center longitude.
    double mapCenterLon = 6;
    // The id of the mode.
    string modeId = 7;
    // The latitude of the pin.
    double pinLat = 8;
    // The longitude of the pin.
    double pinLon = 9;
    // The title of the scenario.
    string scenarioTitle = 10;
    // The id for the time of day (AM/INTER/PM)
    string timeOfDayId = 11;
    // The total minutes between the travel time bands
    int32 travelTimeInterval = 12;
    // The width of the requested overlay.
    int32 width = 13;
    // The zoom level.
    int32 z = 14;
}

message GetTravelTimesOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest {
    // The direction of travel.
    enum GetTravelTimesOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest_Direction {
        GETTRAVELTIMESOVERLAYZMAPCENTERMAPCENTERLATMAPCENTERLONPINLOCATIONPINLATPINLONDIMENSIONSWIDTHHEIGHTREQUEST_DIRECTION_AVERAGE = 0;
        GETTRAVELTIMESOVERLAYZMAPCENTERMAPCENTERLATMAPCENTERLONPINLOCATIONPINLATPINLONDIMENSIONSWIDTHHEIGHTREQUEST_DIRECTION_FROM = 1;
        GETTRAVELTIMESOVERLAYZMAPCENTERMAPCENTERLATMAPCENTERLONPINLOCATIONPINLATPINLONDIMENSIONSWIDTHHEIGHTREQUEST_DIRECTION_TO = 2;
    }
    GetTravelTimesOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest_Direction direction = 1;
    // The height of the requested overlay.
    int32 height = 2;
    // The map center latitude.
    double mapCenterLat = 3;
    // The map center longitude.
    double mapCenterLon = 4;
    // The id of the mode.
    string modeId = 5;
    // The latitude of the pin.
    double pinLat = 6;
    // The longitude of the pin.
    double pinLon = 7;
    // The title of the scenario.
    string scenarioTitle = 8;
    // The id for the time of day (AM/INTER/PM)
    string timeOfDayId = 9;
    // The total minutes between the travel time bands
    int32 travelTimeInterval = 10;
    // The width of the requested overlay.
    int32 width = 11;
    // The zoom level.
    int32 z = 12;
}

message GetVehicleEmissionSurchargeRequest {
    // The Vehicle Registration Mark
    string vrm = 1;
}

message GetVehicleIdsArrivalsRequest {
    // A comma-separated list of vehicle ids e.g. LX58CFV,LX11AZB,LX58CFE. Max approx. 25 ids.
    repeated string ids = 1;
}

message GetVehicleIdsArrivalsResponse {
    repeated Prediction items = 1;
}

message AccidentDetail {
    string borough = 1;
    repeated Casualty casualties = 2;
    string date = 3;
    int32 id = 4;
    double lat = 5;
    string location = 6;
    double lon = 7;
    string severity = 8;
    repeated Vehicle vehicles = 9;
}

message AccidentStatsOrderedSummary {
    int32 accidents = 1;
    string borough = 2;
    int32 year = 3;
}

message ActiveServiceType {
    string mode = 1;
    string serviceType = 2;
}

message AdditionalProperties {
    string category = 1;
    string key = 2;
    string modified = 3;
    string sourceSystemKey = 4;
    string value = 5;
}

message ApiVersionInfo {
    repeated string assemblies = 1;
    string label = 2;
    string timestamp = 3;
    string version = 4;
}

message Bay {
    int32 bayCount = 1;
    string bayType = 2;
    int32 free = 3;
    int32 occupied = 4;
}

message BikePointOccupancy {
    // Total bike counts
    int32 bikesCount = 1;
    // Empty docks
    int32 emptyDocks = 2;
    // Id of the bike point such as BikePoints_1
    string id = 3;
    // Name / Common name of the bike point
    string name = 4;
    // Total docks available
    int32 totalDocks = 5;
}

message CarParkOccupancy {
    repeated Bay bays = 1;
    string carParkDetailsUrl = 2;
    string id = 3;
    string name = 4;
}

message Casualty {
    int32 age = 1;
    string ageBand = 2;
    string class = 3;
    string mode = 4;
    string severity = 5;
}

message ChargeConnectorOccupancy {
    int32 id = 1;
    string sourceSystemPlaceId = 2;
    string status = 3;
}

message Coordinate {
    double easting = 1;
    double latitude = 2;
    double longitude = 3;
    double northing = 4;
    int32 xCoord = 5;
    int32 yCoord = 6;
}

message Crowding {
    // Busiest times at a station (static information)
    repeated PassengerFlow passengerFlows = 1;
    // Train Loading on a scale 1-6, 1 being "Very quiet" and 6 being "Exceptionally busy" (static information)
    repeated TrainLoading trainLoadings = 2;
}

message CycleSuperhighway {
    // A LineString or MultiLineString that forms the route of the highway
    DbGeography geography = 1;
    // The Id
    string id = 2;
    // The long label to show on maps when zoomed in
    string label = 3;
    // The short label to show on maps
    string labelShort = 4;
    // When the data was last updated
    string modified = 5;
    // True if the route is split into segments
    bool segmented = 6;
}

message DateRange {
    string endDate = 1;
    string startDate = 2;
}

message DateRangeNullable {
    string endDate = 1;
    string startDate = 2;
}

message DbGeography {
    DbGeographyWellKnownValue geography = 1;
}

message DbGeographyWellKnownValue {
    int32 coordinateSystemId = 1;
    string wellKnownBinary = 2;
    string wellKnownText = 3;
}

message Disambiguation {
    repeated DisambiguationOption disambiguationOptions = 1;
}

message DisambiguationOption {
    string description = 1;
    string uri = 2;
}

message DisruptedPoint {
    string additionalInformation = 1;
    string appearance = 2;
    string atcoCode = 3;
    string commonName = 4;
    string description = 5;
    string fromDate = 6;
    string mode = 7;
    string stationAtcoCode = 8;
    string toDate = 9;
    string type = 10;
}

message Disruption {
    // Gets or sets the additionaInfo of this disruption.
    string additionalInfo = 1;
    // Gets or sets the routes affected by this disruption
    repeated RouteSection affectedRoutes = 2;
    // Gets or sets the stops affected by this disruption
    repeated StopPoint affectedStops = 3;
    // Gets or sets the category of this dispruption.
    enum Disruption_Category {
        DISRUPTION_CATEGORY_UNDEFINED = 0;
        DISRUPTION_CATEGORY_REALTIME = 1;
        DISRUPTION_CATEGORY_PLANNEDWORK = 2;
        DISRUPTION_CATEGORY_INFORMATION = 3;
        DISRUPTION_CATEGORY_EVENT = 4;
        DISRUPTION_CATEGORY_CROWDING = 5;
        DISRUPTION_CATEGORY_STATUSALERT = 6;
    }
    Disruption_Category category = 4;
    // Gets or sets the description of the category.
    string categoryDescription = 5;
    string closureText = 6;
    // Gets or sets the date/time when this disruption was created.
    string created = 7;
    // Gets or sets the description of this disruption.
    string description = 8;
    bool isBlocking = 9;
    bool isWholeLine = 10;
    // Gets or sets the date/time when this disruption was last updated.
    string lastUpdate = 11;
    // Gets or sets the disruption type of this dispruption.
    string type = 12;
}

message EmissionsSurchargeVehicle {
    string colour = 1;
    enum EmissionsSurchargeVehicle_Compliance {
        EMISSIONSSURCHARGEVEHICLE_COMPLIANCE_NOTCOMPLIANT = 0;
        EMISSIONSSURCHARGEVEHICLE_COMPLIANCE_COMPLIANT = 1;
        EMISSIONSSURCHARGEVEHICLE_COMPLIANCE_EXEMPT = 2;
    }
    EmissionsSurchargeVehicle_Compliance compliance = 2;
    string make = 3;
    string model = 4;
    string type = 5;
    string vrm = 6;
}

message Fare {
    double cap = 1;
    string cost = 2;
    string description = 3;
    int32 id = 4;
    string mode = 5;
    string passengerType = 6;
    string ticketTime = 7;
    string ticketType = 8;
    string validFrom = 9;
    string validUntil = 10;
    string zone = 11;
}

message FareBounds {
    string description = 1;
    string displayName = 2;
    int32 displayOrder = 3;
    string from = 4;
    int32 id = 5;
    bool isPopularFare = 6;
    bool isPopularTravelCard = 7;
    bool isTour = 8;
    repeated Message messages = 9;
    string operator = 10;
    string routeCode = 11;
    string to = 12;
    string via = 13;
}

message FareDetails {
    int32 boundsId = 1;
    string displayName = 2;
    int32 displayOrder = 3;
    string endDate = 4;
    string from = 5;
    string fromStation = 6;
    bool isTour = 7;
    repeated Message messages = 8;
    string mode = 9;
    string operator = 10;
    string passengerType = 11;
    string routeCode = 12;
    string routeDescription = 13;
    bool specialFare = 14;
    string startDate = 15;
    bool throughFare = 16;
    repeated Ticket ticketsAvailable = 17;
    string to = 18;
    string toStation = 19;
    string validatorInformation = 20;
    string via = 21;
}

message FaresMode {
    string description = 1;
    int32 id = 2;
    string name = 3;
}

message FaresPeriod {
    string endDate = 1;
    int32 id = 2;
    bool isFuture = 3;
    string startDate = 4;
    string viewableDate = 5;
}

message FaresSection {
    string header = 1;
    int32 index = 2;
    repeated Message messages = 3;
    repeated FareDetails rows = 4;
}

message GeoCodeSearchMatch {
    // A string describing the formatted address of the place. Adds additional context to the place's Name.
    string address = 1;
    string id = 2;
    double lat = 3;
    double lon = 4;
    string name = 5;
    // The type of the place e.g. "street_address"
    repeated string types = 6;
    string url = 7;
}

message GeoPoint {
    double lat = 1;
    double lon = 2;
}

message GeoPointBBox {
    double neLat = 1;
    double neLon = 2;
    double swLat = 3;
    double swLon = 4;
}

message Identifier {
    Crowding crowding = 1;
    string fullName = 2;
    string id = 3;
    string name = 4;
    string type = 5;
    string uri = 6;
}

message Instruction {
    string detailed = 1;
    repeated InstructionStep steps = 2;
    string summary = 3;
}

message InstructionStep {
    int32 cumulativeDistance = 1;
    int32 cumulativeTravelTime = 2;
    string description = 3;
    string descriptionHeading = 4;
    int32 distance = 5;
    double latitude = 6;
    double longitude = 7;
    PathAttribute pathAttribute = 8;
    int32 skyDirection = 9;
    enum InstructionStep_SkyDirectionDescription {
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_NORTH = 0;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_NORTHEAST = 1;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_EAST = 2;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_SOUTHEAST = 3;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_SOUTH = 4;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_SOUTHWEST = 5;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_WEST = 6;
        INSTRUCTIONSTEP_SKYDIRECTIONDESCRIPTION_NORTHWEST = 7;
    }
    InstructionStep_SkyDirectionDescription skyDirectionDescription = 10;
    string streetName = 11;
    enum InstructionStep_TrackType {
        INSTRUCTIONSTEP_TRACKTYPE_CYCLESUPERHIGHWAY = 0;
        INSTRUCTIONSTEP_TRACKTYPE_CANALTOWPATH = 1;
        INSTRUCTIONSTEP_TRACKTYPE_QUIETROAD = 2;
        INSTRUCTIONSTEP_TRACKTYPE_PROVISIONFORCYCLISTS = 3;
        INSTRUCTIONSTEP_TRACKTYPE_BUSYROADS = 4;
        INSTRUCTIONSTEP_TRACKTYPE_NONE = 5;
        INSTRUCTIONSTEP_TRACKTYPE_PUSHBIKE = 6;
    }
    InstructionStep_TrackType trackType = 12;
    string turnDirection = 13;
}

message Interval {
    string stopId = 1;
    double timeToArrival = 2;
}

message ItineraryResult {
    JourneyPlannerCycleHireDockingStationData cycleHireDockingStationData = 1;
    JourneyVector journeyVector = 2;
    repeated Journey journeys = 3;
    repeated Line lines = 4;
    int32 recommendedMaxAgeMinutes = 5;
    SearchCriteria searchCriteria = 6;
    repeated string stopMessages = 7;
}

message Journey {
    string arrivalDateTime = 1;
    int32 duration = 2;
    repeated Leg legs = 3;
    string startDateTime = 4;
}

message JourneyPlannerCycleHireDockingStationData {
    string destinationId = 1;
    int32 destinationNumberOfBikes = 2;
    int32 destinationNumberOfEmptySlots = 3;
    string originId = 4;
    int32 originNumberOfBikes = 5;
    int32 originNumberOfEmptySlots = 6;
}

message JourneyVector {
    string from = 1;
    string to = 2;
    string uri = 3;
    string via = 4;
}

message JpElevation {
    int32 distance = 1;
    double endLat = 2;
    double endLon = 3;
    double gradient = 4;
    int32 heightFromPreviousPoint = 5;
    double startLat = 6;
    double startLon = 7;
}

message KnownJourney {
    string hour = 1;
    int32 intervalId = 2;
    string minute = 3;
}

message Leg {
    Point arrivalPoint = 1;
    string arrivalTime = 2;
    Point departurePoint = 3;
    string departureTime = 4;
    repeated Disruption disruptions = 5;
    double distance = 6;
    int32 duration = 7;
    bool hasFixedLocations = 8;
    // Describes the action the user need to take for this section, E.g. "walk to the
    //             district line"
    Instruction instruction = 9;
    bool isDisrupted = 10;
    Identifier mode = 11;
    repeated Obstacle obstacles = 12;
    Path path = 13;
    repeated PlannedWork plannedWorks = 14;
    repeated RouteOption routeOptions = 15;
    string speed = 16;
}

message Line {
    string created = 1;
    Crowding crowding = 2;
    repeated Disruption disruptions = 3;
    string id = 4;
    repeated LineStatus lineStatuses = 5;
    string modeName = 6;
    string modified = 7;
    string name = 8;
    repeated MatchedRoute routeSections = 9;
    repeated LineServiceTypeInfo serviceTypes = 10;
}

message LineGroup {
    repeated string lineIdentifier = 1;
    string naptanIdReference = 2;
    string stationAtcoCode = 3;
}

message LineModeGroup {
    repeated string lineIdentifier = 1;
    string modeName = 2;
}

message LineRouteSection {
    string destination = 1;
    string direction = 2;
    string fromStation = 3;
    int32 routeId = 4;
    string serviceType = 5;
    string toStation = 6;
    string vehicleDestinationText = 7;
}

message LineServiceType {
    string lineName = 1;
    repeated LineSpecificServiceType lineSpecificServiceTypes = 2;
}

message LineServiceTypeInfo {
    string name = 1;
    string uri = 2;
}

message LineSpecificServiceType {
    LineServiceTypeInfo serviceType = 1;
    bool stopServesServiceType = 2;
}

message LineStatus {
    string created = 1;
    Disruption disruption = 2;
    int32 id = 3;
    string lineId = 4;
    string modified = 5;
    string reason = 6;
    int32 statusSeverity = 7;
    string statusSeverityDescription = 8;
    repeated ValidityPeriod validityPeriods = 9;
}

message MatchedRoute {
    // eg: Destination
    string destination = 1;
    // eg: Destination Name
    string destinationName = 2;
    // eg: N or S or I or O
    string direction = 3;
    // Name such as "72"
    string name = 4;
    // eg: Origination Name
    string originationName = 5;
    // eg: Origination
    string originator = 6;
    // The route code
    string routeCode = 7;
    // eg: Regular, Night
    string serviceType = 8;
}

message MatchedRouteSections {
    int32 id = 1;
}

message MatchedStop {
    string accessibilitySummary = 1;
    string direction = 2;
    bool hasDisruption = 3;
    string icsId = 4;
    string id = 5;
    double lat = 6;
    repeated Identifier lines = 7;
    double lon = 8;
    repeated string modes = 9;
    string name = 10;
    string parentId = 11;
    int32 routeId = 12;
    string stationId = 13;
    bool status = 14;
    string stopLetter = 15;
    string stopType = 16;
    string topMostParentId = 17;
    string towards = 18;
    string url = 19;
    string zone = 20;
}

message Message {
    int32 bulletOrder = 1;
    bool header = 2;
    string linkText = 3;
    string messageText = 4;
    string url = 5;
}

message Mode {
    bool isFarePaying = 1;
    bool isScheduledService = 2;
    bool isTflService = 3;
    string modeName = 4;
}

message Object {
}

message Obstacle {
    string incline = 1;
    string position = 2;
    int32 stopId = 3;
    string type = 4;
}

message OrderedRoute {
    string name = 1;
    repeated string naptanIds = 2;
    string serviceType = 3;
}

message PassengerFlow {
    // Time in 24hr format with 15 minute intervals e.g. 0500-0515, 0515-0530 etc.
    string timeSlice = 1;
    // Count of passenger flow towards a platform
    int32 value = 2;
}

message PassengerType {
    string description = 1;
    string displayName = 2;
    int32 displayOrder = 3;
    string type = 4;
}

message Path {
    repeated JpElevation elevation = 1;
    string lineString = 2;
    repeated Identifier stopPoints = 3;
}

message PathAttribute {
    string name = 1;
    string value = 2;
}

message Period {
    ServiceFrequency frequency = 1;
    TwentyFourHourClockTime fromTime = 2;
    TwentyFourHourClockTime toTime = 3;
    enum Period_Type {
        PERIOD_TYPE_NORMAL = 0;
        PERIOD_TYPE_FREQUENCYHOURS = 1;
        PERIOD_TYPE_FREQUENCYMINUTES = 2;
        PERIOD_TYPE_UNKNOWN = 3;
    }
    Period_Type type = 4;
}

message Place {
    // A bag of additional key/value pairs with extra information about this place.
    repeated AdditionalProperties additionalProperties = 1;
    repeated Place children = 2;
    repeated string childrenUrls = 3;
    // A human readable name.
    string commonName = 4;
    // The distance of the place from its search point, if this is the result
    //             of a geographical search, otherwise zero.
    double distance = 5;
    // A unique identifier.
    string id = 6;
    // WGS84 latitude of the location.
    double lat = 7;
    // WGS84 longitude of the location.
    double lon = 8;
    // The type of Place. See /Place/Meta/placeTypes for possible values.
    string placeType = 9;
    // The unique location of this resource.
    string url = 10;
}

message PlaceCategory {
    repeated string availableKeys = 1;
    string category = 2;
}

message PlacePolygon {
    string commonName = 1;
    repeated GeoPoint geoPoints = 2;
}

message PlannedWork {
    string createdDateTime = 1;
    string description = 2;
    string id = 3;
    string lastUpdateDateTime = 4;
}

message Point {
    // WGS84 latitude of the location.
    double lat = 1;
    // WGS84 longitude of the location.
    double lon = 2;
}

message PostcodeInput {
    string postcode = 1;
}

message Prediction {
    // Bearing (between 0 to 359)
    string bearing = 1;
    // The current location of the vehicle.
    string currentLocation = 2;
    // Name of the destination
    string destinationName = 3;
    // Naptan Identifier for the prediction's destination
    string destinationNaptanId = 4;
    // Direction (unified to inbound/outbound)
    string direction = 5;
    // The expected arrival time of the vehicle at the stop/station
    string expectedArrival = 6;
    // The identitier for the prediction
    string id = 7;
    // Unique identifier for the Line
    string lineId = 8;
    // Line Name
    string lineName = 9;
    // The mode name of the station/line the prediction relates to
    string modeName = 10;
    // Identifier for the prediction
    string naptanId = 11;
    // The type of the operation (1: is new or has been updated, 2: should be deleted from any client cache)
    int32 operationType = 12;
    // Platform name (for bus, this is the stop letter)
    string platformName = 13;
    // Station name
    string stationName = 14;
    // The expiry time for the prediction
    string timeToLive = 15;
    // Prediction of the Time to station in seconds
    int32 timeToStation = 16;
    // Timestamp for when the prediction was inserted/modified (source column drives what objects are broadcast on each iteration)
    string timestamp = 17;
    // Keep the original timestamp from MongoDb fo debugging purposes
    PredictionTiming timing = 18;
    // Routing information or other descriptive text about the path of the vehicle towards the destination
    string towards = 19;
    // The actual vehicle in transit (for train modes, the leading car of the rolling set)
    string vehicleId = 20;
}

message PredictionTiming {
    string countdownServerAdjustment = 1;
    string insert = 2;
    string read = 3;
    string received = 4;
    string sent = 5;
    string source = 6;
}

message Recommendation {
    string cost = 1;
    string discountCard = 2;
    string fareType = 3;
    repeated Message gettingYourTicket = 4;
    int32 id = 5;
    repeated Message keyFeatures = 6;
    repeated Message notes = 7;
    string priceComparison = 8;
    string priceDescription = 9;
    string product = 10;
    string productType = 11;
    int32 rank = 12;
    string recommendedTopUp = 13;
    int32 rule = 14;
    double singleFare = 15;
    string ticketTime = 16;
    string ticketType = 17;
    string zones = 18;
}

message RecommendationResponse {
    repeated Recommendation recommendations = 1;
}

message Redirect {
    bool active = 1;
    string longUrl = 2;
    string shortUrl = 3;
}

message RoadCorridor {
    // The Bounds of the Corridor, given by the south-east followed by the north-west co-ordinate
    //             pair in geoJSON format e.g. "[[-1.241531,51.242151],[1.641223,53.765721]]"
    string bounds = 1;
    // The display name of the Corridor e.g. "North Circular (A406)". This
    //             may be identical to the Id.
    string displayName = 2;
    // The Envelope of the Corridor, given by the corner co-ordinates of a rectangular (four-point) polygon
    //             in geoJSON format e.g. "[[-1.241531,51.242151],[-1.241531,53.765721],[1.641223,53.765721],[1.641223,51.242151]]"
    string envelope = 3;
    // The group name of the Corridor e.g. "Central London". Most corridors are not grouped, in which case this field can be null.
    string group = 4;
    // The Id of the Corridor e.g. "A406"
    string id = 5;
    // The end of the period over which status has been aggregated, or null if this is the current corridor status.
    string statusAggregationEndDate = 6;
    // The start of the period over which status has been aggregated, or null if this is the current corridor status.
    string statusAggregationStartDate = 7;
    // Standard multi-mode status severity code
    string statusSeverity = 8;
    // Description of the status severity as applied to RoadCorridors
    string statusSeverityDescription = 9;
    // URL to retrieve this Corridor.
    string url = 10;
}

message RoadDisruption {
    // Describes the nature of disruption e.g. Traffic Incidents, Works
    string category = 1;
    // Full text of comments describing the disruption, including details of any road closures and diversions, where appropriate.
    string comments = 2;
    // The Ids of affected corridors, if any.
    repeated string corridorIds = 3;
    // Text of the most recent update from the LSTCC on the state of the
    //              disruption, including the current traffic impact and any advice to
    //              road users.
    string currentUpdate = 4;
    // The time when the last CurrentUpdate description was recorded, 
    //             or null if no CurrentUpdate has been applied.
    string currentUpdateDateTime = 5;
    // The date and time on which the disruption ended. For planned disruptions, this date will have a valid value. For unplanned 
    //             disruptions in progress, this field will be omitted.
    string endDateTime = 6;
    // Geography version of Point for output as GeoJSON.
    //             Can not use Geometry in a consistent way as non-TIMS disruptions do not have a polygon
    DbGeography geography = 7;
    // GeoJSON formatted latitude/longitude (WGS84) pairs forming an enclosed polyline or polygon. The polygon will only be included where affected streets information
    //             is not available for the disruption, would be inappropriate (e.g. a very large number of streets), or is centred on an area without streets (e.g. a football stadium).
    DbGeography geometry = 8;
    // True if any of the affected Streets have a "Full Closure" status, false otherwise. A RoadDisruption that has HasClosures is considered a 
    //             Severe or Serious disruption for severity filtering purposes.
    bool hasClosures = 9;
    // Unique identifier for the road disruption
    string id = 10;
    // True if the disruption is planned on a future date that is open to change
    bool isProvisional = 11;
    // The date and time on which the disruption was last modified in the system. This information can reliably be used by a developer to quickly
    //             compare two instances of the same disruption to determine if it has been changed.
    string lastModifiedTime = 12;
    // This describes the level of potential impact on traffic operations of the disruption. 
    //             High = e.g. a one-off disruption on a major or high profile route which will require a high level of operational attention 
    //             Medium = This is the default value 
    //             Low = e.g. a frequently occurring disruption which is well known
    string levelOfInterest = 13;
    // The text of any associated link
    string linkText = 14;
    // The url of any associated link
    string linkUrl = 15;
    // Main road name / number (borough) or preset area name where the disruption is located. This might be useful for a map popup where space is limited.
    string location = 16;
    // An ordinal of the disruption based on severity, level of interest and corridor.
    int32 ordinal = 17;
    // Latitude and longitude (WGS84) of the centroid of the disruption, stored in a geoJSON-formatted string.
    string point = 18;
    string publishEndDate = 19;
    // TDM Additional properties
    string publishStartDate = 20;
    repeated RoadDisruptionSchedule recurringSchedules = 21;
    repeated RoadDisruptionImpactArea roadDisruptionImpactAreas = 22;
    repeated RoadDisruptionLine roadDisruptionLines = 23;
    // Any associated road project
    RoadProject roadProject = 24;
    // A description of the severity of the disruption.
    string severity = 25;
    // The date and time which the disruption started. For a planned disruption (i.e. planned road works) this date will be in the future.
    //             For unplanned disruptions, this will default to the date on which the disruption was first recorded, but may be adjusted by the operator.
    string startDateTime = 26;
    // This describes the status of the disruption.  
    //             Active = currently in progress 
    //             Active Long Term = currently in progress and long term
    //             Scheduled = scheduled to start within the next 180 days
    //             Recurring Works = planned maintenance works that follow a regular routine or pattern and whose next occurrence is to start within the next 180 days.
    //             Recently Cleared = recently cleared in the last 24 hours
    //             Note that the status of Scheduled or Recurring Works disruptions will change to Active when they start, and will change status again when they end.
    string status = 27;
    // A collection of zero or more streets affected by the disruption.
    repeated Street streets = 28;
    // Describes the sub-category of disruption e.g. Collapsed Manhole, Abnormal Load
    string subCategory = 29;
    string timeFrame = 30;
    // URL to retrieve this road disruption
    string url = 31;
}

message RoadDisruptionImpactArea {
    string endDate = 1;
    string endTime = 2;
    int32 id = 3;
    DbGeography polygon = 4;
    string roadDisruptionId = 5;
    string startDate = 6;
    string startTime = 7;
}

message RoadDisruptionLine {
    string endDate = 1;
    string endTime = 2;
    int32 id = 3;
    bool isDiversion = 4;
    DbGeography multiLineString = 5;
    string roadDisruptionId = 6;
    string startDate = 7;
    string startTime = 8;
}

message RoadDisruptionSchedule {
    string endTime = 1;
    string startTime = 2;
}

message RoadProject {
    repeated string boroughsBenefited = 1;
    string constructionEndDate = 2;
    string constructionStartDate = 3;
    string consultationEndDate = 4;
    string consultationPageUrl = 5;
    string consultationStartDate = 6;
    string contactEmail = 7;
    string contactName = 8;
    string cycleSuperhighwayId = 9;
    string externalPageUrl = 10;
    enum RoadProject_Phase {
        ROADPROJECT_PHASE_UNSCOPED = 0;
        ROADPROJECT_PHASE_CONCEPT = 1;
        ROADPROJECT_PHASE_CONSULTATIONENDED = 2;
        ROADPROJECT_PHASE_CONSULTATION = 3;
        ROADPROJECT_PHASE_CONSTRUCTION = 4;
        ROADPROJECT_PHASE_COMPLETE = 5;
    }
    RoadProject_Phase phase = 11;
    string projectDescription = 12;
    string projectId = 13;
    string projectName = 14;
    string projectPageUrl = 15;
    string projectSummaryPageUrl = 16;
    string schemeName = 17;
}

message RouteOption {
    repeated string directions = 1;
    // The Id of the route
    string id = 2;
    // The line identifier (e.g. District Line), from where you can obtain line status information e.g. the rainbow board status "good service".
    Identifier lineIdentifier = 3;
    // Name such as "72"
    string name = 4;
}

message RouteSearchMatch {
    string id = 1;
    double lat = 2;
    string lineId = 3;
    string lineName = 4;
    repeated LineRouteSection lineRouteSection = 5;
    double lon = 6;
    repeated MatchedRouteSections matchedRouteSections = 7;
    repeated MatchedStop matchedStops = 8;
    string mode = 9;
    string name = 10;
    string url = 11;
}

message RouteSearchResponse {
    string input = 1;
    repeated RouteSearchMatch searchMatches = 2;
}

message RouteSection {
    // eg: Destination Name
    string destinationName = 1;
    // eg: N or S or I or O
    string direction = 2;
    // The Id of the route
    string id = 3;
    // The Id of the Line
    string lineId = 4;
    // eg: Path coordindates
    string lineString = 5;
    // Name such as "72"
    string name = 6;
    // eg: Origination Name
    string originationName = 7;
    // The route code
    string routeCode = 8;
    repeated RouteSectionNaptanEntrySequence routeSectionNaptanEntrySequence = 9;
}

message RouteSectionNaptanEntrySequence {
    int32 ordinal = 1;
    StopPoint stopPoint = 2;
}

message RouteSequence {
    string direction = 1;
    bool isOutboundOnly = 2;
    string lineId = 3;
    string lineName = 4;
    repeated string lineStrings = 5;
    string mode = 6;
    repeated OrderedRoute orderedLineRoutes = 7;
    repeated MatchedStop stations = 8;
    repeated StopPointSequence stopPointSequences = 9;
}

message Schedule {
    KnownJourney firstJourney = 1;
    repeated KnownJourney knownJourneys = 2;
    KnownJourney lastJourney = 3;
    string name = 4;
    repeated Period periods = 5;
}

message SearchCriteria {
    string dateTime = 1;
    enum SearchCriteria_DateTimeType {
        SEARCHCRITERIA_DATETIMETYPE_ARRIVING = 0;
        SEARCHCRITERIA_DATETIMETYPE_DEPARTING = 1;
    }
    SearchCriteria_DateTimeType dateTimeType = 2;
    TimeAdjustments timeAdjustments = 3;
}

message SearchMatch {
    string id = 1;
    double lat = 2;
    double lon = 3;
    string name = 4;
    string url = 5;
}

message SearchResponse {
    int32 from = 1;
    repeated SearchMatch matches = 2;
    double maxScore = 3;
    int32 page = 4;
    int32 pageSize = 5;
    string provider = 6;
    string query = 7;
    int32 total = 8;
}

message ServiceFrequency {
    double highestFrequency = 1;
    double lowestFrequency = 2;
}

message StationInterval {
    string id = 1;
    repeated Interval intervals = 2;
}

message StatusSeverity {
    string description = 1;
    string modeName = 2;
    int32 severityLevel = 3;
}

message StopPoint {
    string accessibilitySummary = 1;
    // A bag of additional key/value pairs with extra information about this place.
    repeated AdditionalProperties additionalProperties = 2;
    repeated Place children = 3;
    repeated string childrenUrls = 4;
    // A human readable name.
    string commonName = 5;
    // The distance of the place from its search point, if this is the result
    //             of a geographical search, otherwise zero.
    double distance = 6;
    string fullName = 7;
    string hubNaptanCode = 8;
    string icsCode = 9;
    // A unique identifier.
    string id = 10;
    // The indicator of the stop point e.g. "Stop K"
    string indicator = 11;
    // WGS84 latitude of the location.
    double lat = 12;
    repeated LineGroup lineGroup = 13;
    repeated LineModeGroup lineModeGroups = 14;
    repeated Identifier lines = 15;
    // WGS84 longitude of the location.
    double lon = 16;
    repeated string modes = 17;
    string naptanId = 18;
    string naptanMode = 19;
    // The type of Place. See /Place/Meta/placeTypes for possible values.
    string placeType = 20;
    string platformName = 21;
    string smsCode = 22;
    string stationNaptan = 23;
    bool status = 24;
    // The stop letter, if it could be cleansed from the Indicator e.g. "K"
    string stopLetter = 25;
    string stopType = 26;
    // The unique location of this resource.
    string url = 27;
}

message StopPointCategory {
    repeated string availableKeys = 1;
    string category = 2;
}

message StopPointRouteSection {
    string destinationName = 1;
    string direction = 2;
    bool isActive = 3;
    string lineId = 4;
    string lineString = 5;
    string mode = 6;
    string naptanId = 7;
    string routeSectionName = 8;
    string serviceType = 9;
    string validFrom = 10;
    string validTo = 11;
    string vehicleDestinationText = 12;
}

message StopPointSequence {
    // The id of this branch.
    int32 branchId = 1;
    string direction = 2;
    string lineId = 3;
    string lineName = 4;
    // The ids of the next branch(es) in the sequence. Note that the next and previous branch id can be
    //             identical in the case of a looped route e.g. the Circle line.
    repeated int32 nextBranchIds = 5;
    // The ids of the previous branch(es) in the sequence. Note that the next and previous branch id can be
    //             identical in the case of a looped route e.g. the Circle line.
    repeated int32 prevBranchIds = 6;
    enum StopPointSequence_ServiceType {
        STOPPOINTSEQUENCE_SERVICETYPE_REGULAR = 0;
        STOPPOINTSEQUENCE_SERVICETYPE_NIGHT = 1;
    }
    StopPointSequence_ServiceType serviceType = 7;
    repeated MatchedStop stopPoint = 8;
}

message StopPointsResponse {
    // The centre latitude/longitude of this list of StopPoints
    repeated double centrePoint = 1;
    // The index of this page
    int32 page = 2;
    // The maximum size of the page in this response i.e. the maximum number of StopPoints
    int32 pageSize = 3;
    // Collection of stop points
    repeated StopPoint stopPoints = 4;
    // The total number of StopPoints available across all pages
    int32 total = 5;
}

message Street {
    // Type of road closure. Some example values:
    //             Open = road is open, not blocked, not closed, not restricted. It maybe that the disruption has been moved out of the carriageway.
    //             Partial Closure = road is partially blocked, closed or restricted. 
    //             Full Closure = road is fully blocked or closed.
    string closure = 1;
    // The direction of the disruption on the street. Some example values:
    //             All Directions
    //             All Approaches
    //             Clockwise
    //             Anti-Clockwise
    //             Northbound
    //             Eastbound
    //             Southbound
    //             Westbound
    //             Both Directions
    string directions = 2;
    // Street name
    string name = 3;
    // Geographic description of the sections of this street that are affected.
    repeated StreetSegment segments = 4;
    // The ID from the source system of the disruption that this street belongs to.
    int64 sourceSystemId = 5;
    // The key of the source system of the disruption that this street belongs to.
    string sourceSystemKey = 6;
}

message StreetSegment {
    // geoJSON formatted LineString containing two latitude/longitude (WGS84) pairs that identify the start and end points of the street segment.
    string lineString = 1;
    // The ID from the source system of the disruption that this street belongs to.
    int64 sourceSystemId = 2;
    // The key of the source system of the disruption that this street belongs to.
    string sourceSystemKey = 3;
    // A 16 digit unique integer identifying a OS ITN (Ordnance Survey Integrated Transport Network) road link.
    string toid = 4;
}

message Ticket {
    string cost = 1;
    string description = 2;
    int32 displayOrder = 3;
    repeated Message messages = 4;
    string mode = 5;
    string passengerType = 6;
    TicketTime ticketTime = 7;
    TicketType ticketType = 8;
}

message TicketTime {
    string description = 1;
    string type = 2;
}

message TicketType {
    string description = 1;
    string type = 2;
}

message TimeAdjustment {
    string date = 1;
    string time = 2;
    string timeIs = 3;
    string uri = 4;
}

message TimeAdjustments {
    TimeAdjustment earlier = 1;
    TimeAdjustment earliest = 2;
    TimeAdjustment later = 3;
    TimeAdjustment latest = 4;
}

message Timetable {
    string departureStopId = 1;
    repeated TimetableRoute routes = 2;
}

message TimetableResponse {
    string direction = 1;
    Disambiguation disambiguation = 2;
    string lineId = 3;
    string lineName = 4;
    string pdfUrl = 5;
    repeated MatchedStop stations = 6;
    string statusErrorMessage = 7;
    repeated MatchedStop stops = 8;
    Timetable timetable = 9;
}

message TimetableRoute {
    repeated Schedule schedules = 1;
    repeated StationInterval stationIntervals = 2;
}

message TrainLoading {
    // Direction in regards to Journey Planner i.e. inbound or outbound
    string direction = 1;
    // The Line Name e.g. "Victoria"
    string line = 2;
    // Direction of the Line e.g. NB, SB, WB etc.
    string lineDirection = 3;
    // Naptan of the adjacent station
    string naptanTo = 4;
    // Direction displayed on the platform e.g. NB, SB, WB etc.
    string platformDirection = 5;
    // Time in 24hr format with 15 minute intervals e.g. 0500-0515, 0515-0530 etc.
    string timeSlice = 6;
    // Scale between 1-6, 
    //              1 = Very quiet, 2 = Quiet, 3 = Fairly busy, 4 = Busy, 5 = Very busy, 6 = Exceptionally busy
    int32 value = 7;
}

message TwentyFourHourClockTime {
    string hour = 1;
    string minute = 2;
}

message ValidityPeriod {
    // Gets or sets the start date.
    string fromDate = 1;
    // If true is a realtime status rather than planned or info
    bool isNow = 2;
    // Gets or sets the end date.
    string toDate = 3;
}

message Vehicle {
    string type = 1;
}

service TransportForLondonUnifiedService {
    // Gets all accident details for accidents occuring in the specified year
    rpc GetAccidentStatsYear(GetAccidentStatsYearRequest) returns (GetAccidentStatsYearResponse) {
      option (google.api.http) = {
        get: "/AccidentStats/{year}"
      };
    }
    // Gets air quality data feed
    rpc GetAirQuality(google.protobuf.Empty) returns (Object) {
      option (google.api.http) = {
        get: "/AirQuality"
      };
    }
    // Gets all bike point locations. The Place object has an addtionalProperties array which contains the nbBikes, nbDocks and nbSpaces
    //             numbers which give the status of the BikePoint. A mismatch in these numbers i.e. nbDocks - (nbBikes + nbSpaces) != 0 indicates broken docks.
    rpc GetBikePoint(google.protobuf.Empty) returns (GetBikePointResponse) {
      option (google.api.http) = {
        get: "/BikePoint"
      };
    }
    // Search for bike stations by their name, a bike point's name often contains information about the name of the street
    //             or nearby landmarks, for example. Note that the search result does not contain the PlaceProperties i.e. the status
    //             or occupancy of the BikePoint, to get that information you should retrieve the BikePoint by its id on /BikePoint/id.
    rpc GetBikePointSearch(GetBikePointSearchRequest) returns (GetBikePointSearchResponse) {
      option (google.api.http) = {
        get: "/BikePoint/Search"
      };
    }
    // Gets the bike point with the given id.
    rpc GetBikePointId(GetBikePointIdRequest) returns (Place) {
      option (google.api.http) = {
        get: "/BikePoint/{id}"
      };
    }
    // Gets taxis and minicabs contact information
    rpc GetCabwiseSearch(GetCabwiseSearchRequest) returns (Object) {
      option (google.api.http) = {
        get: "/Cabwise/search"
      };
    }
    // Perform a Journey Planner search from the parameters specified in simple types
    rpc GetJourneyJourneyResultsFromToTo(GetJourneyJourneyResultsFromToToRequest) returns (ItineraryResult) {
      option (google.api.http) = {
        get: "/Journey/JourneyResults/{from}/to/{to}"
      };
    }
    // Gets a list of all of the available journey planner modes
    rpc GetJourneyMetaModes(google.protobuf.Empty) returns (GetJourneyMetaModesResponse) {
      option (google.api.http) = {
        get: "/Journey/Meta/Modes"
      };
    }
    // Gets a list of valid disruption categories
    rpc GetLineMetaDisruptionCategories(google.protobuf.Empty) returns (GetLineMetaDisruptionCategoriesResponse) {
      option (google.api.http) = {
        get: "/Line/Meta/DisruptionCategories"
      };
    }
    // Gets a list of valid modes
    rpc GetLineMetaModes(google.protobuf.Empty) returns (GetLineMetaModesResponse) {
      option (google.api.http) = {
        get: "/Line/Meta/Modes"
      };
    }
    // Gets a list of valid ServiceTypes to filter on
    rpc GetLineMetaServiceTypes(google.protobuf.Empty) returns (GetLineMetaServiceTypesResponse) {
      option (google.api.http) = {
        get: "/Line/Meta/ServiceTypes"
      };
    }
    // Gets a list of valid severity codes
    rpc GetLineMetaSeverity(google.protobuf.Empty) returns (GetLineMetaSeverityResponse) {
      option (google.api.http) = {
        get: "/Line/Meta/Severity"
      };
    }
    // Gets lines that serve the given modes.
    rpc GetLineModeModes(GetLineModeModesRequest) returns (GetLineModeModesResponse) {
      option (google.api.http) = {
        get: "/Line/Mode/{modes}"
      };
    }
    // Get disruptions for all lines of the given modes.
    rpc GetLineModeModesDisruption(GetLineModeModesDisruptionRequest) returns (GetLineModeModesDisruptionResponse) {
      option (google.api.http) = {
        get: "/Line/Mode/{modes}/Disruption"
      };
    }
    // Gets all lines and their valid routes for given modes, including the name and id of the originating and terminating stops for each route
    rpc GetLineModeModesRoute(GetLineModeModesRouteRequest) returns (GetLineModeModesRouteResponse) {
      option (google.api.http) = {
        get: "/Line/Mode/{modes}/Route"
      };
    }
    // Gets the line status of for all lines for the given modes
    rpc GetLineModeModesStatus(GetLineModeModesStatusRequest) returns (GetLineModeModesStatusResponse) {
      option (google.api.http) = {
        get: "/Line/Mode/{modes}/Status"
      };
    }
    // Get all valid routes for all lines, including the name and id of the originating and terminating stops for each route.
    rpc GetLineRoute(GetLineRouteRequest) returns (GetLineRouteResponse) {
      option (google.api.http) = {
        get: "/Line/Route"
      };
    }
    // Search for lines or routes matching the query string
    rpc GetLineSearchQuery(GetLineSearchQueryRequest) returns (RouteSearchResponse) {
      option (google.api.http) = {
        get: "/Line/Search/{query}"
      };
    }
    // Gets the line status for all lines with a given severity
    //             A list of valid severity codes can be obtained from a call to Line/Meta/Severity
    rpc GetLineStatusSeverity(GetLineStatusSeverityRequest) returns (GetLineStatusSeverityResponse) {
      option (google.api.http) = {
        get: "/Line/Status/{severity}"
      };
    }
    // Gets lines that match the specified line ids.
    rpc GetLineIds(GetLineIdsRequest) returns (GetLineIdsResponse) {
      option (google.api.http) = {
        get: "/Line/{ids}"
      };
    }
    // Get the list of arrival predictions for given line ids based at the given stop
    rpc GetLineIdsArrivalsStopPointId(GetLineIdsArrivalsStopPointIdRequest) returns (GetLineIdsArrivalsStopPointIdResponse) {
      option (google.api.http) = {
        get: "/Line/{ids}/Arrivals/{stopPointId}"
      };
    }
    // Get disruptions for the given line ids
    rpc GetLineIdsDisruption(GetLineIdsDisruptionRequest) returns (GetLineIdsDisruptionResponse) {
      option (google.api.http) = {
        get: "/Line/{ids}/Disruption"
      };
    }
    // Get all valid routes for given line ids, including the name and id of the originating and terminating stops for each route.
    rpc GetLineIdsRoute(GetLineIdsRouteRequest) returns (GetLineIdsRouteResponse) {
      option (google.api.http) = {
        get: "/Line/{ids}/Route"
      };
    }
    // Gets the line status of for given line ids e.g Minor Delays
    rpc GetLineIdsStatus(GetLineIdsStatusRequest) returns (GetLineIdsStatusResponse) {
      option (google.api.http) = {
        get: "/Line/{ids}/Status"
      };
    }
    // Gets the line status for given line ids during the provided dates e.g Minor Delays
    rpc GetLineIdsStatusStartDateToEndDate(GetLineIdsStatusStartDateToEndDateRequest) returns (GetLineIdsStatusStartDateToEndDateResponse) {
      option (google.api.http) = {
        get: "/Line/{ids}/Status/{StartDate}/to/{EndDate}"
      };
    }
    // Gets all valid routes for given line id, including the sequence of stops on each route.
    rpc GetLineIdRouteSequenceDirection(GetLineIdRouteSequenceDirectionRequest) returns (RouteSequence) {
      option (google.api.http) = {
        get: "/Line/{id}/Route/Sequence/{direction}"
      };
    }
    // Gets a list of the stations that serve the given line id
    rpc GetLineIdStopPoints(GetLineIdStopPointsRequest) returns (GetLineIdStopPointsResponse) {
      option (google.api.http) = {
        get: "/Line/{id}/StopPoints"
      };
    }
    // Gets the timetable for a specified station on the give line
    rpc GetLineIdTimetableFromStopPointId(GetLineIdTimetableFromStopPointIdRequest) returns (TimetableResponse) {
      option (google.api.http) = {
        get: "/Line/{id}/Timetable/{fromStopPointId}"
      };
    }
    // Gets the timetable for a specified station on the give line with specified destination
    rpc GetLineIdTimetableFromStopPointIdToToStopPointId(GetLineIdTimetableFromStopPointIdToToStopPointIdRequest) returns (TimetableResponse) {
      option (google.api.http) = {
        get: "/Line/{id}/Timetable/{fromStopPointId}/to/{toStopPointId}"
      };
    }
    // Returns the service type active for a mode.
    //             Currently only supports tube
    rpc GetModeActiveServiceTypes(google.protobuf.Empty) returns (GetModeActiveServiceTypesResponse) {
      option (google.api.http) = {
        get: "/Mode/ActiveServiceTypes"
      };
    }
    // Gets the next arrival predictions for all stops of a given mode
    rpc GetModeModeArrivals(GetModeModeArrivalsRequest) returns (GetModeModeArrivalsResponse) {
      option (google.api.http) = {
        get: "/Mode/{mode}/Arrivals"
      };
    }
    // Get the occupancy for bike points.
    rpc GetOccupancyBikePointsIds(GetOccupancyBikePointsIdsRequest) returns (GetOccupancyBikePointsIdsResponse) {
      option (google.api.http) = {
        get: "/Occupancy/BikePoints/{ids}"
      };
    }
    // Gets the occupancy for all car parks that have occupancy data
    rpc GetOccupancyCarPark(google.protobuf.Empty) returns (GetOccupancyCarParkResponse) {
      option (google.api.http) = {
        get: "/Occupancy/CarPark"
      };
    }
    // Gets the occupancy for a car park with a given id
    rpc GetOccupancyCarParkId(GetOccupancyCarParkIdRequest) returns (CarParkOccupancy) {
      option (google.api.http) = {
        get: "/Occupancy/CarPark/{id}"
      };
    }
    // Gets the occupancy for all charge connectors
    rpc GetOccupancyChargeConnector(google.protobuf.Empty) returns (GetOccupancyChargeConnectorResponse) {
      option (google.api.http) = {
        get: "/Occupancy/ChargeConnector"
      };
    }
    // Gets the occupancy for a charge connectors with a given id (sourceSystemPlaceId)
    rpc GetOccupancyChargeConnectorIds(GetOccupancyChargeConnectorIdsRequest) returns (GetOccupancyChargeConnectorIdsResponse) {
      option (google.api.http) = {
        get: "/Occupancy/ChargeConnector/{ids}"
      };
    }
    // Gets the places that lie within the bounding box defined by the lat/lon of its north-west and south-east corners. Optionally filters
    //             on type and can strip properties for a smaller payload.
    rpc GetPlace(GetPlaceRequest) returns (GetPlaceResponse) {
      option (google.api.http) = {
        get: "/Place"
      };
    }
    // Gets the set of streets associated with a post code.
    rpc GetPlaceAddressStreetsPostcode(GetPlaceAddressStreetsPostcodeRequest) returns (Object) {
      option (google.api.http) = {
        get: "/Place/Address/Streets/{Postcode}"
      };
    }
    // Gets a list of all of the available place property categories and keys.
    rpc GetPlaceMetaCategories(google.protobuf.Empty) returns (GetPlaceMetaCategoriesResponse) {
      option (google.api.http) = {
        get: "/Place/Meta/Categories"
      };
    }
    // Gets a list of the available types of Place.
    rpc GetPlaceMetaPlaceTypes(google.protobuf.Empty) returns (GetPlaceMetaPlaceTypesResponse) {
      option (google.api.http) = {
        get: "/Place/Meta/PlaceTypes"
      };
    }
    // Gets all places that matches the given query
    rpc GetPlaceSearch(GetPlaceSearchRequest) returns (GetPlaceSearchResponse) {
      option (google.api.http) = {
        get: "/Place/Search"
      };
    }
    // Gets all places of a given type
    rpc GetPlaceTypeTypes(GetPlaceTypeTypesRequest) returns (GetPlaceTypeTypesResponse) {
      option (google.api.http) = {
        get: "/Place/Type/{types}"
      };
    }
    // Gets the place with the given id.
    rpc GetPlaceId(GetPlaceIdRequest) returns (GetPlaceIdResponse) {
      option (google.api.http) = {
        get: "/Place/{id}"
      };
    }
    // Gets any places of the given type whose geography intersects the given latitude and longitude. In practice this means the Place
    //             must be polygonal e.g. a BoroughBoundary.
    rpc GetPlaceTypeAtLatLon(GetPlaceTypeAtLatLonRequest) returns (Object) {
      option (google.api.http) = {
        get: "/Place/{type}/At/{Lat}/{Lon}"
      };
    }
    // Gets the place overlay for a given set of co-ordinates and a given width/height.
    rpc GetPlaceTypeOverlayZLatLonWidthHeight(GetPlaceTypeOverlayZLatLonWidthHeightRequest) returns (Object) {
      option (google.api.http) = {
        get: "/Place/{type}/overlay/{z}/{Lat}/{Lon}/{width}/{height}"
      };
    }
    // Gets all roads managed by TfL
    rpc GetRoad(google.protobuf.Empty) returns (GetRoadResponse) {
      option (google.api.http) = {
        get: "/Road"
      };
    }
    // Gets a list of valid RoadDisruption categories
    rpc GetRoadMetaCategories(google.protobuf.Empty) returns (GetRoadMetaCategoriesResponse) {
      option (google.api.http) = {
        get: "/Road/Meta/Categories"
      };
    }
    // Gets a list of valid RoadDisruption severity codes
    rpc GetRoadMetaSeverities(google.protobuf.Empty) returns (GetRoadMetaSeveritiesResponse) {
      option (google.api.http) = {
        get: "/Road/Meta/Severities"
      };
    }
    // Gets a list of active disruptions filtered by disruption Ids.
    rpc GetRoadAllDisruptionDisruptionIds(GetRoadAllDisruptionDisruptionIdsRequest) returns (RoadDisruption) {
      option (google.api.http) = {
        get: "/Road/all/Disruption/{disruptionIds}"
      };
    }
    // Gets a list of disrupted streets. If no date filters are provided, current disruptions are returned.
    rpc GetRoadAllStreetDisruption(GetRoadAllStreetDisruptionRequest) returns (Object) {
      option (google.api.http) = {
        get: "/Road/all/Street/Disruption"
      };
    }
    // Gets the road with the specified id (e.g. A1)
    rpc GetRoadIds(GetRoadIdsRequest) returns (GetRoadIdsResponse) {
      option (google.api.http) = {
        get: "/Road/{ids}"
      };
    }
    // Get active disruptions, filtered by road ids
    rpc GetRoadIdsDisruption(GetRoadIdsDisruptionRequest) returns (GetRoadIdsDisruptionResponse) {
      option (google.api.http) = {
        get: "/Road/{ids}/Disruption"
      };
    }
    // Gets the specified roads with the status aggregated over the date range specified, or now until the end of today if no dates are passed.
    rpc GetRoadIdsStatus(GetRoadIdsStatusRequest) returns (GetRoadIdsStatusResponse) {
      option (google.api.http) = {
        get: "/Road/{ids}/Status"
      };
    }
    // Search the site for occurrences of the query string. The maximum number of results returned is equal to the maximum page size
    //             of 100. To return subsequent pages, use the paginated overload.
    rpc GetSearch(GetSearchRequest) returns (SearchResponse) {
      option (google.api.http) = {
        get: "/Search"
      };
    }
    // Searches the bus schedules folder on S3 for a given bus number.
    rpc GetSearchBusSchedules(GetSearchBusSchedulesRequest) returns (SearchResponse) {
      option (google.api.http) = {
        get: "/Search/BusSchedules"
      };
    }
    // Gets the available search categories.
    rpc GetSearchMetaCategories(google.protobuf.Empty) returns (GetSearchMetaCategoriesResponse) {
      option (google.api.http) = {
        get: "/Search/Meta/Categories"
      };
    }
    // Gets the available searchProvider names.
    rpc GetSearchMetaSearchProviders(google.protobuf.Empty) returns (GetSearchMetaSearchProvidersResponse) {
      option (google.api.http) = {
        get: "/Search/Meta/SearchProviders"
      };
    }
    // Gets the available sorting options.
    rpc GetSearchMetaSorts(google.protobuf.Empty) returns (GetSearchMetaSortsResponse) {
      option (google.api.http) = {
        get: "/Search/Meta/Sorts"
      };
    }
    // Gets a list of StopPoints within {radius} by the specified criteria
    rpc GetStopPoint(GetStopPointRequest) returns (StopPointsResponse) {
      option (google.api.http) = {
        get: "/StopPoint"
      };
    }
    // Gets the list of available StopPoint additional information categories
    rpc GetStopPointMetaCategories(google.protobuf.Empty) returns (GetStopPointMetaCategoriesResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Meta/Categories"
      };
    }
    // Gets the list of available StopPoint modes
    rpc GetStopPointMetaModes(google.protobuf.Empty) returns (GetStopPointMetaModesResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Meta/Modes"
      };
    }
    // Gets the list of available StopPoint types
    rpc GetStopPointMetaStopTypes(google.protobuf.Empty) returns (GetStopPointMetaStopTypesResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Meta/StopTypes"
      };
    }
    // Gets a list of StopPoints filtered by the modes available at that StopPoint.
    rpc GetStopPointModeModes(GetStopPointModeModesRequest) returns (StopPointsResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Mode/{modes}"
      };
    }
    // Gets a distinct list of disrupted stop points for the given modes
    rpc GetStopPointModeModesDisruption(GetStopPointModeModesDisruptionRequest) returns (GetStopPointModeModesDisruptionResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Mode/{modes}/Disruption"
      };
    }
    // Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code.
    rpc GetStopPointSearch(GetStopPointSearchRequest) returns (SearchResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Search"
      };
    }
    // Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code.
    rpc GetStopPointSearchQuery(GetStopPointSearchQueryRequest) returns (SearchResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Search/{query}"
      };
    }
    // Gets the service types for a given stoppoint
    rpc GetStopPointServiceTypes(GetStopPointServiceTypesRequest) returns (GetStopPointServiceTypesResponse) {
      option (google.api.http) = {
        get: "/StopPoint/ServiceTypes"
      };
    }
    // Gets a StopPoint for a given sms code.
    rpc GetStopPointSmsId(GetStopPointSmsIdRequest) returns (Object) {
      option (google.api.http) = {
        get: "/StopPoint/Sms/{id}"
      };
    }
    // Gets all stop points of a given type
    rpc GetStopPointTypeTypes(GetStopPointTypeTypesRequest) returns (GetStopPointTypeTypesResponse) {
      option (google.api.http) = {
        get: "/StopPoint/Type/{types}"
      };
    }
    // Gets a list of StopPoints corresponding to the given list of stop ids.
    rpc GetStopPointIds(GetStopPointIdsRequest) returns (GetStopPointIdsResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{ids}"
      };
    }
    // Gets all disruptions for the specified StopPointId, plus disruptions for any child Naptan records it may have.
    rpc GetStopPointIdsDisruption(GetStopPointIdsDisruptionRequest) returns (GetStopPointIdsDisruptionResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{ids}/Disruption"
      };
    }
    // Gets the list of arrival predictions for the given stop point id
    rpc GetStopPointIdArrivals(GetStopPointIdArrivalsRequest) returns (GetStopPointIdArrivalsResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{id}/Arrivals"
      };
    }
    // Gets Stopoints that are reachable from a station/line combination.
    rpc GetStopPointIdCanReachOnLineLineId(GetStopPointIdCanReachOnLineLineIdRequest) returns (GetStopPointIdCanReachOnLineLineIdResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{id}/CanReachOnLine/{lineId}"
      };
    }
    // Gets all the Crowding data (static) for the StopPointId, plus crowding data for a given line and optionally a particular direction.
    rpc GetStopPointIdCrowdingLine(GetStopPointIdCrowdingLineRequest) returns (GetStopPointIdCrowdingLineResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{id}/Crowding/{line}"
      };
    }
    // Returns the canonical direction, "inbound" or "outbound", for a given pair of stop point Ids in the direction from -&gt; to.
    rpc GetStopPointIdDirectionToToStopPointId(GetStopPointIdDirectionToToStopPointIdRequest) returns (google.protobuf.Empty) {
      option (google.api.http) = {
        get: "/StopPoint/{id}/DirectionTo/{toStopPointId}"
      };
    }
    // Returns the route sections for all the lines that service the given stop point ids
    rpc GetStopPointIdRoute(GetStopPointIdRouteRequest) returns (GetStopPointIdRouteResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{id}/Route"
      };
    }
    // Get a list of places corresponding to a given id and place types.
    rpc GetStopPointIdPlaceTypes(GetStopPointIdPlaceTypesRequest) returns (GetStopPointIdPlaceTypesResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{id}/placeTypes"
      };
    }
    // Get car parks corresponding to the given stop point id.
    rpc GetStopPointStopPointIdCarParks(GetStopPointStopPointIdCarParksRequest) returns (GetStopPointStopPointIdCarParksResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{stopPointId}/CarParks"
      };
    }
    // Gets a list of taxi ranks corresponding to the given stop point id.
    rpc GetStopPointStopPointIdTaxiRanks(GetStopPointStopPointIdTaxiRanksRequest) returns (GetStopPointStopPointIdTaxiRanksResponse) {
      option (google.api.http) = {
        get: "/StopPoint/{stopPointId}/TaxiRanks"
      };
    }
    // Gets the TravelTime overlay.
    rpc GetTravelTimesCompareOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeight(GetTravelTimesCompareOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest) returns (Object) {
      option (google.api.http) = {
        get: "/TravelTimes/compareOverlay/{z}/mapcenter/{mapCenterLat}/{mapCenterLon}/pinlocation/{pinLat}/{pinLon}/dimensions/{width}/{height}"
      };
    }
    // Gets the TravelTime overlay.
    rpc GetTravelTimesOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeight(GetTravelTimesOverlayZMapcenterMapCenterLatMapCenterLonPinlocationPinLatPinLonDimensionsWidthHeightRequest) returns (Object) {
      option (google.api.http) = {
        get: "/TravelTimes/overlay/{z}/mapcenter/{mapCenterLat}/{mapCenterLon}/pinlocation/{pinLat}/{pinLon}/dimensions/{width}/{height}"
      };
    }
    // Gets the Emissions Surcharge compliance for the Vehicle
    rpc GetVehicleEmissionSurcharge(GetVehicleEmissionSurchargeRequest) returns (EmissionsSurchargeVehicle) {
      option (google.api.http) = {
        get: "/Vehicle/EmissionSurcharge"
      };
    }
    // Gets the predictions for a given list of vehicle Id's.
    rpc GetVehicleIdsArrivals(GetVehicleIdsArrivalsRequest) returns (GetVehicleIdsArrivalsResponse) {
      option (google.api.http) = {
        get: "/Vehicle/{ids}/Arrivals"
      };
    }
}
