syntax = "proto3";

import "google/api/annotations.proto";

package genomics;

message PostV1AnnotationsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    Annotation body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1AnnotationsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchAnnotationsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1AnnotationsAnnotationIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    // The ID of the annotation to be retrieved.
    string annotationId = 4;
    string bearer_token = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PutV1AnnotationsAnnotationIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    // The ID of the annotation to be updated.
    string annotationId = 4;
    string bearer_token = 5;
    Annotation body = 6;
    string callback = 7;
    string fields = 8;
    string key = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    // An optional mask specifying which fields to update. Mutable fields are
    // name,
    // variant,
    // transcript, and
    // info. If unspecified, all mutable
    // fields will be updated.
    string updateMask = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message DeleteV1AnnotationsAnnotationIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    // The ID of the annotation to be deleted.
    string annotationId = 4;
    string bearer_token = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1Annotations:BatchCreateRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchCreateAnnotationsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1AnnotationsetsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    AnnotationSet body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1AnnotationsetsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchAnnotationSetsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1AnnotationsetsAnnotationSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    // The ID of the annotation set to be retrieved.
    string annotationSetId = 4;
    string bearer_token = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PutV1AnnotationsetsAnnotationSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    // The ID of the annotation set to be updated.
    string annotationSetId = 4;
    string bearer_token = 5;
    AnnotationSet body = 6;
    string callback = 7;
    string fields = 8;
    string key = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    // An optional mask specifying which fields to update. Mutable fields are
    // name,
    // source_uri, and
    // info. If unspecified, all
    // mutable fields will be updated.
    string updateMask = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message DeleteV1AnnotationsetsAnnotationSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    // The ID of the annotation set to be deleted.
    string annotationSetId = 4;
    string bearer_token = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1CallsetsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CallSet body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1CallsetsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchCallSetsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1CallsetsCallSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    // The ID of the call set.
    string callSetId = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message DeleteV1CallsetsCallSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    // The ID of the call set to be deleted.
    string callSetId = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1DatasetsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 50. The maximum value is 1024.
    int32 pageSize = 9;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    // Required. The Google Cloud project ID to list datasets for.
    string projectId = 13;
    string quotaUser = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message PostV1DatasetsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    Dataset body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1DatasetsDatasetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // The ID of the dataset.
    string datasetId = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message DeleteV1DatasetsDatasetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // The ID of the dataset to be deleted.
    string datasetId = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1DatasetsDatasetId:UndeleteRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    UndeleteDatasetRequest body = 5;
    string callback = 6;
    // The ID of the dataset to be undeleted.
    string datasetId = 7;
    string fields = 8;
    string key = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1ReadgroupsetsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchReadGroupSetsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1ReadgroupsetsReadGroupSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The ID of the read group set.
    string readGroupSetId = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message DeleteV1ReadgroupsetsReadGroupSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The ID of the read group set to be deleted. The caller must have WRITE
    // permissions to the dataset associated with this read group set.
    string readGroupSetId = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1ReadgroupsetsReadGroupSetIdCoveragebucketsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // The end position of the range on the reference, 0-based exclusive. If
    // specified, `referenceName` must also be specified. If unset or 0, defaults
    // to the length of the reference.
    string end = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 1024. The maximum value is 2048.
    int32 pageSize = 10;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 11;
    boolean pp = 12;
    boolean prettyPrint = 13;
    string quotaUser = 14;
    // Required. The ID of the read group set over which coverage is requested.
    string readGroupSetId = 15;
    // The name of the reference to query, within the reference set associated
    // with this query. Optional.
    string referenceName = 16;
    // The start position of the range on the reference, 0-based inclusive. If
    // specified, `referenceName` must also be specified. Defaults to 0.
    string start = 17;
    // The desired width of each reported coverage bucket in base pairs. This
    // will be rounded down to the nearest precomputed bucket width; the value
    // of which is returned as `bucketWidth` in the response. Defaults
    // to infinity (each bucket spans an entire reference sequence) or the length
    // of the target range, if specified. The smallest precomputed
    // `bucketWidth` is currently 2048 base pairs; this is subject to
    // change.
    string targetBucketWidth = 18;
    string uploadType = 19;
    string upload_protocol = 20;
}

message PostV1ReadgroupsetsReadGroupSetId:ExportRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ExportReadGroupSetRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The ID of the read group set to export. The caller must have
    // READ access to this read group set.
    string readGroupSetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Readgroupsets:ImportRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ImportReadGroupSetsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1ReadsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchReadsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1ReferencesSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchReferencesRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1ReferencesReferenceIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The ID of the reference.
    string referenceId = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1ReferencesReferenceIdBasesRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // The end position (0-based, exclusive) of this query. Defaults to the length
    // of this reference.
    string end = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    // The maximum number of bases to return in a single page. If unspecified,
    // defaults to 200Kbp (kilo base pairs). The maximum value is 10Mbp (mega base
    // pairs).
    int32 pageSize = 10;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 11;
    boolean pp = 12;
    boolean prettyPrint = 13;
    string quotaUser = 14;
    // The ID of the reference.
    string referenceId = 15;
    // The start position (0-based) of this query. Defaults to 0.
    string start = 16;
    string uploadType = 17;
    string upload_protocol = 18;
}

message PostV1ReferencesetsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchReferenceSetsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1ReferencesetsReferenceSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The ID of the reference set.
    string referenceSetId = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1VariantsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    Variant body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1VariantsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchVariantsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1VariantsVariantIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    string uploadType = 12;
    string upload_protocol = 13;
    // The ID of the variant.
    string variantId = 14;
}

message DeleteV1VariantsVariantIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    string uploadType = 12;
    string upload_protocol = 13;
    // The ID of the variant to be deleted.
    string variantId = 14;
}

message PostV1Variants:ImportRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ImportVariantsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1Variants:MergeRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    MergeVariantsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1VariantsetsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    VariantSet body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1VariantsetsSearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchVariantSetsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1VariantsetsVariantSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    string uploadType = 12;
    string upload_protocol = 13;
    // Required. The ID of the variant set.
    string variantSetId = 14;
}

message DeleteV1VariantsetsVariantSetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    string uploadType = 12;
    string upload_protocol = 13;
    // The ID of the variant set to be deleted.
    string variantSetId = 14;
}

message PostV1VariantsetsVariantSetId:ExportRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ExportVariantSetRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
    // Required. The ID of the variant set that contains variant data which
    // should be exported. The caller must have READ access to this variant set.
    string variantSetId = 15;
}

message GetV1NameRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    // A string for filtering Operations.
    // The following filter fields are supported&#58;
    // 
    // * projectId&#58; Required. Corresponds to
    //   OperationMetadata.projectId.
    // * createTime&#58; The time this job was created, in seconds from the
    //   [epoch](http://en.wikipedia.org/wiki/Unix_time). Can use `>=` and/or `<=`
    //   operators.
    // * status&#58; Can be `RUNNING`, `SUCCESS`, `FAILURE`, or `CANCELED`. Only
    //   one status may be specified.
    // * labels.key where key is a label key.
    // 
    // Examples&#58;
    // 
    // * `projectId = my-project AND createTime >= 1432140000`
    // * `projectId = my-project AND createTime >= 1432140000 AND createTime <= 1432150000 AND status = RUNNING`
    // * `projectId = my-project AND labels.color = *`
    // * `projectId = my-project AND labels.color = red`
    string filter = 7;
    string key = 8;
    // The name of the operation's parent resource.
    string name = 9;
    string oauth_token = 10;
    // The maximum number of results to return. If unspecified, defaults to
    // 256. The maximum value is 2048.
    int32 pageSize = 11;
    // The standard list page token.
    string pageToken = 12;
    boolean pp = 13;
    boolean prettyPrint = 14;
    string quotaUser = 15;
    string uploadType = 16;
    string upload_protocol = 17;
}

message PostV1Name:CancelRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CancelOperationRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    // The name of the operation resource to be cancelled.
    string name = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Resource:GetIamPolicyRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    GetIamPolicyRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // REQUIRED: The resource for which policy is being specified. Format is
    // `datasets/<dataset ID>`.
    string resource = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Resource:SetIamPolicyRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SetIamPolicyRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // REQUIRED: The resource for which policy is being specified. Format is
    // `datasets/<dataset ID>`.
    string resource = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Resource:TestIamPermissionsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    TestIamPermissionsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // REQUIRED: The resource for which policy is being specified. Format is
    // `datasets/<dataset ID>`.
    string resource = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

enum $.Xgafv {
    $XGAFV_1 = 0;
    $XGAFV_2 = 1;
}

message Annotation {
    // The annotation set to which this annotation belongs.
    string annotationSetId = 1;
    // The end position of the range on the reference, 0-based exclusive.
    string end = 2;
    // The server-generated annotation ID, unique across all annotations.
    string id = 3;
    // A map of additional read alignment information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 4;
    // The display name of this annotation.
    string name = 5;
    // The ID of the Google Genomics reference associated with this range.
    string referenceId = 6;
    // The display name corresponding to the reference specified by
    // `referenceId`, for example `chr1`, `1`, or `chrX`.
    string referenceName = 7;
    // Whether this range refers to the reverse strand, as opposed to the forward
    // strand. Note that regardless of this field, the start/end position of the
    // range always refer to the forward strand.
    bool reverseStrand = 8;
    // The start position of the range on the reference, 0-based inclusive.
    string start = 9;
    // A transcript value represents the assertion that a particular region of
    // the reference genome may be transcribed as RNA. An alternative splicing
    // pattern would be represented as a separate transcript object. This field
    // is only set for annotations of type `TRANSCRIPT`.
    Transcript transcript = 10;
    // The data type for this annotation. Must match the containing annotation
    // set's type.
    enum Annotation_Type {
        ANNOTATION_TYPE_ANNOTATION_TYPE_UNSPECIFIED = 0;
        ANNOTATION_TYPE_GENERIC = 1;
        ANNOTATION_TYPE_VARIANT = 2;
        ANNOTATION_TYPE_GENE = 3;
        ANNOTATION_TYPE_TRANSCRIPT = 4;
    }
    Annotation_Type type = 11;
    // A variant annotation, which describes the effect of a variant on the
    // genome, the coding sequence, and/or higher level consequences at the
    // organism level e.g. pathogenicity. This field is only set for annotations
    // of type `VARIANT`.
    VariantAnnotation variant = 12;
}

message AnnotationSet {
    // The dataset to which this annotation set belongs.
    string datasetId = 1;
    // The server-generated annotation set ID, unique across all annotation sets.
    string id = 2;
    // A map of additional read alignment information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 3;
    // The display name for this annotation set.
    string name = 4;
    // The ID of the reference set that defines the coordinate space for this
    // set's annotations.
    string referenceSetId = 5;
    // The source URI describing the file from which this annotation set was
    // generated, if any.
    string sourceUri = 6;
    // The type of annotations contained within this set.
    enum AnnotationSet_Type {
        ANNOTATIONSET_TYPE_ANNOTATION_TYPE_UNSPECIFIED = 0;
        ANNOTATIONSET_TYPE_GENERIC = 1;
        ANNOTATIONSET_TYPE_VARIANT = 2;
        ANNOTATIONSET_TYPE_GENE = 3;
        ANNOTATIONSET_TYPE_TRANSCRIPT = 4;
    }
    AnnotationSet_Type type = 7;
}

message BatchCreateAnnotationsRequest {
    // The annotations to be created. At most 4096 can be specified in a single
    // request.
    repeated Annotation annotations = 1;
    // A unique request ID which enables the server to detect duplicated requests.
    // If provided, duplicated requests will result in the same response; if not
    // provided, duplicated requests may result in duplicated data. For a given
    // annotation set, callers should not reuse `request_id`s when writing
    // different batches of annotations - behavior in this case is undefined.
    // A common approach is to use a UUID. For batch jobs where worker crashes are
    // a possibility, consider using some unique variant of a worker or run ID.
    string requestId = 2;
}

message BatchCreateAnnotationsResponse {
    // The resulting per-annotation entries, ordered consistently with the
    // original request.
    repeated Entry entries = 1;
}

message Binding {
    // Specifies the identities requesting access for a Cloud Platform resource.
    // `members` can have the following values:
    // 
    // * `allUsers`: A special identifier that represents anyone who is
    //    on the internet; with or without a Google account.
    // 
    // * `allAuthenticatedUsers`: A special identifier that represents anyone
    //    who is authenticated with a Google account or a service account.
    // 
    // * `user:{emailid}`: An email address that represents a specific Google
    //    account. For example, `alice@gmail.com` or `joe@example.com`.
    // 
    // 
    // * `serviceAccount:{emailid}`: An email address that represents a service
    //    account. For example, `my-other-app@appspot.gserviceaccount.com`.
    // 
    // * `group:{emailid}`: An email address that represents a Google group.
    //    For example, `admins@example.com`.
    // 
    // 
    // * `domain:{domain}`: A Google Apps domain name that represents all the
    //    users of that domain. For example, `google.com` or `example.com`.
    // 
    repeated string members = 1;
    // Role that is assigned to `members`.
    // For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
    // Required
    string role = 2;
}

message CallSet {
    // The date this call set was created in milliseconds from the epoch.
    string created = 1;
    // The server-generated call set ID, unique across all call sets.
    string id = 2;
    // A map of additional call set information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 3;
    // The call set name.
    string name = 4;
    // The sample ID this call set corresponds to.
    string sampleId = 5;
    // The IDs of the variant sets this call set belongs to. This field must
    // have exactly length one, as a call set belongs to a single variant set.
    // This field is repeated for compatibility with the
    // [GA4GH 0.5.1
    // API](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).
    repeated string variantSetIds = 6;
}

message CancelOperationRequest {
}

message CigarUnit {
    enum CigarUnit_Operation {
        CIGARUNIT_OPERATION_OPERATION_UNSPECIFIED = 0;
        CIGARUNIT_OPERATION_ALIGNMENT_MATCH = 1;
        CIGARUNIT_OPERATION_INSERT = 2;
        CIGARUNIT_OPERATION_DELETE = 3;
        CIGARUNIT_OPERATION_SKIP = 4;
        CIGARUNIT_OPERATION_CLIP_SOFT = 5;
        CIGARUNIT_OPERATION_CLIP_HARD = 6;
        CIGARUNIT_OPERATION_PAD = 7;
        CIGARUNIT_OPERATION_SEQUENCE_MATCH = 8;
        CIGARUNIT_OPERATION_SEQUENCE_MISMATCH = 9;
    }
    CigarUnit_Operation operation = 1;
    // The number of genomic bases that the operation runs for. Required.
    string operationLength = 2;
    // `referenceSequence` is only used at mismatches
    // (`SEQUENCE_MISMATCH`) and deletions (`DELETE`).
    // Filling this field replaces SAM's MD tag. If the relevant information is
    // not available, this field is unset.
    string referenceSequence = 3;
}

message ClinicalCondition {
    // The MedGen concept id associated with this gene.
    // Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen
    string conceptId = 1;
    // The set of external IDs for this condition.
    repeated ExternalId externalIds = 2;
    // A set of names for the condition.
    repeated string names = 3;
    // The OMIM id for this condition.
    // Search for these IDs at http://omim.org
    string omimId = 4;
}

message CodingSequence {
    // The end of the coding sequence on this annotation's reference sequence,
    // 0-based exclusive. Note that this position is relative to the reference
    // start, and *not* the containing annotation start.
    string end = 1;
    // The start of the coding sequence on this annotation's reference sequence,
    // 0-based inclusive. Note that this position is relative to the reference
    // start, and *not* the containing annotation start.
    string start = 2;
}

message ComputeEngine {
    // The names of the disks that were created for this pipeline.
    repeated string diskNames = 1;
    // The instance on which the operation is running.
    string instanceName = 2;
    // The machine type of the instance.
    string machineType = 3;
    // The availability zone in which the instance resides.
    string zone = 4;
}

message CoverageBucket {
    // The average number of reads which are aligned to each individual
    // reference base in this bucket.
    float meanCoverage = 1;
    // The genomic coordinate range spanned by this bucket.
    Range range = 2;
}

message Dataset {
    // The time this dataset was created, in seconds from the epoch.
    string createTime = 1;
    // The server-generated dataset ID, unique across all datasets.
    string id = 2;
    // The dataset name.
    string name = 3;
    // The Google Cloud project ID that this dataset belongs to.
    string projectId = 4;
}

message Empty {
}

message Entry {
    // The created annotation, if creation was successful.
    Annotation annotation = 1;
    // The creation status.
    Status status = 2;
}

message Exon {
    // The end position of the exon on this annotation's reference sequence,
    // 0-based exclusive. Note that this is relative to the reference start, and
    // *not* the containing annotation start.
    string end = 1;
    // The frame of this exon. Contains a value of 0, 1, or 2, which indicates
    // the offset of the first coding base of the exon within the reading frame
    // of the coding DNA sequence, if any. This field is dependent on the
    // strandedness of this annotation (see
    // Annotation.reverse_strand).
    // For forward stranded annotations, this offset is relative to the
    // exon.start. For reverse
    // strand annotations, this offset is relative to the
    // exon.end `- 1`.
    // 
    // Unset if this exon does not intersect the coding sequence. Upon creation
    // of a transcript, the frame must be populated for all or none of the
    // coding exons.
    int32 frame = 2;
    // The start position of the exon on this annotation's reference sequence,
    // 0-based inclusive. Note that this is relative to the reference start, and
    // **not** the containing annotation start.
    string start = 3;
}

message Experiment {
    // The instrument model used as part of this experiment. This maps to
    // sequencing technology in the SAM spec.
    string instrumentModel = 1;
    // A client-supplied library identifier; a library is a collection of DNA
    // fragments which have been prepared for sequencing from a sample. This
    // field is important for quality control as error or bias can be introduced
    // during sample preparation.
    string libraryId = 2;
    // The platform unit used as part of this experiment, for example
    // flowcell-barcode.lane for Illumina or slide for SOLiD. Corresponds to the
    // @RG PU field in the SAM spec.
    string platformUnit = 3;
    // The sequencing center used as part of this experiment.
    string sequencingCenter = 4;
}

message ExportReadGroupSetRequest {
    // Required. A Google Cloud Storage URI for the exported BAM file.
    // The currently authenticated user must have write access to the new file.
    // An error will be returned if the URI already contains data.
    string exportUri = 1;
    // Required. The Google Cloud project ID that owns this
    // export. The caller must have WRITE access to this project.
    string projectId = 2;
    // The reference names to export. If this is not specified, all reference
    // sequences, including unmapped reads, are exported.
    // Use `*` to export only unmapped reads.
    repeated string referenceNames = 3;
}

message ExportVariantSetRequest {
    // Required. The BigQuery dataset to export data to. This dataset must already
    // exist. Note that this is distinct from the Genomics concept of "dataset".
    string bigqueryDataset = 1;
    // Required. The BigQuery table to export data to.
    // If the table doesn't exist, it will be created. If it already exists, it
    // will be overwritten.
    string bigqueryTable = 2;
    // If provided, only variant call information from the specified call sets
    // will be exported. By default all variant calls are exported.
    repeated string callSetIds = 3;
    // The format for the exported data.
    enum ExportVariantSetRequest_Format {
        EXPORTVARIANTSETREQUEST_FORMAT_FORMAT_UNSPECIFIED = 0;
        EXPORTVARIANTSETREQUEST_FORMAT_FORMAT_BIGQUERY = 1;
    }
    ExportVariantSetRequest_Format format = 4;
    // Required. The Google Cloud project ID that owns the destination
    // BigQuery dataset. The caller must have WRITE access to this project.  This
    // project will also own the resulting export job.
    string projectId = 5;
}

message ExternalId {
    // The id used by the source of this data.
    string id = 1;
    // The name of the source of this data.
    string sourceName = 2;
}

message GetIamPolicyRequest {
}

message ImportReadGroupSetsRequest {
    // Required. The ID of the dataset these read group sets will belong to. The
    // caller must have WRITE permissions to this dataset.
    string datasetId = 1;
    // The partition strategy describes how read groups are partitioned into read
    // group sets.
    enum ImportReadGroupSetsRequest_PartitionStrategy {
        IMPORTREADGROUPSETSREQUEST_PARTITIONSTRATEGY_PARTITION_STRATEGY_UNSPECIFIED = 0;
        IMPORTREADGROUPSETSREQUEST_PARTITIONSTRATEGY_PER_FILE_PER_SAMPLE = 1;
        IMPORTREADGROUPSETSREQUEST_PARTITIONSTRATEGY_MERGE_ALL = 2;
    }
    ImportReadGroupSetsRequest_PartitionStrategy partitionStrategy = 2;
    // The reference set to which the imported read group sets are aligned to, if
    // any. The reference names of this reference set must be a superset of those
    // found in the imported file headers. If no reference set id is provided, a
    // best effort is made to associate with a matching reference set.
    string referenceSetId = 3;
    // A list of URIs pointing at [BAM
    // files](https://samtools.github.io/hts-specs/SAMv1.pdf)
    // in Google Cloud Storage.
    // Those URIs can include wildcards (*), but do not add or remove
    // matching files before import has completed.
    // 
    // Note that Google Cloud Storage object listing is only eventually
    // consistent: files added may be not be immediately visible to
    // everyone. Thus, if using a wildcard it is preferable not to start
    // the import immediately after the files are created.
    repeated string sourceUris = 4;
}

message ImportReadGroupSetsResponse {
    // IDs of the read group sets that were created.
    repeated string readGroupSetIds = 1;
}

message ImportVariantsRequest {
    // The format of the variant data being imported. If unspecified, defaults to
    // to `VCF`.
    enum ImportVariantsRequest_Format {
        IMPORTVARIANTSREQUEST_FORMAT_FORMAT_UNSPECIFIED = 0;
        IMPORTVARIANTSREQUEST_FORMAT_FORMAT_VCF = 1;
        IMPORTVARIANTSREQUEST_FORMAT_FORMAT_COMPLETE_GENOMICS = 2;
    }
    ImportVariantsRequest_Format format = 1;
    // A mapping between info field keys and the InfoMergeOperations to
    // be performed on them. This is plumbed down to the MergeVariantRequests
    // generated by the resulting import job.
    map<string, string> infoMergeConfig = 2;
    // Convert reference names to the canonical representation.
    // hg19 haploytypes (those reference names containing "_hap")
    // are not modified in any way.
    // All other reference names are modified according to the following rules:
    // The reference name is capitalized.
    // The "chr" prefix is dropped for all autosomes and sex chromsomes.
    // For example "chr17" becomes "17" and "chrX" becomes "X".
    // All mitochondrial chromosomes ("chrM", "chrMT", etc) become "MT".
    bool normalizeReferenceNames = 3;
    // A list of URIs referencing variant files in Google Cloud Storage. URIs can
    // include wildcards [as described
    // here](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).
    // Note that recursive wildcards ('**') are not supported.
    repeated string sourceUris = 4;
    // Required. The variant set to which variant data should be imported.
    string variantSetId = 5;
}

message ImportVariantsResponse {
    // IDs of the call sets created during the import.
    repeated string callSetIds = 1;
}

message LinearAlignment {
    // Represents the local alignment of this sequence (alignment matches, indels,
    // etc) against the reference.
    repeated CigarUnit cigar = 1;
    // The mapping quality of this alignment. Represents how likely
    // the read maps to this position as opposed to other locations.
    // 
    // Specifically, this is -10 log10 Pr(mapping position is wrong), rounded to
    // the nearest integer.
    int32 mappingQuality = 2;
    // The position of this alignment.
    Position position = 3;
}

message ListBasesResponse {
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 1;
    // The offset position (0-based) of the given `sequence` from the
    // start of this `Reference`. This value will differ for each page
    // in a paginated request.
    string offset = 2;
    // A substring of the bases that make up this reference.
    string sequence = 3;
}

message ListCoverageBucketsResponse {
    // The length of each coverage bucket in base pairs. Note that buckets at the
    // end of a reference sequence may be shorter. This value is omitted if the
    // bucket width is infinity (the default behaviour, with no range or
    // `targetBucketWidth`).
    string bucketWidth = 1;
    // The coverage buckets. The list of buckets is sparse; a bucket with 0
    // overlapping reads is not returned. A bucket never crosses more than one
    // reference sequence. Each bucket has width `bucketWidth`, unless
    // its end is the end of the reference sequence.
    repeated CoverageBucket coverageBuckets = 2;
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 3;
}

message ListDatasetsResponse {
    // The list of matching Datasets.
    repeated Dataset datasets = 1;
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 2;
}

message ListOperationsResponse {
    // The standard List next-page token.
    string nextPageToken = 1;
    // A list of operations that matches the specified filter in the request.
    repeated Operation operations = 2;
}

message MergeVariantsRequest {
    // A mapping between info field keys and the InfoMergeOperations to
    // be performed on them.
    map<string, string> infoMergeConfig = 1;
    // The destination variant set.
    string variantSetId = 2;
    // The variants to be merged with existing variants.
    repeated Variant variants = 3;
}

message Operation {
    // If the value is `false`, it means the operation is still in progress.
    // If `true`, the operation is completed, and either `error` or `response` is
    // available.
    bool done = 1;
    // The error result of the operation in case of failure or cancellation.
    Status error = 2;
    // An OperationMetadata object. This will always be returned with the Operation.
    map<string, > metadata = 3;
    // The server-assigned name, which is only unique within the same service that originally returns it. For example&#58; `operations/CJHU7Oi_ChDrveSpBRjfuL-qzoWAgEw`
    string name = 4;
    // If importing ReadGroupSets, an ImportReadGroupSetsResponse is returned. If importing Variants, an ImportVariantsResponse is returned. For pipelines and exports, an Empty response is returned.
    map<string, > response = 5;
}

message OperationEvent {
    // Required description of event.
    string description = 1;
    // Optional time of when event finished. An event can have a start time and no
    // finish time. If an event has a finish time, there must be a start time.
    string endTime = 2;
    // Optional time of when event started.
    string startTime = 3;
}

message OperationMetadata {
    // This field is deprecated. Use `labels` instead. Optionally provided by the
    // caller when submitting the request that creates the operation.
    string clientId = 1;
    // The time at which the job was submitted to the Genomics service.
    string createTime = 2;
    // The time at which the job stopped running.
    string endTime = 3;
    // Optional event messages that were generated during the job's execution.
    // This also contains any warnings that were generated during import
    // or export.
    repeated OperationEvent events = 4;
    // Optionally provided by the caller when submitting the request that creates
    // the operation.
    map<string, string> labels = 5;
    // The Google Cloud Project in which the job is scoped.
    string projectId = 6;
    // The original request that started the operation. Note that this will be in
    // current version of the API. If the operation was started with v1beta2 API
    // and a GetOperation is performed on v1 API, a v1 request will be returned.
    map<string, > request = 7;
    // Runtime metadata on this Operation.
    map<string, > runtimeMetadata = 8;
    // The time at which the job began to run.
    string startTime = 9;
}

message Policy {
    // Associates a list of `members` to a `role`.
    // `bindings` with no members will result in an error.
    repeated Binding bindings = 1;
    // `etag` is used for optimistic concurrency control as a way to help
    // prevent simultaneous updates of a policy from overwriting each other.
    // It is strongly suggested that systems make use of the `etag` in the
    // read-modify-write cycle to perform policy updates in order to avoid race
    // conditions: An `etag` is returned in the response to `getIamPolicy`, and
    // systems are expected to put that etag in the request to `setIamPolicy` to
    // ensure that their change will be applied to the same version of the policy.
    // 
    // If no `etag` is provided in the call to `setIamPolicy`, then the existing
    // policy is overwritten blindly.
    string etag = 2;
    // Version of the `Policy`. The default version is 0.
    int32 version = 3;
}

message Position {
    // The 0-based offset from the start of the forward strand for that reference.
    string position = 1;
    // The name of the reference in whatever reference set is being used.
    string referenceName = 2;
    // Whether this position is on the reverse strand, as opposed to the forward
    // strand.
    bool reverseStrand = 3;
}

message Program {
    // The command line used to run this program.
    string commandLine = 1;
    // The user specified locally unique ID of the program. Used along with
    // `prevProgramId` to define an ordering between programs.
    string id = 2;
    // The display name of the program. This is typically the colloquial name of
    // the tool used, for example 'bwa' or 'picard'.
    string name = 3;
    // The ID of the program run before this one.
    string prevProgramId = 4;
    // The version of the program run.
    string version = 5;
}

message Range {
    // The end position of the range on the reference, 0-based exclusive.
    string end = 1;
    // The reference sequence name, for example `chr1`,
    // `1`, or `chrX`.
    string referenceName = 2;
    // The start position of the range on the reference, 0-based inclusive.
    string start = 3;
}

message Read {
    // The quality of the read sequence contained in this alignment record
    // (equivalent to QUAL in SAM).
    // `alignedSequence` and `alignedQuality` may be shorter than the full read
    // sequence and quality. This will occur if the alignment is part of a
    // chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
    // for this read will begin/end with a hard clip operator that will indicate
    // the length of the excised sequence.
    repeated int32 alignedQuality = 1;
    // The bases of the read sequence contained in this alignment record,
    // **without CIGAR operations applied** (equivalent to SEQ in SAM).
    // `alignedSequence` and `alignedQuality` may be
    // shorter than the full read sequence and quality. This will occur if the
    // alignment is part of a chimeric alignment, or if the read was trimmed. When
    // this occurs, the CIGAR for this read will begin/end with a hard clip
    // operator that will indicate the length of the excised sequence.
    string alignedSequence = 2;
    // The linear alignment for this alignment record. This field is null for
    // unmapped reads.
    LinearAlignment alignment = 3;
    // The fragment is a PCR or optical duplicate (SAM flag 0x400).
    bool duplicateFragment = 4;
    // Whether this read did not pass filters, such as platform or vendor quality
    // controls (SAM flag 0x200).
    bool failedVendorQualityChecks = 5;
    // The observed length of the fragment, equivalent to TLEN in SAM.
    int32 fragmentLength = 6;
    // The fragment name. Equivalent to QNAME (query template name) in SAM.
    string fragmentName = 7;
    // The server-generated read ID, unique across all reads. This is different
    // from the `fragmentName`.
    string id = 8;
    // A map of additional read alignment information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 9;
    // The mapping of the primary alignment of the
    // `(readNumber+1)%numberReads` read in the fragment. It replaces
    // mate position and mate strand in SAM.
    Position nextMatePosition = 10;
    // The number of reads in the fragment (extension to SAM flag 0x1).
    int32 numberReads = 11;
    // The orientation and the distance between reads from the fragment are
    // consistent with the sequencing protocol (SAM flag 0x2).
    bool properPlacement = 12;
    // The ID of the read group this read belongs to. A read belongs to exactly
    // one read group. This is a server-generated ID which is distinct from SAM's
    // RG tag (for that value, see
    // ReadGroup.name).
    string readGroupId = 13;
    // The ID of the read group set this read belongs to. A read belongs to
    // exactly one read group set.
    string readGroupSetId = 14;
    // The read number in sequencing. 0-based and less than numberReads. This
    // field replaces SAM flag 0x40 and 0x80.
    int32 readNumber = 15;
    // Whether this alignment is secondary. Equivalent to SAM flag 0x100.
    // A secondary alignment represents an alternative to the primary alignment
    // for this read. Aligners may return secondary alignments if a read can map
    // ambiguously to multiple coordinates in the genome. By convention, each read
    // has one and only one alignment where both `secondaryAlignment`
    // and `supplementaryAlignment` are false.
    bool secondaryAlignment = 16;
    // Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
    // Supplementary alignments are used in the representation of a chimeric
    // alignment. In a chimeric alignment, a read is split into multiple
    // linear alignments that map to different reference contigs. The first
    // linear alignment in the read will be designated as the representative
    // alignment; the remaining linear alignments will be designated as
    // supplementary alignments. These alignments may have different mapping
    // quality scores. In each linear alignment in a chimeric alignment, the read
    // will be hard clipped. The `alignedSequence` and
    // `alignedQuality` fields in the alignment record will only
    // represent the bases for its respective linear alignment.
    bool supplementaryAlignment = 17;
}

message ReadGroup {
    // The dataset to which this read group belongs.
    string datasetId = 1;
    // A free-form text description of this read group.
    string description = 2;
    // The experiment used to generate this read group.
    Experiment experiment = 3;
    // The server-generated read group ID, unique for all read groups.
    // Note: This is different than the @RG ID field in the SAM spec. For that
    // value, see name.
    string id = 4;
    // A map of additional read group information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 5;
    // The read group name. This corresponds to the @RG ID field in the SAM spec.
    string name = 6;
    // The predicted insert size of this read group. The insert size is the length
    // the sequenced DNA fragment from end-to-end, not including the adapters.
    int32 predictedInsertSize = 7;
    // The programs used to generate this read group. Programs are always
    // identical for all read groups within a read group set. For this reason,
    // only the first read group in a returned set will have this field
    // populated.
    repeated Program programs = 8;
    // The reference set the reads in this read group are aligned to.
    string referenceSetId = 9;
    // A client-supplied sample identifier for the reads in this read group.
    string sampleId = 10;
}

message ReadGroupSet {
    // The dataset to which this read group set belongs.
    string datasetId = 1;
    // The filename of the original source file for this read group set, if any.
    string filename = 2;
    // The server-generated read group set ID, unique for all read group sets.
    string id = 3;
    // A map of additional read group set information.
    map<string, array> info = 4;
    // The read group set name. By default this will be initialized to the sample
    // name of the sequenced data contained in this set.
    string name = 5;
    // The read groups in this set. There are typically 1-10 read groups in a read
    // group set.
    repeated ReadGroup readGroups = 6;
    // The reference set to which the reads in this read group set are aligned.
    string referenceSetId = 7;
}

message Reference {
    // The server-generated reference ID, unique across all references.
    string id = 1;
    // The length of this reference's sequence.
    string length = 2;
    // MD5 of the upper-case sequence excluding all whitespace characters (this
    // is equivalent to SQ:M5 in SAM). This value is represented in lower case
    // hexadecimal format.
    string md5checksum = 3;
    // The name of this reference, for example `22`.
    string name = 4;
    // ID from http://www.ncbi.nlm.nih.gov/taxonomy. For example, 9606 for human.
    int32 ncbiTaxonId = 5;
    // All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
    // with a version number, for example `GCF_000001405.26`.
    repeated string sourceAccessions = 6;
    // The URI from which the sequence was obtained. Typically specifies a FASTA
    // format file.
    string sourceUri = 7;
}

message ReferenceBound {
    // The name of the reference associated with this reference bound.
    string referenceName = 1;
    // An upper bound (inclusive) on the starting coordinate of any
    // variant in the reference sequence.
    string upperBound = 2;
}

message ReferenceSet {
    // Public id of this reference set, such as `GRCh37`.
    string assemblyId = 1;
    // Free text description of this reference set.
    string description = 2;
    // The server-generated reference set ID, unique across all reference sets.
    string id = 3;
    // Order-independent MD5 checksum which identifies this reference set. The
    // checksum is computed by sorting all lower case hexidecimal string
    // `reference.md5checksum` (for all reference in this set) in
    // ascending lexicographic order, concatenating, and taking the MD5 of that
    // value. The resulting value is represented in lower case hexadecimal format.
    string md5checksum = 4;
    // ID from http://www.ncbi.nlm.nih.gov/taxonomy (for example, 9606 for human)
    // indicating the species which this reference set is intended to model. Note
    // that contained references may specify a different `ncbiTaxonId`, as
    // assemblies may contain reference sequences which do not belong to the
    // modeled species, for example EBV in a human reference genome.
    int32 ncbiTaxonId = 5;
    // The IDs of the reference objects that are part of this set.
    // `Reference.md5checksum` must be unique within this set.
    repeated string referenceIds = 6;
    // All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
    // with a version number, for example `NC_000001.11`.
    repeated string sourceAccessions = 7;
    // The URI from which the references were obtained.
    string sourceUri = 8;
}

message RuntimeMetadata {
    // Execution information specific to Google Compute Engine.
    ComputeEngine computeEngine = 1;
}

message SearchAnnotationSetsRequest {
    // Required. The dataset IDs to search within. Caller must have `READ` access
    // to these datasets.
    repeated string datasetIds = 1;
    // Only return annotations sets for which a substring of the name matches this
    // string (case insensitive).
    string name = 2;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 128. The maximum value is 1024.
    int32 pageSize = 3;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 4;
    // If specified, only annotation sets associated with the given reference set
    // are returned.
    string referenceSetId = 5;
    // If specified, only annotation sets that have any of these types are
    // returned.
    repeated string types = 6;
}

message SearchAnnotationSetsResponse {
    // The matching annotation sets.
    repeated AnnotationSet annotationSets = 1;
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 2;
}

message SearchAnnotationsRequest {
    // Required. The annotation sets to search within. The caller must have
    // `READ` access to these annotation sets.
    // All queried annotation sets must have the same type.
    repeated string annotationSetIds = 1;
    // The end position of the range on the reference, 0-based exclusive. If
    // referenceId or
    // referenceName
    // must be specified, Defaults to the length of the reference.
    string end = 2;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 256. The maximum value is 2048.
    int32 pageSize = 3;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 4;
    // The ID of the reference to query.
    string referenceId = 5;
    // The name of the reference to query, within the reference set associated
    // with this query.
    string referenceName = 6;
    // The start position of the range on the reference, 0-based inclusive. If
    // specified,
    // referenceId or
    // referenceName
    // must be specified. Defaults to 0.
    string start = 7;
}

message SearchAnnotationsResponse {
    // The matching annotations.
    repeated Annotation annotations = 1;
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 2;
}

message SearchCallSetsRequest {
    // Only return call sets for which a substring of the name matches this
    // string.
    string name = 1;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 1024.
    int32 pageSize = 2;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 3;
    // Restrict the query to call sets within the given variant sets. At least one
    // ID must be provided.
    repeated string variantSetIds = 4;
}

message SearchCallSetsResponse {
    // The list of matching call sets.
    repeated CallSet callSets = 1;
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 2;
}

message SearchReadGroupSetsRequest {
    // Restricts this query to read group sets within the given datasets. At least
    // one ID must be provided.
    repeated string datasetIds = 1;
    // Only return read group sets for which a substring of the name matches this
    // string.
    string name = 2;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 256. The maximum value is 1024.
    int32 pageSize = 3;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 4;
}

message SearchReadGroupSetsResponse {
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 1;
    // The list of matching read group sets.
    repeated ReadGroupSet readGroupSets = 2;
}

message SearchReadsRequest {
    // The end position of the range on the reference, 0-based exclusive. If
    // specified, `referenceName` must also be specified.
    string end = 1;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 256. The maximum value is 2048.
    int32 pageSize = 2;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 3;
    // The IDs of the read groups within which to search for reads. All specified
    // read groups must belong to the same read group sets. Must specify one of
    // `readGroupSetIds` or `readGroupIds`.
    repeated string readGroupIds = 4;
    // The IDs of the read groups sets within which to search for reads. All
    // specified read group sets must be aligned against a common set of reference
    // sequences; this defines the genomic coordinates for the query. Must specify
    // one of `readGroupSetIds` or `readGroupIds`.
    repeated string readGroupSetIds = 5;
    // The reference sequence name, for example `chr1`, `1`, or `chrX`. If set to
    // `*`, only unmapped reads are returned. If unspecified, all reads (mapped
    // and unmapped) are returned.
    string referenceName = 6;
    // The start position of the range on the reference, 0-based inclusive. If
    // specified, `referenceName` must also be specified.
    string start = 7;
}

message SearchReadsResponse {
    // The list of matching alignments sorted by mapped genomic coordinate,
    // if any, ascending in position within the same reference. Unmapped reads,
    // which have no position, are returned contiguously and are sorted in
    // ascending lexicographic order by fragment name.
    repeated Read alignments = 1;
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 2;
}

message SearchReferenceSetsRequest {
    // If present, return reference sets for which a prefix of any of
    // sourceAccessions
    // match any of these strings. Accession numbers typically have a main number
    // and a version, for example `NC_000001.11`.
    repeated string accessions = 1;
    // If present, return reference sets for which a substring of their
    // `assemblyId` matches this string (case insensitive).
    string assemblyId = 2;
    // If present, return reference sets for which the
    // md5checksum matches exactly.
    repeated string md5checksums = 3;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 1024. The maximum value is 4096.
    int32 pageSize = 4;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 5;
}

message SearchReferenceSetsResponse {
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 1;
    // The matching references sets.
    repeated ReferenceSet referenceSets = 2;
}

message SearchReferencesRequest {
    // If present, return references for which a prefix of any of
    // sourceAccessions match
    // any of these strings. Accession numbers typically have a main number and a
    // version, for example `GCF_000001405.26`.
    repeated string accessions = 1;
    // If present, return references for which the
    // md5checksum matches exactly.
    repeated string md5checksums = 2;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 1024. The maximum value is 4096.
    int32 pageSize = 3;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 4;
    // If present, return only references which belong to this reference set.
    string referenceSetId = 5;
}

message SearchReferencesResponse {
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 1;
    // The matching references.
    repeated Reference references = 2;
}

message SearchVariantSetsRequest {
    // Exactly one dataset ID must be provided here. Only variant sets which
    // belong to this dataset will be returned.
    repeated string datasetIds = 1;
    // The maximum number of results to return in a single page. If unspecified,
    // defaults to 1024.
    int32 pageSize = 2;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 3;
}

message SearchVariantSetsResponse {
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 1;
    // The variant sets belonging to the requested dataset.
    repeated VariantSet variantSets = 2;
}

message SearchVariantsRequest {
    // Only return variant calls which belong to call sets with these ids.
    // Leaving this blank returns all variant calls. If a variant has no
    // calls belonging to any of these call sets, it won't be returned at all.
    repeated string callSetIds = 1;
    // The end of the window, 0-based exclusive. If unspecified or 0, defaults to
    // the length of the reference.
    string end = 2;
    // The maximum number of calls to return in a single page. Note that this
    // limit may be exceeded in the event that a matching variant contains more
    // calls than the requested maximum. If unspecified, defaults to 5000. The
    // maximum value is 10000.
    int32 maxCalls = 3;
    // The maximum number of variants to return in a single page. If unspecified,
    // defaults to 5000. The maximum value is 10000.
    int32 pageSize = 4;
    // The continuation token, which is used to page through large result sets.
    // To get the next page of results, set this parameter to the value of
    // `nextPageToken` from the previous response.
    string pageToken = 5;
    // Required. Only return variants in this reference sequence.
    string referenceName = 6;
    // The beginning of the window (0-based, inclusive) for which
    // overlapping variants should be returned. If unspecified, defaults to 0.
    string start = 7;
    // Only return variants which have exactly this name.
    string variantName = 8;
    // At most one variant set ID must be provided. Only variants from this
    // variant set will be returned. If omitted, a call set id must be included in
    // the request.
    repeated string variantSetIds = 9;
}

message SearchVariantsResponse {
    // The continuation token, which is used to page through large result sets.
    // Provide this value in a subsequent request to return the next page of
    // results. This field will be empty if there aren't any additional results.
    string nextPageToken = 1;
    // The list of matching Variants.
    repeated Variant variants = 2;
}

message SetIamPolicyRequest {
    // REQUIRED: The complete policy to be applied to the `resource`. The size of
    // the policy is limited to a few 10s of KB. An empty policy is a
    // valid policy but certain Cloud Platform services (such as Projects)
    // might reject them.
    Policy policy = 1;
}

message Status {
    // The status code, which should be an enum value of google.rpc.Code.
    int32 code = 1;
    // A list of messages that carry the error details.  There is a common set of
    // message types for APIs to use.
    message Detail {
    }
    repeated Detail details = 2;
    // A developer-facing error message, which should be in English. Any
    // user-facing error message should be localized and sent in the
    // google.rpc.Status.details field, or localized by the client.
    string message = 3;
}

message TestIamPermissionsRequest {
    // REQUIRED: The set of permissions to check for the 'resource'.
    // Permissions with wildcards (such as '*' or 'storage.*') are not allowed.
    // Allowed permissions are&#58;
    // 
    // * `genomics.datasets.create`
    // * `genomics.datasets.delete`
    // * `genomics.datasets.get`
    // * `genomics.datasets.list`
    // * `genomics.datasets.update`
    // * `genomics.datasets.getIamPolicy`
    // * `genomics.datasets.setIamPolicy`
    repeated string permissions = 1;
}

message TestIamPermissionsResponse {
    // A subset of `TestPermissionsRequest.permissions` that the caller is
    // allowed.
    repeated string permissions = 1;
}

message Transcript {
    // The range of the coding sequence for this transcript, if any. To determine
    // the exact ranges of coding sequence, intersect this range with those of the
    // exons, if any. If there are any
    // exons, the
    // codingSequence must start
    // and end within them.
    // 
    // Note that in some cases, the reference genome will not exactly match the
    // observed mRNA transcript e.g. due to variance in the source genome from
    // reference. In these cases,
    // exon.frame will not necessarily
    // match the expected reference reading frame and coding exon reference bases
    // cannot necessarily be concatenated to produce the original transcript mRNA.
    CodingSequence codingSequence = 1;
    // The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
    // this transcript. This field should be unset for genomes where transcript
    // splicing does not occur, for example prokaryotes.
    // 
    // Introns are regions of the transcript that are not included in the
    // spliced RNA product. Though not explicitly modeled here, intron ranges can
    // be deduced; all regions of this transcript that are not exons are introns.
    // 
    // Exonic sequences do not necessarily code for a translational product
    // (amino acids). Only the regions of exons bounded by the
    // codingSequence correspond
    // to coding DNA sequence.
    // 
    // Exons are ordered by start position and may not overlap.
    repeated Exon exons = 2;
    // The annotation ID of the gene from which this transcript is transcribed.
    string geneId = 3;
}

message UndeleteDatasetRequest {
}

message Variant {
    // The bases that appear instead of the reference bases.
    repeated string alternateBases = 1;
    // The variant calls for this particular variant. Each one represents the
    // determination of genotype with respect to this variant.
    repeated VariantCall calls = 2;
    // The date this variant was created, in milliseconds from the epoch.
    string created = 3;
    // The end position (0-based) of this variant. This corresponds to the first
    // base after the last base in the reference allele. So, the length of
    // the reference allele is (end - start). This is useful for variants
    // that don't explicitly give alternate bases, for example large deletions.
    string end = 4;
    // A list of filters (normally quality filters) this variant has failed.
    // `PASS` indicates this variant has passed all filters.
    repeated string filter = 5;
    // The server-generated variant ID, unique across all variants.
    string id = 6;
    // A map of additional variant information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 7;
    // Names for the variant, for example a RefSNP ID.
    repeated string names = 8;
    // A measure of how likely this variant is to be real.
    // A higher value is better.
    double quality = 9;
    // The reference bases for this variant. They start at the given
    // position.
    string referenceBases = 10;
    // The reference on which this variant occurs.
    // (such as `chr20` or `X`)
    string referenceName = 11;
    // The position at which this variant occurs (0-based).
    // This corresponds to the first base of the string of reference bases.
    string start = 12;
    // The ID of the variant set this variant belongs to.
    string variantSetId = 13;
}

message VariantAnnotation {
    // The alternate allele for this variant. If multiple alternate alleles
    // exist at this location, create a separate variant for each one, as they
    // may represent distinct conditions.
    string alternateBases = 1;
    // Describes the clinical significance of a variant.
    // It is adapted from the ClinVar controlled vocabulary for clinical
    // significance described at:
    // http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig
    enum VariantAnnotation_ClinicalSignificance {
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_CLINICAL_SIGNIFICANCE_UNSPECIFIED = 0;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_CLINICAL_SIGNIFICANCE_OTHER = 1;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_UNCERTAIN = 2;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_BENIGN = 3;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_LIKELY_BENIGN = 4;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_LIKELY_PATHOGENIC = 5;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_PATHOGENIC = 6;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_DRUG_RESPONSE = 7;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_HISTOCOMPATIBILITY = 8;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_CONFERS_SENSITIVITY = 9;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_RISK_FACTOR = 10;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_ASSOCIATION = 11;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_PROTECTIVE = 12;
        VARIANTANNOTATION_CLINICALSIGNIFICANCE_MULTIPLE_REPORTED = 13;
    }
    VariantAnnotation_ClinicalSignificance clinicalSignificance = 2;
    // The set of conditions associated with this variant.
    // A condition describes the way a variant influences human health.
    repeated ClinicalCondition conditions = 3;
    // Effect of the variant on the coding sequence.
    enum VariantAnnotation_Effect {
        VARIANTANNOTATION_EFFECT_EFFECT_UNSPECIFIED = 0;
        VARIANTANNOTATION_EFFECT_EFFECT_OTHER = 1;
        VARIANTANNOTATION_EFFECT_FRAMESHIFT = 2;
        VARIANTANNOTATION_EFFECT_FRAME_PRESERVING_INDEL = 3;
        VARIANTANNOTATION_EFFECT_SYNONYMOUS_SNP = 4;
        VARIANTANNOTATION_EFFECT_NONSYNONYMOUS_SNP = 5;
        VARIANTANNOTATION_EFFECT_STOP_GAIN = 6;
        VARIANTANNOTATION_EFFECT_STOP_LOSS = 7;
        VARIANTANNOTATION_EFFECT_SPLICE_SITE_DISRUPTION = 8;
    }
    VariantAnnotation_Effect effect = 4;
    // Google annotation ID of the gene affected by this variant. This should
    // be provided when the variant is created.
    string geneId = 5;
    // Google annotation IDs of the transcripts affected by this variant. These
    // should be provided when the variant is created.
    repeated string transcriptIds = 6;
    // Type has been adapted from ClinVar's list of variant types.
    enum VariantAnnotation_Type {
        VARIANTANNOTATION_TYPE_TYPE_UNSPECIFIED = 0;
        VARIANTANNOTATION_TYPE_TYPE_OTHER = 1;
        VARIANTANNOTATION_TYPE_INSERTION = 2;
        VARIANTANNOTATION_TYPE_DELETION = 3;
        VARIANTANNOTATION_TYPE_SUBSTITUTION = 4;
        VARIANTANNOTATION_TYPE_SNP = 5;
        VARIANTANNOTATION_TYPE_STRUCTURAL = 6;
        VARIANTANNOTATION_TYPE_CNV = 7;
    }
    VariantAnnotation_Type type = 7;
}

message VariantCall {
    // The ID of the call set this variant call belongs to.
    string callSetId = 1;
    // The name of the call set this variant call belongs to.
    string callSetName = 2;
    // The genotype of this variant call. Each value represents either the value
    // of the `referenceBases` field or a 1-based index into
    // `alternateBases`. If a variant had a `referenceBases`
    // value of `T` and an `alternateBases`
    // value of `["A", "C"]`, and the `genotype` was
    // `[2, 1]`, that would mean the call
    // represented the heterozygous value `CA` for this variant.
    // If the `genotype` was instead `[0, 1]`, the
    // represented value would be `TA`. Ordering of the
    // genotype values is important if the `phaseset` is present.
    // If a genotype is not called (that is, a `.` is present in the
    // GT string) -1 is returned.
    repeated int32 genotype = 3;
    // The genotype likelihoods for this variant call. Each array entry
    // represents how likely a specific genotype is for this call. The value
    // ordering is defined by the GL tag in the VCF spec.
    // If Phred-scaled genotype likelihood scores (PL) are available and
    // log10(P) genotype likelihood scores (GL) are not, PL scores are converted
    // to GL scores.  If both are available, PL scores are stored in `info`.
    repeated double genotypeLikelihood = 4;
    // A map of additional variant call information. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 5;
    // If this field is present, this variant call's genotype ordering implies
    // the phase of the bases and is consistent with any other variant calls in
    // the same reference sequence which have the same phaseset value.
    // When importing data from VCF, if the genotype data was phased but no
    // phase set was specified this field will be set to `*`.
    string phaseset = 6;
}

message VariantSet {
    // The dataset to which this variant set belongs.
    string datasetId = 1;
    // A textual description of this variant set.
    string description = 2;
    // The server-generated variant set ID, unique across all variant sets.
    string id = 3;
    // The metadata associated with this variant set.
    repeated VariantSetMetadata metadata = 4;
    // User-specified, mutable name.
    string name = 5;
    // A list of all references used by the variants in a variant set
    // with associated coordinate upper bounds for each one.
    repeated ReferenceBound referenceBounds = 6;
    // The reference set to which the variant set is mapped. The reference set
    // describes the alignment provenance of the variant set, while the
    // `referenceBounds` describe the shape of the actual variant data. The
    // reference set's reference names are a superset of those found in the
    // `referenceBounds`.
    // 
    // For example, given a variant set that is mapped to the GRCh38 reference set
    // and contains a single variant on reference 'X', `referenceBounds` would
    // contain only an entry for 'X', while the associated reference set
    // enumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.
    string referenceSetId = 7;
}

message VariantSetMetadata {
    // A textual description of this metadata.
    string description = 1;
    // User-provided ID field, not enforced by this API.
    // Two or more pieces of structured metadata with identical
    // id and key fields are considered equivalent.
    string id = 2;
    // Remaining structured metadata key-value pairs. This must be of the form
    // map<string, string[]> (string key mapping to a list of string values).
    map<string, array> info = 3;
    // The top-level key.
    string key = 4;
    // The number of values that can be included in a field described by this
    // metadata.
    string number = 5;
    // The type of data. Possible types include: Integer, Float,
    // Flag, Character, and String.
    enum VariantSetMetadata_Type {
        VARIANTSETMETADATA_TYPE_TYPE_UNSPECIFIED = 0;
        VARIANTSETMETADATA_TYPE_INTEGER = 1;
        VARIANTSETMETADATA_TYPE_FLOAT = 2;
        VARIANTSETMETADATA_TYPE_FLAG = 3;
        VARIANTSETMETADATA_TYPE_CHARACTER = 4;
        VARIANTSETMETADATA_TYPE_STRING = 5;
    }
    VariantSetMetadata_Type type = 6;
    // The value field for simple metadata
    string value = 7;
}

enum Alt {
    JSON = 0;
    MEDIA = 1;
    PROTO = 2;
}

service GenomicsService {
    // Creates a new annotation. Caller must have WRITE permission
    // for the associated annotation set.
    // 
    // The following fields are required:
    // 
    // * annotationSetId
    // * referenceName or
    //   referenceId
    // 
    // ### Transcripts
    // 
    // For annotations of type TRANSCRIPT, the following fields of
    // transcript must be provided:
    // 
    // * exons.start
    // * exons.end
    // 
    // All other fields may be optionally specified, unless documented as being
    // server-generated (for example, the `id` field). The annotated
    // range must be no longer than 100Mbp (mega base pairs). See the
    // Annotation resource
    // for additional restrictions on each field.
    rpc PostV1Annotations(PostV1AnnotationsRequest) returns (Annotation) {
      option (google.api.http) = {
        post: "//v1/annotations"
        body: "body"
      };
    }
    // Searches for annotations that match the given criteria. Results are
    // ordered by genomic coordinate (by reference sequence, then position).
    // Annotations with equivalent genomic coordinates are returned in an
    // unspecified order. This order is consistent, such that two queries for the
    // same content (regardless of page size) yield annotations in the same order
    // across their respective streams of paginated responses. Caller must have
    // READ permission for the queried annotation sets.
    rpc PostV1AnnotationsSearch(PostV1AnnotationsSearchRequest) returns (SearchAnnotationsResponse) {
      option (google.api.http) = {
        post: "//v1/annotations/search"
        body: "body"
      };
    }
    // Gets an annotation. Caller must have READ permission
    // for the associated annotation set.
    rpc GetV1AnnotationsAnnotationId(GetV1AnnotationsAnnotationIdRequest) returns (Annotation) {
      option (google.api.http) = {
        get: "//v1/annotations/{annotationId}"
      };
    }
    // Updates an annotation. Caller must have
    // WRITE permission for the associated dataset.
    rpc PutV1AnnotationsAnnotationId(PutV1AnnotationsAnnotationIdRequest) returns (Annotation) {
      option (google.api.http) = {
        put: "//v1/annotations/{annotationId}"
        body: "body"
      };
    }
    // Deletes an annotation. Caller must have WRITE permission for
    // the associated annotation set.
    rpc DeleteV1AnnotationsAnnotationId(DeleteV1AnnotationsAnnotationIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/annotations/{annotationId}"
      };
    }
    // Creates one or more new annotations atomically. All annotations must
    // belong to the same annotation set. Caller must have WRITE
    // permission for this annotation set. For optimal performance, batch
    // positionally adjacent annotations together.
    // 
    // If the request has a systemic issue, such as an attempt to write to
    // an inaccessible annotation set, the entire RPC will fail accordingly. For
    // lesser data issues, when possible an error will be isolated to the
    // corresponding batch entry in the response; the remaining well formed
    // annotations will be created normally.
    // 
    // For details on the requirements for each individual annotation resource,
    // see
    // CreateAnnotation.
    rpc PostV1Annotations:BatchCreate(PostV1Annotations:BatchCreateRequest) returns (BatchCreateAnnotationsResponse) {
      option (google.api.http) = {
        post: "//v1/annotations:batchCreate"
        body: "body"
      };
    }
    // Creates a new annotation set. Caller must have WRITE permission for the
    // associated dataset.
    // 
    // The following fields are required:
    // 
    //   * datasetId
    //   * referenceSetId
    // 
    // All other fields may be optionally specified, unless documented as being
    // server-generated (for example, the `id` field).
    rpc PostV1Annotationsets(PostV1AnnotationsetsRequest) returns (AnnotationSet) {
      option (google.api.http) = {
        post: "//v1/annotationsets"
        body: "body"
      };
    }
    // Searches for annotation sets that match the given criteria. Annotation sets
    // are returned in an unspecified order. This order is consistent, such that
    // two queries for the same content (regardless of page size) yield annotation
    // sets in the same order across their respective streams of paginated
    // responses. Caller must have READ permission for the queried datasets.
    rpc PostV1AnnotationsetsSearch(PostV1AnnotationsetsSearchRequest) returns (SearchAnnotationSetsResponse) {
      option (google.api.http) = {
        post: "//v1/annotationsets/search"
        body: "body"
      };
    }
    // Gets an annotation set. Caller must have READ permission for
    // the associated dataset.
    rpc GetV1AnnotationsetsAnnotationSetId(GetV1AnnotationsetsAnnotationSetIdRequest) returns (AnnotationSet) {
      option (google.api.http) = {
        get: "//v1/annotationsets/{annotationSetId}"
      };
    }
    // Updates an annotation set. The update must respect all mutability
    // restrictions and other invariants described on the annotation set resource.
    // Caller must have WRITE permission for the associated dataset.
    rpc PutV1AnnotationsetsAnnotationSetId(PutV1AnnotationsetsAnnotationSetIdRequest) returns (AnnotationSet) {
      option (google.api.http) = {
        put: "//v1/annotationsets/{annotationSetId}"
        body: "body"
      };
    }
    // Deletes an annotation set. Caller must have WRITE permission
    // for the associated annotation set.
    rpc DeleteV1AnnotationsetsAnnotationSetId(DeleteV1AnnotationsetsAnnotationSetIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/annotationsets/{annotationSetId}"
      };
    }
    // Creates a new call set.
    // 
    // For the definitions of call sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc PostV1Callsets(PostV1CallsetsRequest) returns (CallSet) {
      option (google.api.http) = {
        post: "//v1/callsets"
        body: "body"
      };
    }
    // Gets a list of call sets matching the criteria.
    // 
    // For the definitions of call sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
    rpc PostV1CallsetsSearch(PostV1CallsetsSearchRequest) returns (SearchCallSetsResponse) {
      option (google.api.http) = {
        post: "//v1/callsets/search"
        body: "body"
      };
    }
    // Gets a call set by ID.
    // 
    // For the definitions of call sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc GetV1CallsetsCallSetId(GetV1CallsetsCallSetIdRequest) returns (CallSet) {
      option (google.api.http) = {
        get: "//v1/callsets/{callSetId}"
      };
    }
    // Deletes a call set.
    // 
    // For the definitions of call sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc DeleteV1CallsetsCallSetId(DeleteV1CallsetsCallSetIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/callsets/{callSetId}"
      };
    }
    // Lists datasets within a project.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc GetV1Datasets(GetV1DatasetsRequest) returns (ListDatasetsResponse) {
      option (google.api.http) = {
        get: "//v1/datasets"
      };
    }
    // Creates a new dataset.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc PostV1Datasets(PostV1DatasetsRequest) returns (Dataset) {
      option (google.api.http) = {
        post: "//v1/datasets"
        body: "body"
      };
    }
    // Gets a dataset by ID.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc GetV1DatasetsDatasetId(GetV1DatasetsDatasetIdRequest) returns (Dataset) {
      option (google.api.http) = {
        get: "//v1/datasets/{datasetId}"
      };
    }
    // Deletes a dataset and all of its contents (all read group sets,
    // reference sets, variant sets, call sets, annotation sets, etc.)
    // This is reversible (up to one week after the deletion) via
    // the
    // datasets.undelete
    // operation.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc DeleteV1DatasetsDatasetId(DeleteV1DatasetsDatasetIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/datasets/{datasetId}"
      };
    }
    // Undeletes a dataset by restoring a dataset which was deleted via this API.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // This operation is only possible for a week after the deletion occurred.
    rpc PostV1DatasetsDatasetId:Undelete(PostV1DatasetsDatasetId:UndeleteRequest) returns (Dataset) {
      option (google.api.http) = {
        post: "//v1/datasets/{datasetId}:undelete"
        body: "body"
      };
    }
    // Searches for read group sets matching the criteria.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.searchReadGroupSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L135).
    rpc PostV1ReadgroupsetsSearch(PostV1ReadgroupsetsSearchRequest) returns (SearchReadGroupSetsResponse) {
      option (google.api.http) = {
        post: "//v1/readgroupsets/search"
        body: "body"
      };
    }
    // Gets a read group set by ID.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc GetV1ReadgroupsetsReadGroupSetId(GetV1ReadgroupsetsReadGroupSetIdRequest) returns (ReadGroupSet) {
      option (google.api.http) = {
        get: "//v1/readgroupsets/{readGroupSetId}"
      };
    }
    // Deletes a read group set.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc DeleteV1ReadgroupsetsReadGroupSetId(DeleteV1ReadgroupsetsReadGroupSetIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/readgroupsets/{readGroupSetId}"
      };
    }
    // Lists fixed width coverage buckets for a read group set, each of which
    // correspond to a range of a reference sequence. Each bucket summarizes
    // coverage information across its corresponding genomic range.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Coverage is defined as the number of reads which are aligned to a given
    // base in the reference sequence. Coverage buckets are available at several
    // precomputed bucket widths, enabling retrieval of various coverage 'zoom
    // levels'. The caller must have READ permissions for the target read group
    // set.
    rpc GetV1ReadgroupsetsReadGroupSetIdCoveragebuckets(GetV1ReadgroupsetsReadGroupSetIdCoveragebucketsRequest) returns (ListCoverageBucketsResponse) {
      option (google.api.http) = {
        get: "//v1/readgroupsets/{readGroupSetId}/coveragebuckets"
      };
    }
    // Exports a read group set to a BAM file in Google Cloud Storage.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Note that currently there may be some differences between exported BAM
    // files and the original BAM file at the time of import. See
    // ImportReadGroupSets
    // for caveats.
    rpc PostV1ReadgroupsetsReadGroupSetId:Export(PostV1ReadgroupsetsReadGroupSetId:ExportRequest) returns (Operation) {
      option (google.api.http) = {
        post: "//v1/readgroupsets/{readGroupSetId}:export"
        body: "body"
      };
    }
    // Creates read group sets by asynchronously importing the provided
    // information.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // The caller must have WRITE permissions to the dataset.
    // 
    // ## Notes on [BAM](https://samtools.github.io/hts-specs/SAMv1.pdf) import
    // 
    // - Tags will be converted to strings - tag types are not preserved
    // - Comments (`@CO`) in the input file header will not be preserved
    // - Original header order of references (`@SQ`) will not be preserved
    // - Any reverse stranded unmapped reads will be reverse complemented, and
    // their qualities (also the "BQ" and "OQ" tags, if any) will be reversed
    // - Unmapped reads will be stripped of positional information (reference name
    // and position)
    rpc PostV1Readgroupsets:Import(PostV1Readgroupsets:ImportRequest) returns (Operation) {
      option (google.api.http) = {
        post: "//v1/readgroupsets:import"
        body: "body"
      };
    }
    // Gets a list of reads for one or more read group sets.
    // 
    // For the definitions of read group sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Reads search operates over a genomic coordinate space of reference sequence
    // & position defined over the reference sequences to which the requested
    // read group sets are aligned.
    // 
    // If a target positional range is specified, search returns all reads whose
    // alignment to the reference genome overlap the range. A query which
    // specifies only read group set IDs yields all reads in those read group
    // sets, including unmapped reads.
    // 
    // All reads returned (including reads on subsequent pages) are ordered by
    // genomic coordinate (by reference sequence, then position). Reads with
    // equivalent genomic coordinates are returned in an unspecified order. This
    // order is consistent, such that two queries for the same content (regardless
    // of page size) yield reads in the same order across their respective streams
    // of paginated responses.
    // 
    // Implements
    // [GlobalAllianceApi.searchReads](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L85).
    rpc PostV1ReadsSearch(PostV1ReadsSearchRequest) returns (SearchReadsResponse) {
      option (google.api.http) = {
        post: "//v1/reads/search"
        body: "body"
      };
    }
    // Searches for references which match the given criteria.
    // 
    // For the definitions of references and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.searchReferences](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L146).
    rpc PostV1ReferencesSearch(PostV1ReferencesSearchRequest) returns (SearchReferencesResponse) {
      option (google.api.http) = {
        post: "//v1/references/search"
        body: "body"
      };
    }
    // Gets a reference.
    // 
    // For the definitions of references and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.getReference](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L158).
    rpc GetV1ReferencesReferenceId(GetV1ReferencesReferenceIdRequest) returns (Reference) {
      option (google.api.http) = {
        get: "//v1/references/{referenceId}"
      };
    }
    // Lists the bases in a reference, optionally restricted to a range.
    // 
    // For the definitions of references and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.getReferenceBases](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L221).
    rpc GetV1ReferencesReferenceIdBases(GetV1ReferencesReferenceIdBasesRequest) returns (ListBasesResponse) {
      option (google.api.http) = {
        get: "//v1/references/{referenceId}/bases"
      };
    }
    // Searches for reference sets which match the given criteria.
    // 
    // For the definitions of references and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.searchReferenceSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L71)
    rpc PostV1ReferencesetsSearch(PostV1ReferencesetsSearchRequest) returns (SearchReferenceSetsResponse) {
      option (google.api.http) = {
        post: "//v1/referencesets/search"
        body: "body"
      };
    }
    // Gets a reference set.
    // 
    // For the definitions of references and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.getReferenceSet](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L83).
    rpc GetV1ReferencesetsReferenceSetId(GetV1ReferencesetsReferenceSetIdRequest) returns (ReferenceSet) {
      option (google.api.http) = {
        get: "//v1/referencesets/{referenceSetId}"
      };
    }
    // Creates a new variant.
    // 
    // For the definitions of variants and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc PostV1Variants(PostV1VariantsRequest) returns (Variant) {
      option (google.api.http) = {
        post: "//v1/variants"
        body: "body"
      };
    }
    // Gets a list of variants matching the criteria.
    // 
    // For the definitions of variants and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
    rpc PostV1VariantsSearch(PostV1VariantsSearchRequest) returns (SearchVariantsResponse) {
      option (google.api.http) = {
        post: "//v1/variants/search"
        body: "body"
      };
    }
    // Gets a variant by ID.
    // 
    // For the definitions of variants and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc GetV1VariantsVariantId(GetV1VariantsVariantIdRequest) returns (Variant) {
      option (google.api.http) = {
        get: "//v1/variants/{variantId}"
      };
    }
    // Deletes a variant.
    // 
    // For the definitions of variants and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc DeleteV1VariantsVariantId(DeleteV1VariantsVariantIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/variants/{variantId}"
      };
    }
    // Creates variant data by asynchronously importing the provided information.
    // 
    // For the definitions of variant sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // The variants for import will be merged with any existing variant that
    // matches its reference sequence, start, end, reference bases, and
    // alternative bases. If no such variant exists, a new one will be created.
    // 
    // When variants are merged, the call information from the new variant
    // is added to the existing variant, and Variant info fields are merged
    // as specified in
    // infoMergeConfig.
    // As a special case, for single-sample VCF files, QUAL and FILTER fields will
    // be moved to the call level; these are sometimes interpreted in a
    // call-specific context.
    // Imported VCF headers are appended to the metadata already in a variant set.
    rpc PostV1Variants:Import(PostV1Variants:ImportRequest) returns (Operation) {
      option (google.api.http) = {
        post: "//v1/variants:import"
        body: "body"
      };
    }
    // Merges the given variants with existing variants.
    // 
    // For the definitions of variants and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Each variant will be
    // merged with an existing variant that matches its reference sequence,
    // start, end, reference bases, and alternative bases. If no such variant
    // exists, a new one will be created.
    // 
    // When variants are merged, the call information from the new variant
    // is added to the existing variant. Variant info fields are merged as
    // specified in the
    // infoMergeConfig
    // field of the MergeVariantsRequest.
    // 
    // Please exercise caution when using this method!  It is easy to introduce
    // mistakes in existing variants and difficult to back out of them.  For
    // example,
    // suppose you were trying to merge a new variant with an existing one and
    // both
    // variants contain calls that belong to callsets with the same callset ID.
    // 
    //     // Existing variant - irrelevant fields trimmed for clarity
    //     {
    //         "variantSetId": "10473108253681171589",
    //         "referenceName": "1",
    //         "start": "10582",
    //         "referenceBases": "G",
    //         "alternateBases": [
    //             "A"
    //         ],
    //         "calls": [
    //             {
    //                 "callSetId": "10473108253681171589-0",
    //                 "callSetName": "CALLSET0",
    //                 "genotype": [
    //                     0,
    //                     1
    //                 ],
    //             }
    //         ]
    //     }
    // 
    //     // New variant with conflicting call information
    //     {
    //         "variantSetId": "10473108253681171589",
    //         "referenceName": "1",
    //         "start": "10582",
    //         "referenceBases": "G",
    //         "alternateBases": [
    //             "A"
    //         ],
    //         "calls": [
    //             {
    //                 "callSetId": "10473108253681171589-0",
    //                 "callSetName": "CALLSET0",
    //                 "genotype": [
    //                     1,
    //                     1
    //                 ],
    //             }
    //         ]
    //     }
    // 
    // The resulting merged variant would overwrite the existing calls with those
    // from the new variant:
    // 
    //     {
    //         "variantSetId": "10473108253681171589",
    //         "referenceName": "1",
    //         "start": "10582",
    //         "referenceBases": "G",
    //         "alternateBases": [
    //             "A"
    //         ],
    //         "calls": [
    //             {
    //                 "callSetId": "10473108253681171589-0",
    //                 "callSetName": "CALLSET0",
    //                 "genotype": [
    //                     1,
    //                     1
    //                 ],
    //             }
    //         ]
    //     }
    // 
    // This may be the desired outcome, but it is up to the user to determine if
    // if that is indeed the case.
    rpc PostV1Variants:Merge(PostV1Variants:MergeRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1/variants:merge"
        body: "body"
      };
    }
    // Creates a new variant set.
    // 
    // For the definitions of variant sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // The provided variant set must have a valid `datasetId` set - all other
    // fields are optional. Note that the `id` field will be ignored, as this is
    // assigned by the server.
    rpc PostV1Variantsets(PostV1VariantsetsRequest) returns (VariantSet) {
      option (google.api.http) = {
        post: "//v1/variantsets"
        body: "body"
      };
    }
    // Returns a list of all variant sets matching search criteria.
    // 
    // For the definitions of variant sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // Implements
    // [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
    rpc PostV1VariantsetsSearch(PostV1VariantsetsSearchRequest) returns (SearchVariantSetsResponse) {
      option (google.api.http) = {
        post: "//v1/variantsets/search"
        body: "body"
      };
    }
    // Gets a variant set by ID.
    // 
    // For the definitions of variant sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc GetV1VariantsetsVariantSetId(GetV1VariantsetsVariantSetIdRequest) returns (VariantSet) {
      option (google.api.http) = {
        get: "//v1/variantsets/{variantSetId}"
      };
    }
    // Deletes a variant set including all variants, call sets, and calls within.
    // This is not reversible.
    // 
    // For the definitions of variant sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc DeleteV1VariantsetsVariantSetId(DeleteV1VariantsetsVariantSetIdRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/variantsets/{variantSetId}"
      };
    }
    // Exports variant set data to an external destination.
    // 
    // For the definitions of variant sets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc PostV1VariantsetsVariantSetId:Export(PostV1VariantsetsVariantSetId:ExportRequest) returns (Operation) {
      option (google.api.http) = {
        post: "//v1/variantsets/{variantSetId}:export"
        body: "body"
      };
    }
    // Lists operations that match the specified filter in the request.
    rpc GetV1Name(GetV1NameRequest) returns (ListOperationsResponse) {
      option (google.api.http) = {
        get: "//v1/{name}"
      };
    }
    // Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. Clients may use Operations.GetOperation or Operations.ListOperations to check whether the cancellation succeeded or the operation completed despite cancellation.
    rpc PostV1Name:Cancel(PostV1Name:CancelRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1/{name}:cancel"
        body: "body"
      };
    }
    // Gets the access control policy for the dataset. This is empty if the
    // policy or resource does not exist.
    // 
    // See <a href="/iam/docs/managing-policies#getting_a_policy">Getting a
    // Policy</a> for more information.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc PostV1Resource:GetIamPolicy(PostV1Resource:GetIamPolicyRequest) returns (Policy) {
      option (google.api.http) = {
        post: "//v1/{resource}:getIamPolicy"
        body: "body"
      };
    }
    // Sets the access control policy on the specified dataset. Replaces any
    // existing policy.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    // 
    // See <a href="/iam/docs/managing-policies#setting_a_policy">Setting a
    // Policy</a> for more information.
    rpc PostV1Resource:SetIamPolicy(PostV1Resource:SetIamPolicyRequest) returns (Policy) {
      option (google.api.http) = {
        post: "//v1/{resource}:setIamPolicy"
        body: "body"
      };
    }
    // Returns permissions that a caller has on the specified resource.
    // See <a href="/iam/docs/managing-policies#testing_permissions">Testing
    // Permissions</a> for more information.
    // 
    // For the definitions of datasets and other genomics resources, see
    // [Fundamentals of Google
    // Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
    rpc PostV1Resource:TestIamPermissions(PostV1Resource:TestIamPermissionsRequest) returns (TestIamPermissionsResponse) {
      option (google.api.http) = {
        post: "//v1/{resource}:testIamPermissions"
        body: "body"
      };
    }
}
