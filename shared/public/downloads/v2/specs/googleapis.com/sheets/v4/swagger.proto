syntax = "proto3";

import "google/api/annotations.proto";

package googlesheets;

message PostV4SpreadsheetsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    Spreadsheet body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV4SpreadsheetsSpreadsheetIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    // True if grid data should be returned.
    // This parameter is ignored if a field mask was set in the request.
    bool includeGridData = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ranges to retrieve from the spreadsheet.
    repeated string ranges = 13;
    // The spreadsheet to request.
    string spreadsheetId = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message GetV4SpreadsheetsSpreadsheetIdDeveloperMetadataMetadataIdRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    // The ID of the developer metadata to retrieve.
    int32 metadataId = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to retrieve metadata from.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetIdDeveloperMetadata:SearchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SearchDeveloperMetadataRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to retrieve metadata from.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetIdSheetsSheetId:CopyToRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CopySheetToAnotherSpreadsheetRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the sheet to copy.
    int32 sheetId = 13;
    // The ID of the spreadsheet containing the sheet to copy.
    string spreadsheetId = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // How dates, times, and durations should be represented in the output.
    // This is ignored if value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    enum GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest_DateTimeRenderOption {
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_DATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_DATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest_DateTimeRenderOption dateTimeRenderOption = 6;
    string fields = 7;
    string key = 8;
    // The major dimension that results should use.
    // 
    // For example, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`,
    // then requesting `range=A1:B2,majorDimension=ROWS` will return
    // `[[1,2],[3,4]]`,
    // whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return
    // `[[1,3],[2,4]]`.
    enum GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest_MajorDimension {
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_MAJORDIMENSION_DIMENSION_UNSPECIFIED = 0;
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_MAJORDIMENSION_ROWS = 1;
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_MAJORDIMENSION_COLUMNS = 2;
    }
    GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest_MajorDimension majorDimension = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    // The A1 notation of the values to retrieve.
    string range = 14;
    // The ID of the spreadsheet to retrieve data from.
    string spreadsheetId = 15;
    string uploadType = 16;
    string upload_protocol = 17;
    // How values should be represented in the output.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ValueRenderOption {
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_VALUERENDEROPTION_FORMATTED_VALUE = 0;
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_VALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        GETV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_VALUERENDEROPTION_FORMULA = 2;
    }
    GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ValueRenderOption valueRenderOption = 18;
}

message PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ValueRange body = 5;
    string callback = 6;
    string fields = 7;
    // Determines if the update response should include the values
    // of the cells that were updated. By default, responses
    // do not include the updated values.
    // If the range to write was larger than than the range actually written,
    // the response will include all values in the requested range (excluding
    // trailing empty rows and columns).
    bool includeValuesInResponse = 8;
    string key = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    // The A1 notation of the values to update.
    string range = 14;
    // Determines how dates, times, and durations in the response should be
    // rendered. This is ignored if response_value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    enum PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ResponseDateTimeRenderOption {
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_RESPONSEDATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_RESPONSEDATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ResponseDateTimeRenderOption responseDateTimeRenderOption = 15;
    // Determines how values in the response should be rendered.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ResponseValueRenderOption {
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_RESPONSEVALUERENDEROPTION_FORMATTED_VALUE = 0;
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_RESPONSEVALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_RESPONSEVALUERENDEROPTION_FORMULA = 2;
    }
    PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ResponseValueRenderOption responseValueRenderOption = 16;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 17;
    string uploadType = 18;
    string upload_protocol = 19;
    // How the input data should be interpreted.
    enum PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ValueInputOption {
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_VALUEINPUTOPTION_INPUT_VALUE_OPTION_UNSPECIFIED = 0;
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_VALUEINPUTOPTION_RAW = 1;
        PUTV4SPREADSHEETSSPREADSHEETIDVALUESRANGEREQUEST_VALUEINPUTOPTION_USER_ENTERED = 2;
    }
    PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest_ValueInputOption valueInputOption = 20;
}

message PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ValueRange body = 5;
    string callback = 6;
    string fields = 7;
    // Determines if the update response should include the values
    // of the cells that were appended. By default, responses
    // do not include the updated values.
    bool includeValuesInResponse = 8;
    // How the input data should be inserted.
    enum PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_InsertDataOption {
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_INSERTDATAOPTION_OVERWRITE = 0;
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_INSERTDATAOPTION_INSERT_ROWS = 1;
    }
    PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_InsertDataOption insertDataOption = 9;
    string key = 10;
    string oauth_token = 11;
    boolean pp = 12;
    boolean prettyPrint = 13;
    string quotaUser = 14;
    // The A1 notation of a range to search for a logical table of data.
    // Values will be appended after the last row of the table.
    string range = 15;
    // Determines how dates, times, and durations in the response should be
    // rendered. This is ignored if response_value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    enum PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_ResponseDateTimeRenderOption {
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_RESPONSEDATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_RESPONSEDATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_ResponseDateTimeRenderOption responseDateTimeRenderOption = 16;
    // Determines how values in the response should be rendered.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_ResponseValueRenderOption {
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_RESPONSEVALUERENDEROPTION_FORMATTED_VALUE = 0;
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_RESPONSEVALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_RESPONSEVALUERENDEROPTION_FORMULA = 2;
    }
    PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_ResponseValueRenderOption responseValueRenderOption = 17;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 18;
    string uploadType = 19;
    string upload_protocol = 20;
    // How the input data should be interpreted.
    enum PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_ValueInputOption {
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_VALUEINPUTOPTION_INPUT_VALUE_OPTION_UNSPECIFIED = 0;
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_VALUEINPUTOPTION_RAW = 1;
        POSTV4SPREADSHEETSSPREADSHEETIDVALUESRANGE:APPENDREQUEST_VALUEINPUTOPTION_USER_ENTERED = 2;
    }
    PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest_ValueInputOption valueInputOption = 21;
}

message PostV4SpreadsheetsSpreadsheetIdValuesRange:ClearRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ClearValuesRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The A1 notation of the values to clear.
    string range = 13;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message PostV4SpreadsheetsSpreadsheetIdValues:BatchClearRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchClearValuesRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetIdValues:BatchClearByDataFilterRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchClearValuesByDataFilterRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // How dates, times, and durations should be represented in the output.
    // This is ignored if value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    enum GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest_DateTimeRenderOption {
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_DATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_DATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest_DateTimeRenderOption dateTimeRenderOption = 6;
    string fields = 7;
    string key = 8;
    // The major dimension that results should use.
    // 
    // For example, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`,
    // then requesting `range=A1:B2,majorDimension=ROWS` will return
    // `[[1,2],[3,4]]`,
    // whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return
    // `[[1,3],[2,4]]`.
    enum GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest_MajorDimension {
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_MAJORDIMENSION_DIMENSION_UNSPECIFIED = 0;
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_MAJORDIMENSION_ROWS = 1;
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_MAJORDIMENSION_COLUMNS = 2;
    }
    GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest_MajorDimension majorDimension = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    // The A1 notation of the values to retrieve.
    repeated string ranges = 14;
    // The ID of the spreadsheet to retrieve data from.
    string spreadsheetId = 15;
    string uploadType = 16;
    string upload_protocol = 17;
    // How values should be represented in the output.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest_ValueRenderOption {
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_VALUERENDEROPTION_FORMATTED_VALUE = 0;
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_VALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        GETV4SPREADSHEETSSPREADSHEETIDVALUES:BATCHGETREQUEST_VALUERENDEROPTION_FORMULA = 2;
    }
    GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest_ValueRenderOption valueRenderOption = 18;
}

message PostV4SpreadsheetsSpreadsheetIdValues:BatchGetByDataFilterRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchGetValuesByDataFilterRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to retrieve data from.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetIdValues:BatchUpdateRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchUpdateValuesRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetIdValues:BatchUpdateByDataFilterRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchUpdateValuesByDataFilterRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The ID of the spreadsheet to update.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetId:BatchUpdateRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BatchUpdateSpreadsheetRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The spreadsheet to apply the updates to.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV4SpreadsheetsSpreadsheetId:GetByDataFilterRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    GetSpreadsheetByDataFilterRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // The spreadsheet to request.
    string spreadsheetId = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

enum $.Xgafv {
    $XGAFV_1 = 0;
    $XGAFV_2 = 1;
}

message AddBandingRequest {
    // The banded range to add. The bandedRangeId
    // field is optional; if one is not set, an id will be randomly generated. (It
    // is an error to specify the ID of a range that already exists.)
    BandedRange bandedRange = 1;
}

message AddBandingResponse {
    // The banded range that was added.
    BandedRange bandedRange = 1;
}

message AddChartRequest {
    // The chart that should be added to the spreadsheet, including the position
    // where it should be placed. The chartId
    // field is optional; if one is not set, an id will be randomly generated. (It
    // is an error to specify the ID of a chart that already exists.)
    EmbeddedChart chart = 1;
}

message AddChartResponse {
    // The newly added chart.
    EmbeddedChart chart = 1;
}

message AddConditionalFormatRuleRequest {
    // The zero-based index where the rule should be inserted.
    int32 index = 1;
    // The rule to add.
    ConditionalFormatRule rule = 2;
}

message AddFilterViewRequest {
    // The filter to add. The filterViewId
    // field is optional; if one is not set, an id will be randomly generated. (It
    // is an error to specify the ID of a filter that already exists.)
    FilterView filter = 1;
}

message AddFilterViewResponse {
    // The newly added filter view.
    FilterView filter = 1;
}

message AddNamedRangeRequest {
    // The named range to add. The namedRangeId
    // field is optional; if one is not set, an id will be randomly generated. (It
    // is an error to specify the ID of a range that already exists.)
    NamedRange namedRange = 1;
}

message AddNamedRangeResponse {
    // The named range to add.
    NamedRange namedRange = 1;
}

message AddProtectedRangeRequest {
    // The protected range to be added. The
    // protectedRangeId field is optional; if
    // one is not set, an id will be randomly generated. (It is an error to
    // specify the ID of a range that already exists.)
    ProtectedRange protectedRange = 1;
}

message AddProtectedRangeResponse {
    // The newly added protected range.
    ProtectedRange protectedRange = 1;
}

message AddSheetRequest {
    // The properties the new sheet should have.
    // All properties are optional.
    // The sheetId field is optional; if one is not
    // set, an id will be randomly generated. (It is an error to specify the ID
    // of a sheet that already exists.)
    SheetProperties properties = 1;
}

message AddSheetResponse {
    // The properties of the newly added sheet.
    SheetProperties properties = 1;
}

message AppendCellsRequest {
    // The fields of CellData that should be updated.
    // At least one field must be specified.
    // The root is the CellData; 'row.values.' should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The data to append.
    repeated RowData rows = 2;
    // The sheet ID to append the data to.
    int32 sheetId = 3;
}

message AppendDimensionRequest {
    // Whether rows or columns should be appended.
    enum AppendDimensionRequest_Dimension {
        APPENDDIMENSIONREQUEST_DIMENSION_DIMENSION_UNSPECIFIED = 0;
        APPENDDIMENSIONREQUEST_DIMENSION_ROWS = 1;
        APPENDDIMENSIONREQUEST_DIMENSION_COLUMNS = 2;
    }
    AppendDimensionRequest_Dimension dimension = 1;
    // The number of rows or columns to append.
    int32 length = 2;
    // The sheet to append rows or columns to.
    int32 sheetId = 3;
}

message AppendValuesResponse {
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 1;
    // The range (in A1 notation) of the table that values are being appended to
    // (before the values were appended).
    // Empty if no table was found.
    string tableRange = 2;
    // Information about the updates that were applied.
    UpdateValuesResponse updates = 3;
}

message AutoFillRequest {
    // The range to autofill. This will examine the range and detect
    // the location that has data and automatically fill that data
    // in to the rest of the range.
    GridRange range = 1;
    // The source and destination areas to autofill.
    // This explicitly lists the source of the autofill and where to
    // extend that data.
    SourceAndDestination sourceAndDestination = 2;
    // True if we should generate data with the "alternate" series.
    // This differs based on the type and amount of source data.
    bool useAlternateSeries = 3;
}

message AutoResizeDimensionsRequest {
    // The dimensions to automatically resize.
    DimensionRange dimensions = 1;
}

message BandedRange {
    // The id of the banded range.
    int32 bandedRangeId = 1;
    // Properties for column bands. These properties will be applied on a column-
    // by-column basis throughout all the columns in the range. At least one of
    // row_properties or column_properties must be specified.
    BandingProperties columnProperties = 2;
    // The range over which these properties are applied.
    GridRange range = 3;
    // Properties for row bands. These properties will be applied on a row-by-row
    // basis throughout all the rows in the range. At least one of
    // row_properties or column_properties must be specified.
    BandingProperties rowProperties = 4;
}

message BandingProperties {
    // The first color that is alternating. (Required)
    Color firstBandColor = 1;
    // The color of the last row or column. If this field is not set, the last
    // row or column will be filled with either first_band_color or
    // second_band_color, depending on the color of the previous row or
    // column.
    Color footerColor = 2;
    // The color of the first row or column. If this field is set, the first
    // row or column will be filled with this color and the colors will
    // alternate between first_band_color and second_band_color starting
    // from the second row or column. Otherwise, the first row or column will be
    // filled with first_band_color and the colors will proceed to alternate
    // as they normally would.
    Color headerColor = 3;
    // The second color that is alternating. (Required)
    Color secondBandColor = 4;
}

message BasicChartAxis {
    // The format of the title.
    // Only valid if the axis is not associated with the domain.
    TextFormat format = 1;
    // The position of this axis.
    enum BasicChartAxis_Position {
        BASICCHARTAXIS_POSITION_BASIC_CHART_AXIS_POSITION_UNSPECIFIED = 0;
        BASICCHARTAXIS_POSITION_BOTTOM_AXIS = 1;
        BASICCHARTAXIS_POSITION_LEFT_AXIS = 2;
        BASICCHARTAXIS_POSITION_RIGHT_AXIS = 3;
    }
    BasicChartAxis_Position position = 2;
    // The title of this axis. If set, this overrides any title inferred
    // from headers of the data.
    string title = 3;
    // The axis title text position.
    TextPosition titleTextPosition = 4;
}

message BasicChartDomain {
    // The data of the domain. For example, if charting stock prices over time,
    // this is the data representing the dates.
    ChartData domain = 1;
    // True to reverse the order of the domain values (horizontal axis).
    bool reversed = 2;
}

message BasicChartSeries {
    // The data being visualized in this chart series.
    ChartData series = 1;
    // The minor axis that will specify the range of values for this series.
    // For example, if charting stocks over time, the "Volume" series
    // may want to be pinned to the right with the prices pinned to the left,
    // because the scale of trading volume is different than the scale of
    // prices.
    // It is an error to specify an axis that isn't a valid minor axis
    // for the chart's type.
    enum BasicChartSeries_TargetAxi {
        BASICCHARTSERIES_TARGETAXI_BASIC_CHART_AXIS_POSITION_UNSPECIFIED = 0;
        BASICCHARTSERIES_TARGETAXI_BOTTOM_AXIS = 1;
        BASICCHARTSERIES_TARGETAXI_LEFT_AXIS = 2;
        BASICCHARTSERIES_TARGETAXI_RIGHT_AXIS = 3;
    }
    BasicChartSeries_TargetAxi targetAxis = 2;
    // The type of this series. Valid only if the
    // chartType is
    // COMBO.
    // Different types will change the way the series is visualized.
    // Only LINE, AREA,
    // and COLUMN are supported.
    enum BasicChartSeries_Type {
        BASICCHARTSERIES_TYPE_BASIC_CHART_TYPE_UNSPECIFIED = 0;
        BASICCHARTSERIES_TYPE_BAR = 1;
        BASICCHARTSERIES_TYPE_LINE = 2;
        BASICCHARTSERIES_TYPE_AREA = 3;
        BASICCHARTSERIES_TYPE_COLUMN = 4;
        BASICCHARTSERIES_TYPE_SCATTER = 5;
        BASICCHARTSERIES_TYPE_COMBO = 6;
        BASICCHARTSERIES_TYPE_STEPPED_AREA = 7;
    }
    BasicChartSeries_Type type = 3;
}

message BasicChartSpec {
    // The axis on the chart.
    repeated BasicChartAxis axis = 1;
    // The type of the chart.
    enum BasicChartSpec_ChartType {
        BASICCHARTSPEC_CHARTTYPE_BASIC_CHART_TYPE_UNSPECIFIED = 0;
        BASICCHARTSPEC_CHARTTYPE_BAR = 1;
        BASICCHARTSPEC_CHARTTYPE_LINE = 2;
        BASICCHARTSPEC_CHARTTYPE_AREA = 3;
        BASICCHARTSPEC_CHARTTYPE_COLUMN = 4;
        BASICCHARTSPEC_CHARTTYPE_SCATTER = 5;
        BASICCHARTSPEC_CHARTTYPE_COMBO = 6;
        BASICCHARTSPEC_CHARTTYPE_STEPPED_AREA = 7;
    }
    BasicChartSpec_ChartType chartType = 2;
    // The behavior of tooltips and data highlighting when hovering on data and
    // chart area.
    enum BasicChartSpec_CompareMode {
        BASICCHARTSPEC_COMPAREMODE_BASIC_CHART_COMPARE_MODE_UNSPECIFIED = 0;
        BASICCHARTSPEC_COMPAREMODE_DATUM = 1;
        BASICCHARTSPEC_COMPAREMODE_CATEGORY = 2;
    }
    BasicChartSpec_CompareMode compareMode = 3;
    // The domain of data this is charting.
    // Only a single domain is supported.
    repeated BasicChartDomain domains = 4;
    // The number of rows or columns in the data that are "headers".
    // If not set, Google Sheets will guess how many rows are headers based
    // on the data.
    // 
    // (Note that BasicChartAxis.title may override the axis title
    //  inferred from the header values.)
    int32 headerCount = 5;
    // If some values in a series are missing, gaps may appear in the chart (e.g,
    // segments of lines in a line chart will be missing).  To eliminate these
    // gaps set this to true.
    // Applies to Line, Area, and Combo charts.
    bool interpolateNulls = 6;
    // The position of the chart legend.
    enum BasicChartSpec_LegendPosition {
        BASICCHARTSPEC_LEGENDPOSITION_BASIC_CHART_LEGEND_POSITION_UNSPECIFIED = 0;
        BASICCHARTSPEC_LEGENDPOSITION_BOTTOM_LEGEND = 1;
        BASICCHARTSPEC_LEGENDPOSITION_LEFT_LEGEND = 2;
        BASICCHARTSPEC_LEGENDPOSITION_RIGHT_LEGEND = 3;
        BASICCHARTSPEC_LEGENDPOSITION_TOP_LEGEND = 4;
        BASICCHARTSPEC_LEGENDPOSITION_NO_LEGEND = 5;
    }
    BasicChartSpec_LegendPosition legendPosition = 7;
    // Gets whether all lines should be rendered smooth or straight by default.
    // Applies to Line charts.
    bool lineSmoothing = 8;
    // The data this chart is visualizing.
    repeated BasicChartSeries series = 9;
    // The stacked type for charts that support vertical stacking.
    // Applies to Area, Bar, Column, and Stepped Area charts.
    enum BasicChartSpec_StackedType {
        BASICCHARTSPEC_STACKEDTYPE_BASIC_CHART_STACKED_TYPE_UNSPECIFIED = 0;
        BASICCHARTSPEC_STACKEDTYPE_NOT_STACKED = 1;
        BASICCHARTSPEC_STACKEDTYPE_STACKED = 2;
        BASICCHARTSPEC_STACKEDTYPE_PERCENT_STACKED = 3;
    }
    BasicChartSpec_StackedType stackedType = 10;
    // True to make the chart 3D.
    // Applies to Bar and Column charts.
    bool threeDimensional = 11;
}

message BasicFilter {
    // The criteria for showing/hiding values per column.
    // The map's key is the column index, and the value is the criteria for
    // that column.
    map<string, FilterCriteria> criteria = 1;
    // The range the filter covers.
    GridRange range = 2;
    // The sort order per column. Later specifications are used when values
    // are equal in the earlier specifications.
    repeated SortSpec sortSpecs = 3;
}

message BatchClearValuesByDataFilterRequest {
    // The DataFilters used to determine which ranges to clear.
    repeated DataFilter dataFilters = 1;
}

message BatchClearValuesByDataFilterResponse {
    // The ranges that were cleared, in A1 notation.
    // (If the requests were for an unbounded range or a ranger larger
    //  than the bounds of the sheet, this will be the actual ranges
    //  that were cleared, bounded to the sheet's limits.)
    repeated string clearedRanges = 1;
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 2;
}

message BatchClearValuesRequest {
    // The ranges to clear, in A1 notation.
    repeated string ranges = 1;
}

message BatchClearValuesResponse {
    // The ranges that were cleared, in A1 notation.
    // (If the requests were for an unbounded range or a ranger larger
    //  than the bounds of the sheet, this will be the actual ranges
    //  that were cleared, bounded to the sheet's limits.)
    repeated string clearedRanges = 1;
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 2;
}

message BatchGetValuesByDataFilterRequest {
    // The data filters used to match the ranges of values to retrieve.  Ranges
    // that match any of the specified data filters will be included in the
    // response.
    repeated DataFilter dataFilters = 1;
    // How dates, times, and durations should be represented in the output.
    // This is ignored if value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    enum BatchGetValuesByDataFilterRequest_DateTimeRenderOption {
        BATCHGETVALUESBYDATAFILTERREQUEST_DATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        BATCHGETVALUESBYDATAFILTERREQUEST_DATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    BatchGetValuesByDataFilterRequest_DateTimeRenderOption dateTimeRenderOption = 2;
    // The major dimension that results should use.
    // 
    // For example, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`,
    // then a request that selects that range and sets `majorDimension=ROWS` will
    // return `[[1,2],[3,4]]`,
    // whereas a request that sets `majorDimension=COLUMNS` will return
    // `[[1,3],[2,4]]`.
    enum BatchGetValuesByDataFilterRequest_MajorDimension {
        BATCHGETVALUESBYDATAFILTERREQUEST_MAJORDIMENSION_DIMENSION_UNSPECIFIED = 0;
        BATCHGETVALUESBYDATAFILTERREQUEST_MAJORDIMENSION_ROWS = 1;
        BATCHGETVALUESBYDATAFILTERREQUEST_MAJORDIMENSION_COLUMNS = 2;
    }
    BatchGetValuesByDataFilterRequest_MajorDimension majorDimension = 3;
    // How values should be represented in the output.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum BatchGetValuesByDataFilterRequest_ValueRenderOption {
        BATCHGETVALUESBYDATAFILTERREQUEST_VALUERENDEROPTION_FORMATTED_VALUE = 0;
        BATCHGETVALUESBYDATAFILTERREQUEST_VALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        BATCHGETVALUESBYDATAFILTERREQUEST_VALUERENDEROPTION_FORMULA = 2;
    }
    BatchGetValuesByDataFilterRequest_ValueRenderOption valueRenderOption = 4;
}

message BatchGetValuesByDataFilterResponse {
    // The ID of the spreadsheet the data was retrieved from.
    string spreadsheetId = 1;
    // The requested values with the list of data filters that matched them.
    repeated MatchedValueRange valueRanges = 2;
}

message BatchGetValuesResponse {
    // The ID of the spreadsheet the data was retrieved from.
    string spreadsheetId = 1;
    // The requested values. The order of the ValueRanges is the same as the
    // order of the requested ranges.
    repeated ValueRange valueRanges = 2;
}

message BatchUpdateSpreadsheetRequest {
    // Determines if the update response should include the spreadsheet
    // resource.
    bool includeSpreadsheetInResponse = 1;
    // A list of updates to apply to the spreadsheet.
    // Requests will be applied in the order they are specified.
    // If any request is not valid, no requests will be applied.
    repeated Request requests = 2;
    // True if grid data should be returned. Meaningful only if
    // if include_spreadsheet_response is 'true'.
    // This parameter is ignored if a field mask was set in the request.
    bool responseIncludeGridData = 3;
    // Limits the ranges included in the response spreadsheet.
    // Meaningful only if include_spreadsheet_response is 'true'.
    repeated string responseRanges = 4;
}

message BatchUpdateSpreadsheetResponse {
    // The reply of the updates.  This maps 1:1 with the updates, although
    // replies to some requests may be empty.
    repeated Response replies = 1;
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 2;
    // The spreadsheet after updates were applied. This is only set if
    // [BatchUpdateSpreadsheetRequest.include_spreadsheet_in_response] is `true`.
    Spreadsheet updatedSpreadsheet = 3;
}

message BatchUpdateValuesByDataFilterRequest {
    // The new values to apply to the spreadsheet.  If more than one range is
    // matched by the specified DataFilter the specified values will be
    // applied to all of those ranges.
    repeated DataFilterValueRange data = 1;
    // Determines if the update response should include the values
    // of the cells that were updated. By default, responses
    // do not include the updated values. The `updatedData` field within
    // each of the BatchUpdateValuesResponse.responses will contain
    // the updated values. If the range to write was larger than than the range
    // actually written, the response will include all values in the requested
    // range (excluding trailing empty rows and columns).
    bool includeValuesInResponse = 2;
    // Determines how dates, times, and durations in the response should be
    // rendered. This is ignored if response_value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is
    // DateTimeRenderOption.SERIAL_NUMBER.
    enum BatchUpdateValuesByDataFilterRequest_ResponseDateTimeRenderOption {
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_RESPONSEDATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_RESPONSEDATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    BatchUpdateValuesByDataFilterRequest_ResponseDateTimeRenderOption responseDateTimeRenderOption = 3;
    // Determines how values in the response should be rendered.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum BatchUpdateValuesByDataFilterRequest_ResponseValueRenderOption {
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_RESPONSEVALUERENDEROPTION_FORMATTED_VALUE = 0;
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_RESPONSEVALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_RESPONSEVALUERENDEROPTION_FORMULA = 2;
    }
    BatchUpdateValuesByDataFilterRequest_ResponseValueRenderOption responseValueRenderOption = 4;
    // How the input data should be interpreted.
    enum BatchUpdateValuesByDataFilterRequest_ValueInputOption {
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_VALUEINPUTOPTION_INPUT_VALUE_OPTION_UNSPECIFIED = 0;
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_VALUEINPUTOPTION_RAW = 1;
        BATCHUPDATEVALUESBYDATAFILTERREQUEST_VALUEINPUTOPTION_USER_ENTERED = 2;
    }
    BatchUpdateValuesByDataFilterRequest_ValueInputOption valueInputOption = 5;
}

message BatchUpdateValuesByDataFilterResponse {
    // The response for each range updated.
    repeated UpdateValuesByDataFilterResponse responses = 1;
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 2;
    // The total number of cells updated.
    int32 totalUpdatedCells = 3;
    // The total number of columns where at least one cell in the column was
    // updated.
    int32 totalUpdatedColumns = 4;
    // The total number of rows where at least one cell in the row was updated.
    int32 totalUpdatedRows = 5;
    // The total number of sheets where at least one cell in the sheet was
    // updated.
    int32 totalUpdatedSheets = 6;
}

message BatchUpdateValuesRequest {
    // The new values to apply to the spreadsheet.
    repeated ValueRange data = 1;
    // Determines if the update response should include the values
    // of the cells that were updated. By default, responses
    // do not include the updated values. The `updatedData` field within
    // each of the BatchUpdateValuesResponse.responses will contain
    // the updated values. If the range to write was larger than than the range
    // actually written, the response will include all values in the requested
    // range (excluding trailing empty rows and columns).
    bool includeValuesInResponse = 2;
    // Determines how dates, times, and durations in the response should be
    // rendered. This is ignored if response_value_render_option is
    // FORMATTED_VALUE.
    // The default dateTime render option is
    // DateTimeRenderOption.SERIAL_NUMBER.
    enum BatchUpdateValuesRequest_ResponseDateTimeRenderOption {
        BATCHUPDATEVALUESREQUEST_RESPONSEDATETIMERENDEROPTION_SERIAL_NUMBER = 0;
        BATCHUPDATEVALUESREQUEST_RESPONSEDATETIMERENDEROPTION_FORMATTED_STRING = 1;
    }
    BatchUpdateValuesRequest_ResponseDateTimeRenderOption responseDateTimeRenderOption = 3;
    // Determines how values in the response should be rendered.
    // The default render option is ValueRenderOption.FORMATTED_VALUE.
    enum BatchUpdateValuesRequest_ResponseValueRenderOption {
        BATCHUPDATEVALUESREQUEST_RESPONSEVALUERENDEROPTION_FORMATTED_VALUE = 0;
        BATCHUPDATEVALUESREQUEST_RESPONSEVALUERENDEROPTION_UNFORMATTED_VALUE = 1;
        BATCHUPDATEVALUESREQUEST_RESPONSEVALUERENDEROPTION_FORMULA = 2;
    }
    BatchUpdateValuesRequest_ResponseValueRenderOption responseValueRenderOption = 4;
    // How the input data should be interpreted.
    enum BatchUpdateValuesRequest_ValueInputOption {
        BATCHUPDATEVALUESREQUEST_VALUEINPUTOPTION_INPUT_VALUE_OPTION_UNSPECIFIED = 0;
        BATCHUPDATEVALUESREQUEST_VALUEINPUTOPTION_RAW = 1;
        BATCHUPDATEVALUESREQUEST_VALUEINPUTOPTION_USER_ENTERED = 2;
    }
    BatchUpdateValuesRequest_ValueInputOption valueInputOption = 5;
}

message BatchUpdateValuesResponse {
    // One UpdateValuesResponse per requested range, in the same order as
    // the requests appeared.
    repeated UpdateValuesResponse responses = 1;
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 2;
    // The total number of cells updated.
    int32 totalUpdatedCells = 3;
    // The total number of columns where at least one cell in the column was
    // updated.
    int32 totalUpdatedColumns = 4;
    // The total number of rows where at least one cell in the row was updated.
    int32 totalUpdatedRows = 5;
    // The total number of sheets where at least one cell in the sheet was
    // updated.
    int32 totalUpdatedSheets = 6;
}

message BooleanCondition {
    // The type of condition.
    enum BooleanCondition_Type {
        BOOLEANCONDITION_TYPE_CONDITION_TYPE_UNSPECIFIED = 0;
        BOOLEANCONDITION_TYPE_NUMBER_GREATER = 1;
        BOOLEANCONDITION_TYPE_NUMBER_GREATER_THAN_EQ = 2;
        BOOLEANCONDITION_TYPE_NUMBER_LESS = 3;
        BOOLEANCONDITION_TYPE_NUMBER_LESS_THAN_EQ = 4;
        BOOLEANCONDITION_TYPE_NUMBER_EQ = 5;
        BOOLEANCONDITION_TYPE_NUMBER_NOT_EQ = 6;
        BOOLEANCONDITION_TYPE_NUMBER_BETWEEN = 7;
        BOOLEANCONDITION_TYPE_NUMBER_NOT_BETWEEN = 8;
        BOOLEANCONDITION_TYPE_TEXT_CONTAINS = 9;
        BOOLEANCONDITION_TYPE_TEXT_NOT_CONTAINS = 10;
        BOOLEANCONDITION_TYPE_TEXT_STARTS_WITH = 11;
        BOOLEANCONDITION_TYPE_TEXT_ENDS_WITH = 12;
        BOOLEANCONDITION_TYPE_TEXT_EQ = 13;
        BOOLEANCONDITION_TYPE_TEXT_IS_EMAIL = 14;
        BOOLEANCONDITION_TYPE_TEXT_IS_URL = 15;
        BOOLEANCONDITION_TYPE_DATE_EQ = 16;
        BOOLEANCONDITION_TYPE_DATE_BEFORE = 17;
        BOOLEANCONDITION_TYPE_DATE_AFTER = 18;
        BOOLEANCONDITION_TYPE_DATE_ON_OR_BEFORE = 19;
        BOOLEANCONDITION_TYPE_DATE_ON_OR_AFTER = 20;
        BOOLEANCONDITION_TYPE_DATE_BETWEEN = 21;
        BOOLEANCONDITION_TYPE_DATE_NOT_BETWEEN = 22;
        BOOLEANCONDITION_TYPE_DATE_IS_VALID = 23;
        BOOLEANCONDITION_TYPE_ONE_OF_RANGE = 24;
        BOOLEANCONDITION_TYPE_ONE_OF_LIST = 25;
        BOOLEANCONDITION_TYPE_BLANK = 26;
        BOOLEANCONDITION_TYPE_NOT_BLANK = 27;
        BOOLEANCONDITION_TYPE_CUSTOM_FORMULA = 28;
    }
    BooleanCondition_Type type = 1;
    // The values of the condition. The number of supported values depends
    // on the condition type.  Some support zero values,
    // others one or two values,
    // and ConditionType.ONE_OF_LIST supports an arbitrary number of values.
    repeated ConditionValue values = 2;
}

message BooleanRule {
    // The condition of the rule. If the condition evaluates to true,
    // the format will be applied.
    BooleanCondition condition = 1;
    // The format to apply.
    // Conditional formatting can only apply a subset of formatting:
    // bold, italic,
    // strikethrough,
    // foreground color &
    // background color.
    CellFormat format = 2;
}

message Border {
    // The color of the border.
    Color color = 1;
    // The style of the border.
    enum Border_Style {
        BORDER_STYLE_STYLE_UNSPECIFIED = 0;
        BORDER_STYLE_DOTTED = 1;
        BORDER_STYLE_DASHED = 2;
        BORDER_STYLE_SOLID = 3;
        BORDER_STYLE_SOLID_MEDIUM = 4;
        BORDER_STYLE_SOLID_THICK = 5;
        BORDER_STYLE_NONE = 6;
        BORDER_STYLE_DOUBLE = 7;
    }
    Border_Style style = 2;
    // The width of the border, in pixels.
    // Deprecated; the width is determined by the "style" field.
    int32 width = 3;
}

message Borders {
    // The bottom border of the cell.
    Border bottom = 1;
    // The left border of the cell.
    Border left = 2;
    // The right border of the cell.
    Border right = 3;
    // The top border of the cell.
    Border top = 4;
}

message BubbleChartSpec {
    // The bubble border color.
    Color bubbleBorderColor = 1;
    // The data containing the bubble labels.  These do not need to be unique.
    ChartData bubbleLabels = 2;
    // The max radius size of the bubbles, in pixels.
    // If specified, the field must be a positive value.
    int32 bubbleMaxRadiusSize = 3;
    // The minimum radius size of the bubbles, in pixels.
    // If specific, the field must be a positive value.
    int32 bubbleMinRadiusSize = 4;
    // The opacity of the bubbles between 0 and 1.0.
    // 0 is fully transparent and 1 is fully opaque.
    float bubbleOpacity = 5;
    // The data contianing the bubble sizes.  Bubble sizes are used to draw
    // the bubbles at different sizes relative to each other.
    // If specified, group_ids must also be specified.  This field is
    // optional.
    ChartData bubbleSizes = 6;
    // The format of the text inside the bubbles.
    // Underline and Strikethrough are not supported.
    TextFormat bubbleTextStyle = 7;
    // The data containing the bubble x-values.  These values locate the bubbles
    // in the chart horizontally.
    ChartData domain = 8;
    // The data containing the bubble group IDs. All bubbles with the same group
    // ID will be drawn in the same color. If bubble_sizes is specified then
    // this field must also be specified but may contain blank values.
    // This field is optional.
    ChartData groupIds = 9;
    // Where the legend of the chart should be drawn.
    enum BubbleChartSpec_LegendPosition {
        BUBBLECHARTSPEC_LEGENDPOSITION_BUBBLE_CHART_LEGEND_POSITION_UNSPECIFIED = 0;
        BUBBLECHARTSPEC_LEGENDPOSITION_BOTTOM_LEGEND = 1;
        BUBBLECHARTSPEC_LEGENDPOSITION_LEFT_LEGEND = 2;
        BUBBLECHARTSPEC_LEGENDPOSITION_RIGHT_LEGEND = 3;
        BUBBLECHARTSPEC_LEGENDPOSITION_TOP_LEGEND = 4;
        BUBBLECHARTSPEC_LEGENDPOSITION_NO_LEGEND = 5;
        BUBBLECHARTSPEC_LEGENDPOSITION_INSIDE_LEGEND = 6;
    }
    BubbleChartSpec_LegendPosition legendPosition = 10;
    // The data contianing the bubble y-values.  These values locate the bubbles
    // in the chart vertically.
    ChartData series = 11;
}

message CandlestickChartSpec {
    // The Candlestick chart data.
    // Only one CandlestickData is supported.
    repeated CandlestickData data = 1;
    // The domain data (horizontal axis) for the candlestick chart.  String data
    // will be treated as discrete labels, other data will be treated as
    // continuous values.
    CandlestickDomain domain = 2;
}

message CandlestickData {
    // The range data (vertical axis) for the close/final value for each candle.
    // This is the top of the candle body.  If greater than the open value the
    // candle will be filled.  Otherwise the candle will be hollow.
    CandlestickSeries closeSeries = 1;
    // The range data (vertical axis) for the high/maximum value for each
    // candle. This is the top of the candle's center line.
    CandlestickSeries highSeries = 2;
    // The range data (vertical axis) for the low/minimum value for each candle.
    // This is the bottom of the candle's center line.
    CandlestickSeries lowSeries = 3;
    // The range data (vertical axis) for the open/initial value for each
    // candle. This is the bottom of the candle body.  If less than the close
    // value the candle will be filled.  Otherwise the candle will be hollow.
    CandlestickSeries openSeries = 4;
}

message CandlestickDomain {
    // The data of the CandlestickDomain.
    ChartData data = 1;
    // True to reverse the order of the domain values (horizontal axis).
    bool reversed = 2;
}

message CandlestickSeries {
    // The data of the CandlestickSeries.
    ChartData data = 1;
}

message CellData {
    // A data validation rule on the cell, if any.
    // 
    // When writing, the new data validation rule will overwrite any prior rule.
    DataValidationRule dataValidation = 1;
    // The effective format being used by the cell.
    // This includes the results of applying any conditional formatting and,
    // if the cell contains a formula, the computed number format.
    // If the effective format is the default format, effective format will
    // not be written.
    // This field is read-only.
    CellFormat effectiveFormat = 2;
    // The effective value of the cell. For cells with formulas, this will be
    // the calculated value.  For cells with literals, this will be
    // the same as the user_entered_value.
    // This field is read-only.
    ExtendedValue effectiveValue = 3;
    // The formatted value of the cell.
    // This is the value as it's shown to the user.
    // This field is read-only.
    string formattedValue = 4;
    // A hyperlink this cell points to, if any.
    // This field is read-only.  (To set it, use a `=HYPERLINK` formula
    // in the userEnteredValue.formulaValue
    // field.)
    string hyperlink = 5;
    // Any note on the cell.
    string note = 6;
    // A pivot table anchored at this cell. The size of pivot table itself
    // is computed dynamically based on its data, grouping, filters, values,
    // etc. Only the top-left cell of the pivot table contains the pivot table
    // definition. The other cells will contain the calculated values of the
    // results of the pivot in their effective_value fields.
    PivotTable pivotTable = 7;
    // Runs of rich text applied to subsections of the cell.  Runs are only valid
    // on user entered strings, not formulas, bools, or numbers.
    // Runs start at specific indexes in the text and continue until the next
    // run. Properties of a run will continue unless explicitly changed
    // in a subsequent run (and properties of the first run will continue
    // the properties of the cell unless explicitly changed).
    // 
    // When writing, the new runs will overwrite any prior runs.  When writing a
    // new user_entered_value, previous runs will be erased.
    repeated TextFormatRun textFormatRuns = 8;
    // The format the user entered for the cell.
    // 
    // When writing, the new format will be merged with the existing format.
    CellFormat userEnteredFormat = 9;
    // The value the user entered in the cell. e.g, `1234`, `'Hello'`, or `=NOW()`
    // Note: Dates, Times and DateTimes are represented as doubles in
    // serial number format.
    ExtendedValue userEnteredValue = 10;
}

message CellFormat {
    // The background color of the cell.
    Color backgroundColor = 1;
    // The borders of the cell.
    Borders borders = 2;
    // The horizontal alignment of the value in the cell.
    enum CellFormat_HorizontalAlignment {
        CELLFORMAT_HORIZONTALALIGNMENT_HORIZONTAL_ALIGN_UNSPECIFIED = 0;
        CELLFORMAT_HORIZONTALALIGNMENT_LEFT = 1;
        CELLFORMAT_HORIZONTALALIGNMENT_CENTER = 2;
        CELLFORMAT_HORIZONTALALIGNMENT_RIGHT = 3;
    }
    CellFormat_HorizontalAlignment horizontalAlignment = 3;
    // How a hyperlink, if it exists, should be displayed in the cell.
    enum CellFormat_HyperlinkDisplayType {
        CELLFORMAT_HYPERLINKDISPLAYTYPE_HYPERLINK_DISPLAY_TYPE_UNSPECIFIED = 0;
        CELLFORMAT_HYPERLINKDISPLAYTYPE_LINKED = 1;
        CELLFORMAT_HYPERLINKDISPLAYTYPE_PLAIN_TEXT = 2;
    }
    CellFormat_HyperlinkDisplayType hyperlinkDisplayType = 4;
    // A format describing how number values should be represented to the user.
    NumberFormat numberFormat = 5;
    // The padding of the cell.
    Padding padding = 6;
    // The direction of the text in the cell.
    enum CellFormat_TextDirection {
        CELLFORMAT_TEXTDIRECTION_TEXT_DIRECTION_UNSPECIFIED = 0;
        CELLFORMAT_TEXTDIRECTION_LEFT_TO_RIGHT = 1;
        CELLFORMAT_TEXTDIRECTION_RIGHT_TO_LEFT = 2;
    }
    CellFormat_TextDirection textDirection = 7;
    // The format of the text in the cell (unless overridden by a format run).
    TextFormat textFormat = 8;
    // The rotation applied to text in a cell
    TextRotation textRotation = 9;
    // The vertical alignment of the value in the cell.
    enum CellFormat_VerticalAlignment {
        CELLFORMAT_VERTICALALIGNMENT_VERTICAL_ALIGN_UNSPECIFIED = 0;
        CELLFORMAT_VERTICALALIGNMENT_TOP = 1;
        CELLFORMAT_VERTICALALIGNMENT_MIDDLE = 2;
        CELLFORMAT_VERTICALALIGNMENT_BOTTOM = 3;
    }
    CellFormat_VerticalAlignment verticalAlignment = 10;
    // The wrap strategy for the value in the cell.
    enum CellFormat_WrapStrategy {
        CELLFORMAT_WRAPSTRATEGY_WRAP_STRATEGY_UNSPECIFIED = 0;
        CELLFORMAT_WRAPSTRATEGY_OVERFLOW_CELL = 1;
        CELLFORMAT_WRAPSTRATEGY_LEGACY_WRAP = 2;
        CELLFORMAT_WRAPSTRATEGY_CLIP = 3;
        CELLFORMAT_WRAPSTRATEGY_WRAP = 4;
    }
    CellFormat_WrapStrategy wrapStrategy = 11;
}

message ChartData {
    // The source ranges of the data.
    ChartSourceRange sourceRange = 1;
}

message ChartSourceRange {
    // The ranges of data for a series or domain.
    // Exactly one dimension must have a length of 1,
    // and all sources in the list must have the same dimension
    // with length 1.
    // The domain (if it exists) & all series must have the same number
    // of source ranges. If using more than one source range, then the source
    // range at a given offset must be contiguous across the domain and series.
    // 
    // For example, these are valid configurations:
    // 
    //     domain sources: A1:A5
    //     series1 sources: B1:B5
    //     series2 sources: D6:D10
    // 
    //     domain sources: A1:A5, C10:C12
    //     series1 sources: B1:B5, D10:D12
    //     series2 sources: C1:C5, E10:E12
    repeated GridRange sources = 1;
}

message ChartSpec {
    // The alternative text that describes the chart.  This is often used
    // for accessibility.
    string altText = 1;
    // The background color of the entire chart.
    // Not applicable to Org charts.
    Color backgroundColor = 2;
    // A basic chart specification, can be one of many kinds of charts.
    // See BasicChartType for the list of all
    // charts this supports.
    BasicChartSpec basicChart = 3;
    // A bubble chart specification.
    BubbleChartSpec bubbleChart = 4;
    // A candlestick chart specification.
    CandlestickChartSpec candlestickChart = 5;
    // The name of the font to use by default for all chart text (e.g. title,
    // axis labels, legend).  If a font is specified for a specific part of the
    // chart it will override this font name.
    string fontName = 6;
    // Determines how the charts will use hidden rows or columns.
    enum ChartSpec_HiddenDimensionStrategy {
        CHARTSPEC_HIDDENDIMENSIONSTRATEGY_CHART_HIDDEN_DIMENSION_STRATEGY_UNSPECIFIED = 0;
        CHARTSPEC_HIDDENDIMENSIONSTRATEGY_SKIP_HIDDEN_ROWS_AND_COLUMNS = 1;
        CHARTSPEC_HIDDENDIMENSIONSTRATEGY_SKIP_HIDDEN_ROWS = 2;
        CHARTSPEC_HIDDENDIMENSIONSTRATEGY_SKIP_HIDDEN_COLUMNS = 3;
        CHARTSPEC_HIDDENDIMENSIONSTRATEGY_SHOW_ALL = 4;
    }
    ChartSpec_HiddenDimensionStrategy hiddenDimensionStrategy = 7;
    // A histogram chart specification.
    HistogramChartSpec histogramChart = 8;
    // True to make a chart fill the entire space in which it's rendered with
    // minimum padding.  False to use the default padding.
    // (Not applicable to Geo and Org charts.)
    bool maximized = 9;
    // An org chart specification.
    OrgChartSpec orgChart = 10;
    // A pie chart specification.
    PieChartSpec pieChart = 11;
    // The subtitle of the chart.
    string subtitle = 12;
    // The subtitle text format.
    // Strikethrough and underline are not supported.
    TextFormat subtitleTextFormat = 13;
    // The subtitle text position.
    // This field is optional.
    TextPosition subtitleTextPosition = 14;
    // The title of the chart.
    string title = 15;
    // The title text format.
    // Strikethrough and underline are not supported.
    TextFormat titleTextFormat = 16;
    // The title text position.
    // This field is optional.
    TextPosition titleTextPosition = 17;
}

message ClearBasicFilterRequest {
    // The sheet ID on which the basic filter should be cleared.
    int32 sheetId = 1;
}

message ClearValuesRequest {
}

message ClearValuesResponse {
    // The range (in A1 notation) that was cleared.
    // (If the request was for an unbounded range or a ranger larger
    //  than the bounds of the sheet, this will be the actual range
    //  that was cleared, bounded to the sheet's limits.)
    string clearedRange = 1;
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 2;
}

message Color {
    // The fraction of this color that should be applied to the pixel. That is,
    // the final pixel color is defined by the equation:
    // 
    //   pixel color = alpha * (this color) + (1.0 - alpha) * (background color)
    // 
    // This means that a value of 1.0 corresponds to a solid color, whereas
    // a value of 0.0 corresponds to a completely transparent color. This
    // uses a wrapper message rather than a simple float scalar so that it is
    // possible to distinguish between a default value and the value being unset.
    // If omitted, this color object is to be rendered as a solid color
    // (as if the alpha value had been explicitly given with a value of 1.0).
    float alpha = 1;
    // The amount of blue in the color as a value in the interval [0, 1].
    float blue = 2;
    // The amount of green in the color as a value in the interval [0, 1].
    float green = 3;
    // The amount of red in the color as a value in the interval [0, 1].
    float red = 4;
}

message ConditionValue {
    // A relative date (based on the current date).
    // Valid only if the type is
    // DATE_BEFORE,
    // DATE_AFTER,
    // DATE_ON_OR_BEFORE or
    // DATE_ON_OR_AFTER.
    // 
    // Relative dates are not supported in data validation.
    // They are supported only in conditional formatting and
    // conditional filters.
    enum ConditionValue_RelativeDate {
        CONDITIONVALUE_RELATIVEDATE_RELATIVE_DATE_UNSPECIFIED = 0;
        CONDITIONVALUE_RELATIVEDATE_PAST_YEAR = 1;
        CONDITIONVALUE_RELATIVEDATE_PAST_MONTH = 2;
        CONDITIONVALUE_RELATIVEDATE_PAST_WEEK = 3;
        CONDITIONVALUE_RELATIVEDATE_YESTERDAY = 4;
        CONDITIONVALUE_RELATIVEDATE_TODAY = 5;
        CONDITIONVALUE_RELATIVEDATE_TOMORROW = 6;
    }
    ConditionValue_RelativeDate relativeDate = 1;
    // A value the condition is based on.
    // The value will be parsed as if the user typed into a cell.
    // Formulas are supported (and must begin with an `=`).
    string userEnteredValue = 2;
}

message ConditionalFormatRule {
    // The formatting is either "on" or "off" according to the rule.
    BooleanRule booleanRule = 1;
    // The formatting will vary based on the gradients in the rule.
    GradientRule gradientRule = 2;
    // The ranges that will be formatted if the condition is true.
    // All the ranges must be on the same grid.
    repeated GridRange ranges = 3;
}

message CopyPasteRequest {
    // The location to paste to. If the range covers a span that's
    // a multiple of the source's height or width, then the
    // data will be repeated to fill in the destination range.
    // If the range is smaller than the source range, the entire
    // source data will still be copied (beyond the end of the destination range).
    GridRange destination = 1;
    // How that data should be oriented when pasting.
    enum CopyPasteRequest_PasteOrientation {
        COPYPASTEREQUEST_PASTEORIENTATION_NORMAL = 0;
        COPYPASTEREQUEST_PASTEORIENTATION_TRANSPOSE = 1;
    }
    CopyPasteRequest_PasteOrientation pasteOrientation = 2;
    // What kind of data to paste.
    enum CopyPasteRequest_PasteType {
        COPYPASTEREQUEST_PASTETYPE_PASTE_NORMAL = 0;
        COPYPASTEREQUEST_PASTETYPE_PASTE_VALUES = 1;
        COPYPASTEREQUEST_PASTETYPE_PASTE_FORMAT = 2;
        COPYPASTEREQUEST_PASTETYPE_PASTE_NO_BORDERS = 3;
        COPYPASTEREQUEST_PASTETYPE_PASTE_FORMULA = 4;
        COPYPASTEREQUEST_PASTETYPE_PASTE_DATA_VALIDATION = 5;
        COPYPASTEREQUEST_PASTETYPE_PASTE_CONDITIONAL_FORMATTING = 6;
    }
    CopyPasteRequest_PasteType pasteType = 3;
    // The source range to copy.
    GridRange source = 4;
}

message CopySheetToAnotherSpreadsheetRequest {
    // The ID of the spreadsheet to copy the sheet to.
    string destinationSpreadsheetId = 1;
}

message CreateDeveloperMetadataRequest {
    // The developer metadata to create.
    DeveloperMetadata developerMetadata = 1;
}

message CreateDeveloperMetadataResponse {
    // The developer metadata that was created.
    DeveloperMetadata developerMetadata = 1;
}

message CutPasteRequest {
    // The top-left coordinate where the data should be pasted.
    GridCoordinate destination = 1;
    // What kind of data to paste.  All the source data will be cut, regardless
    // of what is pasted.
    enum CutPasteRequest_PasteType {
        CUTPASTEREQUEST_PASTETYPE_PASTE_NORMAL = 0;
        CUTPASTEREQUEST_PASTETYPE_PASTE_VALUES = 1;
        CUTPASTEREQUEST_PASTETYPE_PASTE_FORMAT = 2;
        CUTPASTEREQUEST_PASTETYPE_PASTE_NO_BORDERS = 3;
        CUTPASTEREQUEST_PASTETYPE_PASTE_FORMULA = 4;
        CUTPASTEREQUEST_PASTETYPE_PASTE_DATA_VALIDATION = 5;
        CUTPASTEREQUEST_PASTETYPE_PASTE_CONDITIONAL_FORMATTING = 6;
    }
    CutPasteRequest_PasteType pasteType = 2;
    // The source data to cut.
    GridRange source = 3;
}

message DataFilter {
    // Selects data that matches the specified A1 range.
    string a1Range = 1;
    // Selects data associated with the developer metadata matching the criteria
    // described by this DeveloperMetadataLookup.
    DeveloperMetadataLookup developerMetadataLookup = 2;
    // Selects data that matches the range described by the GridRange.
    GridRange gridRange = 3;
}

message DataFilterValueRange {
    // The data filter describing the location of the values in the spreadsheet.
    DataFilter dataFilter = 1;
    // The major dimension of the values.
    enum DataFilterValueRange_MajorDimension {
        DATAFILTERVALUERANGE_MAJORDIMENSION_DIMENSION_UNSPECIFIED = 0;
        DATAFILTERVALUERANGE_MAJORDIMENSION_ROWS = 1;
        DATAFILTERVALUERANGE_MAJORDIMENSION_COLUMNS = 2;
    }
    DataFilterValueRange_MajorDimension majorDimension = 2;
    // The data to be written.  If the provided values exceed any of the ranges
    // matched by the data filter then the request will fail.  If the provided
    // values are less than the matched ranges only the specified values will be
    // written, existing values in the matched ranges will remain unaffected.
    message Value {
    }
    repeated Value values = 3;
}

message DataValidationRule {
    // The condition that data in the cell must match.
    BooleanCondition condition = 1;
    // A message to show the user when adding data to the cell.
    string inputMessage = 2;
    // True if the UI should be customized based on the kind of condition.
    // If true, "List" conditions will show a dropdown.
    bool showCustomUi = 3;
    // True if invalid data should be rejected.
    bool strict = 4;
}

message DeleteBandingRequest {
    // The ID of the banded range to delete.
    int32 bandedRangeId = 1;
}

message DeleteConditionalFormatRuleRequest {
    // The zero-based index of the rule to be deleted.
    int32 index = 1;
    // The sheet the rule is being deleted from.
    int32 sheetId = 2;
}

message DeleteConditionalFormatRuleResponse {
    // The rule that was deleted.
    ConditionalFormatRule rule = 1;
}

message DeleteDeveloperMetadataRequest {
    // The data filter describing the criteria used to select which developer
    // metadata entry to delete.
    DataFilter dataFilter = 1;
}

message DeleteDeveloperMetadataResponse {
    // The metadata that was deleted.
    repeated DeveloperMetadata deletedDeveloperMetadata = 1;
}

message DeleteDimensionRequest {
    // The dimensions to delete from the sheet.
    DimensionRange range = 1;
}

message DeleteEmbeddedObjectRequest {
    // The ID of the embedded object to delete.
    int32 objectId = 1;
}

message DeleteFilterViewRequest {
    // The ID of the filter to delete.
    int32 filterId = 1;
}

message DeleteNamedRangeRequest {
    // The ID of the named range to delete.
    string namedRangeId = 1;
}

message DeleteProtectedRangeRequest {
    // The ID of the protected range to delete.
    int32 protectedRangeId = 1;
}

message DeleteRangeRequest {
    // The range of cells to delete.
    GridRange range = 1;
    // The dimension from which deleted cells will be replaced with.
    // If ROWS, existing cells will be shifted upward to
    // replace the deleted cells. If COLUMNS, existing cells
    // will be shifted left to replace the deleted cells.
    enum DeleteRangeRequest_ShiftDimension {
        DELETERANGEREQUEST_SHIFTDIMENSION_DIMENSION_UNSPECIFIED = 0;
        DELETERANGEREQUEST_SHIFTDIMENSION_ROWS = 1;
        DELETERANGEREQUEST_SHIFTDIMENSION_COLUMNS = 2;
    }
    DeleteRangeRequest_ShiftDimension shiftDimension = 2;
}

message DeleteSheetRequest {
    // The ID of the sheet to delete.
    int32 sheetId = 1;
}

message DeveloperMetadata {
    // The location where the metadata is associated.
    DeveloperMetadataLocation location = 1;
    // The spreadsheet-scoped unique ID that identifies the metadata. IDs may be
    // specified when metadata is created, otherwise one will be randomly
    // generated and assigned. Must be positive.
    int32 metadataId = 2;
    // The metadata key. There may be multiple metadata in a spreadsheet with the
    // same key.  Developer metadata must always have a key specified.
    string metadataKey = 3;
    // Data associated with the metadata's key.
    string metadataValue = 4;
    // The metadata visibility.  Developer metadata must always have a visibility
    // specified.
    enum DeveloperMetadata_Visibility {
        DEVELOPERMETADATA_VISIBILITY_DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED = 0;
        DEVELOPERMETADATA_VISIBILITY_DOCUMENT = 1;
        DEVELOPERMETADATA_VISIBILITY_PROJECT = 2;
    }
    DeveloperMetadata_Visibility visibility = 5;
}

message DeveloperMetadataLocation {
    // Represents the row or column when metadata is associated with
    // a dimension. The specified DimensionRange must represent a single row
    // or column; it cannot be unbounded or span multiple rows or columns.
    DimensionRange dimensionRange = 1;
    // The type of location this object represents.  This field is read-only.
    enum DeveloperMetadataLocation_LocationType {
        DEVELOPERMETADATALOCATION_LOCATIONTYPE_DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED = 0;
        DEVELOPERMETADATALOCATION_LOCATIONTYPE_ROW = 1;
        DEVELOPERMETADATALOCATION_LOCATIONTYPE_COLUMN = 2;
        DEVELOPERMETADATALOCATION_LOCATIONTYPE_SHEET = 3;
        DEVELOPERMETADATALOCATION_LOCATIONTYPE_SPREADSHEET = 4;
    }
    DeveloperMetadataLocation_LocationType locationType = 2;
    // The ID of the sheet when metadata is associated with an entire sheet.
    int32 sheetId = 3;
    // True when metadata is associated with an entire spreadsheet.
    bool spreadsheet = 4;
}

message DeveloperMetadataLookup {
    // Determines how this lookup matches the location.  If this field is
    // specified as EXACT, only developer metadata associated on the exact
    // location specified is matched.  If this field is specified to INTERSECTING,
    // developer metadata associated on intersecting locations is also
    // matched.  If left unspecified, this field assumes a default value of
    // INTERSECTING.
    // If this field is specified, a metadataLocation
    // must also be specified.
    enum DeveloperMetadataLookup_LocationMatchingStrategy {
        DEVELOPERMETADATALOOKUP_LOCATIONMATCHINGSTRATEGY_DEVELOPER_METADATA_LOCATION_MATCHING_STRATEGY_UNSPECIFIED = 0;
        DEVELOPERMETADATALOOKUP_LOCATIONMATCHINGSTRATEGY_EXACT_LOCATION = 1;
        DEVELOPERMETADATALOOKUP_LOCATIONMATCHINGSTRATEGY_INTERSECTING_LOCATION = 2;
    }
    DeveloperMetadataLookup_LocationMatchingStrategy locationMatchingStrategy = 1;
    // Limits the selected developer metadata to those entries which are
    // associated with locations of the specified type.  For example, when this
    // field is specified as ROW this lookup
    // only considers developer metadata associated on rows.  If the field is left
    // unspecified, all location types are considered.  This field cannot be
    // specified as SPREADSHEET when
    // the locationMatchingStrategy
    // is specified as INTERSECTING or when the
    // metadataLocation is specified as a
    // non-spreadsheet location: spreadsheet metadata cannot intersect any other
    // developer metadata location.  This field also must be left unspecified when
    // the locationMatchingStrategy
    // is specified as EXACT.
    enum DeveloperMetadataLookup_LocationType {
        DEVELOPERMETADATALOOKUP_LOCATIONTYPE_DEVELOPER_METADATA_LOCATION_TYPE_UNSPECIFIED = 0;
        DEVELOPERMETADATALOOKUP_LOCATIONTYPE_ROW = 1;
        DEVELOPERMETADATALOOKUP_LOCATIONTYPE_COLUMN = 2;
        DEVELOPERMETADATALOOKUP_LOCATIONTYPE_SHEET = 3;
        DEVELOPERMETADATALOOKUP_LOCATIONTYPE_SPREADSHEET = 4;
    }
    DeveloperMetadataLookup_LocationType locationType = 2;
    // Limits the selected developer metadata to that which has a matching
    // DeveloperMetadata.metadata_id.
    int32 metadataId = 3;
    // Limits the selected developer metadata to that which has a matching
    // DeveloperMetadata.metadata_key.
    string metadataKey = 4;
    // Limits the selected developer metadata to those entries associated with
    // the specified location.  This field either matches exact locations or all
    // intersecting locations according the specified
    // locationMatchingStrategy.
    DeveloperMetadataLocation metadataLocation = 5;
    // Limits the selected developer metadata to that which has a matching
    // DeveloperMetadata.metadata_value.
    string metadataValue = 6;
    // Limits the selected developer metadata to that which has a matching
    // DeveloperMetadata.visibility.  If left unspecified, all developer
    // metadata visibile to the requesting project is considered.
    enum DeveloperMetadataLookup_Visibility {
        DEVELOPERMETADATALOOKUP_VISIBILITY_DEVELOPER_METADATA_VISIBILITY_UNSPECIFIED = 0;
        DEVELOPERMETADATALOOKUP_VISIBILITY_DOCUMENT = 1;
        DEVELOPERMETADATALOOKUP_VISIBILITY_PROJECT = 2;
    }
    DeveloperMetadataLookup_Visibility visibility = 7;
}

message DimensionProperties {
    // The developer metadata associated with a single row or column.
    repeated DeveloperMetadata developerMetadata = 1;
    // True if this dimension is being filtered.
    // This field is read-only.
    bool hiddenByFilter = 2;
    // True if this dimension is explicitly hidden.
    bool hiddenByUser = 3;
    // The height (if a row) or width (if a column) of the dimension in pixels.
    int32 pixelSize = 4;
}

message DimensionRange {
    // The dimension of the span.
    enum DimensionRange_Dimension {
        DIMENSIONRANGE_DIMENSION_DIMENSION_UNSPECIFIED = 0;
        DIMENSIONRANGE_DIMENSION_ROWS = 1;
        DIMENSIONRANGE_DIMENSION_COLUMNS = 2;
    }
    DimensionRange_Dimension dimension = 1;
    // The end (exclusive) of the span, or not set if unbounded.
    int32 endIndex = 2;
    // The sheet this span is on.
    int32 sheetId = 3;
    // The start (inclusive) of the span, or not set if unbounded.
    int32 startIndex = 4;
}

message DuplicateFilterViewRequest {
    // The ID of the filter being duplicated.
    int32 filterId = 1;
}

message DuplicateFilterViewResponse {
    // The newly created filter.
    FilterView filter = 1;
}

message DuplicateSheetRequest {
    // The zero-based index where the new sheet should be inserted.
    // The index of all sheets after this are incremented.
    int32 insertSheetIndex = 1;
    // If set, the ID of the new sheet. If not set, an ID is chosen.
    // If set, the ID must not conflict with any existing sheet ID.
    // If set, it must be non-negative.
    int32 newSheetId = 2;
    // The name of the new sheet.  If empty, a new name is chosen for you.
    string newSheetName = 3;
    // The sheet to duplicate.
    int32 sourceSheetId = 4;
}

message DuplicateSheetResponse {
    // The properties of the duplicate sheet.
    SheetProperties properties = 1;
}

message Editors {
    // True if anyone in the document's domain has edit access to the protected
    // range.  Domain protection is only supported on documents within a domain.
    bool domainUsersCanEdit = 1;
    // The email addresses of groups with edit access to the protected range.
    repeated string groups = 2;
    // The email addresses of users with edit access to the protected range.
    repeated string users = 3;
}

message EmbeddedChart {
    // The ID of the chart.
    int32 chartId = 1;
    // The position of the chart.
    EmbeddedObjectPosition position = 2;
    // The specification of the chart.
    ChartSpec spec = 3;
}

message EmbeddedObjectPosition {
    // If true, the embedded object will be put on a new sheet whose ID
    // is chosen for you. Used only when writing.
    bool newSheet = 1;
    // The position at which the object is overlaid on top of a grid.
    OverlayPosition overlayPosition = 2;
    // The sheet this is on. Set only if the embedded object
    // is on its own sheet. Must be non-negative.
    int32 sheetId = 3;
}

message ErrorValue {
    // A message with more information about the error
    // (in the spreadsheet's locale).
    string message = 1;
    // The type of error.
    enum ErrorValue_Type {
        ERRORVALUE_TYPE_ERROR_TYPE_UNSPECIFIED = 0;
        ERRORVALUE_TYPE_ERROR = 1;
        ERRORVALUE_TYPE_NULL_VALUE = 2;
        ERRORVALUE_TYPE_DIVIDE_BY_ZERO = 3;
        ERRORVALUE_TYPE_VALUE = 4;
        ERRORVALUE_TYPE_REF = 5;
        ERRORVALUE_TYPE_NAME = 6;
        ERRORVALUE_TYPE_NUM = 7;
        ERRORVALUE_TYPE_N_A = 8;
        ERRORVALUE_TYPE_LOADING = 9;
    }
    ErrorValue_Type type = 2;
}

message ExtendedValue {
    // Represents a boolean value.
    bool boolValue = 1;
    // Represents an error.
    // This field is read-only.
    ErrorValue errorValue = 2;
    // Represents a formula.
    string formulaValue = 3;
    // Represents a double value.
    // Note: Dates, Times and DateTimes are represented as doubles in
    // "serial number" format.
    double numberValue = 4;
    // Represents a string value.
    // Leading single quotes are not included. For example, if the user typed
    // `'123` into the UI, this would be represented as a `stringValue` of
    // `"123"`.
    string stringValue = 5;
}

message FilterCriteria {
    // A condition that must be true for values to be shown.
    // (This does not override hiddenValues -- if a value is listed there,
    //  it will still be hidden.)
    BooleanCondition condition = 1;
    // Values that should be hidden.
    repeated string hiddenValues = 2;
}

message FilterView {
    // The criteria for showing/hiding values per column.
    // The map's key is the column index, and the value is the criteria for
    // that column.
    map<string, FilterCriteria> criteria = 1;
    // The ID of the filter view.
    int32 filterViewId = 2;
    // The named range this filter view is backed by, if any.
    // 
    // When writing, only one of range or named_range_id
    // may be set.
    string namedRangeId = 3;
    // The range this filter view covers.
    // 
    // When writing, only one of range or named_range_id
    // may be set.
    GridRange range = 4;
    // The sort order per column. Later specifications are used when values
    // are equal in the earlier specifications.
    repeated SortSpec sortSpecs = 5;
    // The name of the filter view.
    string title = 6;
}

message FindReplaceRequest {
    // True to find/replace over all sheets.
    bool allSheets = 1;
    // The value to search.
    string find = 2;
    // True if the search should include cells with formulas.
    // False to skip cells with formulas.
    bool includeFormulas = 3;
    // True if the search is case sensitive.
    bool matchCase = 4;
    // True if the find value should match the entire cell.
    bool matchEntireCell = 5;
    // The range to find/replace over.
    GridRange range = 6;
    // The value to use as the replacement.
    string replacement = 7;
    // True if the find value is a regex.
    // The regular expression and replacement should follow Java regex rules
    // at https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html.
    // The replacement string is allowed to refer to capturing groups.
    // For example, if one cell has the contents `"Google Sheets"` and another
    // has `"Google Docs"`, then searching for `"o.* (.*)"` with a replacement of
    // `"$1 Rocks"` would change the contents of the cells to
    // `"GSheets Rocks"` and `"GDocs Rocks"` respectively.
    bool searchByRegex = 8;
    // The sheet to find/replace over.
    int32 sheetId = 9;
}

message FindReplaceResponse {
    // The number of formula cells changed.
    int32 formulasChanged = 1;
    // The number of occurrences (possibly multiple within a cell) changed.
    // For example, if replacing `"e"` with `"o"` in `"Google Sheets"`, this would
    // be `"3"` because `"Google Sheets"` -> `"Googlo Shoots"`.
    int32 occurrencesChanged = 2;
    // The number of rows changed.
    int32 rowsChanged = 3;
    // The number of sheets changed.
    int32 sheetsChanged = 4;
    // The number of non-formula cells changed.
    int32 valuesChanged = 5;
}

message GetSpreadsheetByDataFilterRequest {
    // The DataFilters used to select which ranges to retrieve from
    // the spreadsheet.
    repeated DataFilter dataFilters = 1;
    // True if grid data should be returned.
    // This parameter is ignored if a field mask was set in the request.
    bool includeGridData = 2;
}

message GradientRule {
    // The final interpolation point.
    InterpolationPoint maxpoint = 1;
    // An optional midway interpolation point.
    InterpolationPoint midpoint = 2;
    // The starting interpolation point.
    InterpolationPoint minpoint = 3;
}

message GridCoordinate {
    // The column index of the coordinate.
    int32 columnIndex = 1;
    // The row index of the coordinate.
    int32 rowIndex = 2;
    // The sheet this coordinate is on.
    int32 sheetId = 3;
}

message GridData {
    // Metadata about the requested columns in the grid, starting with the column
    // in start_column.
    repeated DimensionProperties columnMetadata = 1;
    // The data in the grid, one entry per row,
    // starting with the row in startRow.
    // The values in RowData will correspond to columns starting
    // at start_column.
    repeated RowData rowData = 2;
    // Metadata about the requested rows in the grid, starting with the row
    // in start_row.
    repeated DimensionProperties rowMetadata = 3;
    // The first column this GridData refers to, zero-based.
    int32 startColumn = 4;
    // The first row this GridData refers to, zero-based.
    int32 startRow = 5;
}

message GridProperties {
    // The number of columns in the grid.
    int32 columnCount = 1;
    // The number of columns that are frozen in the grid.
    int32 frozenColumnCount = 2;
    // The number of rows that are frozen in the grid.
    int32 frozenRowCount = 3;
    // True if the grid isn't showing gridlines in the UI.
    bool hideGridlines = 4;
    // The number of rows in the grid.
    int32 rowCount = 5;
}

message GridRange {
    // The end column (exclusive) of the range, or not set if unbounded.
    int32 endColumnIndex = 1;
    // The end row (exclusive) of the range, or not set if unbounded.
    int32 endRowIndex = 2;
    // The sheet this range is on.
    int32 sheetId = 3;
    // The start column (inclusive) of the range, or not set if unbounded.
    int32 startColumnIndex = 4;
    // The start row (inclusive) of the range, or not set if unbounded.
    int32 startRowIndex = 5;
}

message HistogramChartSpec {
    // By default the bucket size (the range of values stacked in a single
    // column) is chosen automatically, but it may be overridden here.
    // E.g., A bucket size of 1.5 results in buckets from 0 - 1.5, 1.5 - 3.0, etc.
    // Cannot be negative.
    // This field is optional.
    double bucketSize = 1;
    // The position of the chart legend.
    enum HistogramChartSpec_LegendPosition {
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_HISTOGRAM_CHART_LEGEND_POSITION_UNSPECIFIED = 0;
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_BOTTOM_LEGEND = 1;
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_LEFT_LEGEND = 2;
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_RIGHT_LEGEND = 3;
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_TOP_LEGEND = 4;
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_NO_LEGEND = 5;
        HISTOGRAMCHARTSPEC_LEGENDPOSITION_INSIDE_LEGEND = 6;
    }
    HistogramChartSpec_LegendPosition legendPosition = 2;
    // The outlier percentile is used to ensure that outliers do not adversely
    // affect the calculation of bucket sizes.  For example, setting an outlier
    // percentile of 0.05 indicates that the top and bottom 5% of values when
    // calculating buckets.  The values are still included in the chart, they will
    // be added to the first or last buckets instead of their own buckets.
    // Must be between 0.0 and 0.5.
    double outlierPercentile = 3;
    // The series for a histogram may be either a single series of values to be
    // bucketed or multiple series, each of the same length, containing the name
    // of the series followed by the values to be bucketed for that series.
    repeated HistogramSeries series = 4;
    // Whether horizontal divider lines should be displayed between items in each
    // column.
    bool showItemDividers = 5;
}

message HistogramSeries {
    // The color of the column representing this series in each bucket.
    // This field is optional.
    Color barColor = 1;
    // The data for this histogram series.
    ChartData data = 2;
}

message InsertDimensionRequest {
    // Whether dimension properties should be extended from the dimensions
    // before or after the newly inserted dimensions.
    // True to inherit from the dimensions before (in which case the start
    // index must be greater than 0), and false to inherit from the dimensions
    // after.
    // 
    // For example, if row index 0 has red background and row index 1
    // has a green background, then inserting 2 rows at index 1 can inherit
    // either the green or red background.  If `inheritFromBefore` is true,
    // the two new rows will be red (because the row before the insertion point
    // was red), whereas if `inheritFromBefore` is false, the two new rows will
    // be green (because the row after the insertion point was green).
    bool inheritFromBefore = 1;
    // The dimensions to insert.  Both the start and end indexes must be bounded.
    DimensionRange range = 2;
}

message InsertRangeRequest {
    // The range to insert new cells into.
    GridRange range = 1;
    // The dimension which will be shifted when inserting cells.
    // If ROWS, existing cells will be shifted down.
    // If COLUMNS, existing cells will be shifted right.
    enum InsertRangeRequest_ShiftDimension {
        INSERTRANGEREQUEST_SHIFTDIMENSION_DIMENSION_UNSPECIFIED = 0;
        INSERTRANGEREQUEST_SHIFTDIMENSION_ROWS = 1;
        INSERTRANGEREQUEST_SHIFTDIMENSION_COLUMNS = 2;
    }
    InsertRangeRequest_ShiftDimension shiftDimension = 2;
}

message InterpolationPoint {
    // The color this interpolation point should use.
    Color color = 1;
    // How the value should be interpreted.
    enum InterpolationPoint_Type {
        INTERPOLATIONPOINT_TYPE_INTERPOLATION_POINT_TYPE_UNSPECIFIED = 0;
        INTERPOLATIONPOINT_TYPE_MIN = 1;
        INTERPOLATIONPOINT_TYPE_MAX = 2;
        INTERPOLATIONPOINT_TYPE_NUMBER = 3;
        INTERPOLATIONPOINT_TYPE_PERCENT = 4;
        INTERPOLATIONPOINT_TYPE_PERCENTILE = 5;
    }
    InterpolationPoint_Type type = 2;
    // The value this interpolation point uses.  May be a formula.
    // Unused if type is MIN or
    // MAX.
    string value = 3;
}

message IterativeCalculationSettings {
    // When iterative calculation is enabled and successive results differ by
    // less than this threshold value, the calculation rounds stop.
    double convergenceThreshold = 1;
    // When iterative calculation is enabled, the maximum number of calculation
    // rounds to perform.
    int32 maxIterations = 2;
}

message MatchedDeveloperMetadata {
    // All filters matching the returned developer metadata.
    repeated DataFilter dataFilters = 1;
    // The developer metadata matching the specified filters.
    DeveloperMetadata developerMetadata = 2;
}

message MatchedValueRange {
    // The DataFilters from the request that matched the range of
    // values.
    repeated DataFilter dataFilters = 1;
    // The values matched by the DataFilter.
    ValueRange valueRange = 2;
}

message MergeCellsRequest {
    // How the cells should be merged.
    enum MergeCellsRequest_MergeType {
        MERGECELLSREQUEST_MERGETYPE_MERGE_ALL = 0;
        MERGECELLSREQUEST_MERGETYPE_MERGE_COLUMNS = 1;
        MERGECELLSREQUEST_MERGETYPE_MERGE_ROWS = 2;
    }
    MergeCellsRequest_MergeType mergeType = 1;
    // The range of cells to merge.
    GridRange range = 2;
}

message MoveDimensionRequest {
    // The zero-based start index of where to move the source data to,
    // based on the coordinates *before* the source data is removed
    // from the grid.  Existing data will be shifted down or right
    // (depending on the dimension) to make room for the moved dimensions.
    // The source dimensions are removed from the grid, so the
    // the data may end up in a different index than specified.
    // 
    // For example, given `A1..A5` of `0, 1, 2, 3, 4` and wanting to move
    // `"1"` and `"2"` to between `"3"` and `"4"`, the source would be
    // `ROWS [1..3)`,and the destination index would be `"4"`
    // (the zero-based index of row 5).
    // The end result would be `A1..A5` of `0, 3, 1, 2, 4`.
    int32 destinationIndex = 1;
    // The source dimensions to move.
    DimensionRange source = 2;
}

message NamedRange {
    // The name of the named range.
    string name = 1;
    // The ID of the named range.
    string namedRangeId = 2;
    // The range this represents.
    GridRange range = 3;
}

message NumberFormat {
    // Pattern string used for formatting.  If not set, a default pattern based on
    // the user's locale will be used if necessary for the given type.
    // See the [Date and Number Formats guide](/sheets/api/guides/formats) for more
    // information about the supported patterns.
    string pattern = 1;
    // The type of the number format.
    // When writing, this field must be set.
    enum NumberFormat_Type {
        NUMBERFORMAT_TYPE_NUMBER_FORMAT_TYPE_UNSPECIFIED = 0;
        NUMBERFORMAT_TYPE_TEXT = 1;
        NUMBERFORMAT_TYPE_NUMBER = 2;
        NUMBERFORMAT_TYPE_PERCENT = 3;
        NUMBERFORMAT_TYPE_CURRENCY = 4;
        NUMBERFORMAT_TYPE_DATE = 5;
        NUMBERFORMAT_TYPE_TIME = 6;
        NUMBERFORMAT_TYPE_DATE_TIME = 7;
        NUMBERFORMAT_TYPE_SCIENTIFIC = 8;
    }
    NumberFormat_Type type = 2;
}

message OrgChartSpec {
    // The data containing the labels for all the nodes in the chart.  Labels
    // must be unique.
    ChartData labels = 1;
    // The color of the org chart nodes.
    Color nodeColor = 2;
    // The size of the org chart nodes.
    enum OrgChartSpec_NodeSize {
        ORGCHARTSPEC_NODESIZE_ORG_CHART_LABEL_SIZE_UNSPECIFIED = 0;
        ORGCHARTSPEC_NODESIZE_SMALL = 1;
        ORGCHARTSPEC_NODESIZE_MEDIUM = 2;
        ORGCHARTSPEC_NODESIZE_LARGE = 3;
    }
    OrgChartSpec_NodeSize nodeSize = 3;
    // The data containing the label of the parent for the corresponding node.
    // A blank value indicates that the node has no parent and is a top-level
    // node.
    // This field is optional.
    ChartData parentLabels = 4;
    // The color of the selected org chart nodes.
    Color selectedNodeColor = 5;
    // The data containing the tooltip for the corresponding node.  A blank value
    // results in no tooltip being displayed for the node.
    // This field is optional.
    ChartData tooltips = 6;
}

message OverlayPosition {
    // The cell the object is anchored to.
    GridCoordinate anchorCell = 1;
    // The height of the object, in pixels. Defaults to 371.
    int32 heightPixels = 2;
    // The horizontal offset, in pixels, that the object is offset
    // from the anchor cell.
    int32 offsetXPixels = 3;
    // The vertical offset, in pixels, that the object is offset
    // from the anchor cell.
    int32 offsetYPixels = 4;
    // The width of the object, in pixels. Defaults to 600.
    int32 widthPixels = 5;
}

message Padding {
    // The bottom padding of the cell.
    int32 bottom = 1;
    // The left padding of the cell.
    int32 left = 2;
    // The right padding of the cell.
    int32 right = 3;
    // The top padding of the cell.
    int32 top = 4;
}

message PasteDataRequest {
    // The coordinate at which the data should start being inserted.
    GridCoordinate coordinate = 1;
    // The data to insert.
    string data = 2;
    // The delimiter in the data.
    string delimiter = 3;
    // True if the data is HTML.
    bool html = 4;
    // How the data should be pasted.
    enum PasteDataRequest_Type {
        PASTEDATAREQUEST_TYPE_PASTE_NORMAL = 0;
        PASTEDATAREQUEST_TYPE_PASTE_VALUES = 1;
        PASTEDATAREQUEST_TYPE_PASTE_FORMAT = 2;
        PASTEDATAREQUEST_TYPE_PASTE_NO_BORDERS = 3;
        PASTEDATAREQUEST_TYPE_PASTE_FORMULA = 4;
        PASTEDATAREQUEST_TYPE_PASTE_DATA_VALIDATION = 5;
        PASTEDATAREQUEST_TYPE_PASTE_CONDITIONAL_FORMATTING = 6;
    }
    PasteDataRequest_Type type = 5;
}

message PieChartSpec {
    // The data that covers the domain of the pie chart.
    ChartData domain = 1;
    // Where the legend of the pie chart should be drawn.
    enum PieChartSpec_LegendPosition {
        PIECHARTSPEC_LEGENDPOSITION_PIE_CHART_LEGEND_POSITION_UNSPECIFIED = 0;
        PIECHARTSPEC_LEGENDPOSITION_BOTTOM_LEGEND = 1;
        PIECHARTSPEC_LEGENDPOSITION_LEFT_LEGEND = 2;
        PIECHARTSPEC_LEGENDPOSITION_RIGHT_LEGEND = 3;
        PIECHARTSPEC_LEGENDPOSITION_TOP_LEGEND = 4;
        PIECHARTSPEC_LEGENDPOSITION_NO_LEGEND = 5;
        PIECHARTSPEC_LEGENDPOSITION_LABELED_LEGEND = 6;
    }
    PieChartSpec_LegendPosition legendPosition = 2;
    // The size of the hole in the pie chart.
    double pieHole = 3;
    // The data that covers the one and only series of the pie chart.
    ChartData series = 4;
    // True if the pie is three dimensional.
    bool threeDimensional = 5;
}

message PivotFilterCriteria {
    // Values that should be included.  Values not listed here are excluded.
    repeated string visibleValues = 1;
}

message PivotGroup {
    // True if the pivot table should include the totals for this grouping.
    bool showTotals = 1;
    // The order the values in this group should be sorted.
    enum PivotGroup_SortOrder {
        PIVOTGROUP_SORTORDER_SORT_ORDER_UNSPECIFIED = 0;
        PIVOTGROUP_SORTORDER_ASCENDING = 1;
        PIVOTGROUP_SORTORDER_DESCENDING = 2;
    }
    PivotGroup_SortOrder sortOrder = 2;
    // The column offset of the source range that this grouping is based on.
    // 
    // For example, if the source was `C10:E15`, a `sourceColumnOffset` of `0`
    // means this group refers to column `C`, whereas the offset `1` would refer
    // to column `D`.
    int32 sourceColumnOffset = 3;
    // The bucket of the opposite pivot group to sort by.
    // If not specified, sorting is alphabetical by this group's values.
    PivotGroupSortValueBucket valueBucket = 4;
    // Metadata about values in the grouping.
    repeated PivotGroupValueMetadata valueMetadata = 5;
}

message PivotGroupSortValueBucket {
    // Determines the bucket from which values are chosen to sort.
    // 
    // For example, in a pivot table with one row group & two column groups,
    // the row group can list up to two values. The first value corresponds
    // to a value within the first column group, and the second value
    // corresponds to a value in the second column group.  If no values
    // are listed, this would indicate that the row should be sorted according
    // to the "Grand Total" over the column groups. If a single value is listed,
    // this would correspond to using the "Total" of that bucket.
    repeated ExtendedValue buckets = 1;
    // The offset in the PivotTable.values list which the values in this
    // grouping should be sorted by.
    int32 valuesIndex = 2;
}

message PivotGroupValueMetadata {
    // True if the data corresponding to the value is collapsed.
    bool collapsed = 1;
    // The calculated value the metadata corresponds to.
    // (Note that formulaValue is not valid,
    //  because the values will be calculated.)
    ExtendedValue value = 2;
}

message PivotTable {
    // Each column grouping in the pivot table.
    repeated PivotGroup columns = 1;
    // An optional mapping of filters per source column offset.
    // 
    // The filters will be applied before aggregating data into the pivot table.
    // The map's key is the column offset of the source range that you want to
    // filter, and the value is the criteria for that column.
    // 
    // For example, if the source was `C10:E15`, a key of `0` will have the filter
    // for column `C`, whereas the key `1` is for column `D`.
    map<string, PivotFilterCriteria> criteria = 2;
    // Each row grouping in the pivot table.
    repeated PivotGroup rows = 3;
    // The range the pivot table is reading data from.
    GridRange source = 4;
    // Whether values should be listed horizontally (as columns)
    // or vertically (as rows).
    enum PivotTable_ValueLayout {
        PIVOTTABLE_VALUELAYOUT_HORIZONTAL = 0;
        PIVOTTABLE_VALUELAYOUT_VERTICAL = 1;
    }
    PivotTable_ValueLayout valueLayout = 5;
    // A list of values to include in the pivot table.
    repeated PivotValue values = 6;
}

message PivotValue {
    // A custom formula to calculate the value.  The formula must start
    // with an `=` character.
    string formula = 1;
    // A name to use for the value. This is only used if formula was set.
    // Otherwise, the column name is used.
    string name = 2;
    // The column offset of the source range that this value reads from.
    // 
    // For example, if the source was `C10:E15`, a `sourceColumnOffset` of `0`
    // means this value refers to column `C`, whereas the offset `1` would
    // refer to column `D`.
    int32 sourceColumnOffset = 3;
    // A function to summarize the value.
    // If formula is set, the only supported values are
    // SUM and
    // CUSTOM.
    // If sourceColumnOffset is set, then `CUSTOM`
    // is not supported.
    enum PivotValue_SummarizeFunction {
        PIVOTVALUE_SUMMARIZEFUNCTION_PIVOT_STANDARD_VALUE_FUNCTION_UNSPECIFIED = 0;
        PIVOTVALUE_SUMMARIZEFUNCTION_SUM = 1;
        PIVOTVALUE_SUMMARIZEFUNCTION_COUNTA = 2;
        PIVOTVALUE_SUMMARIZEFUNCTION_COUNT = 3;
        PIVOTVALUE_SUMMARIZEFUNCTION_COUNTUNIQUE = 4;
        PIVOTVALUE_SUMMARIZEFUNCTION_AVERAGE = 5;
        PIVOTVALUE_SUMMARIZEFUNCTION_MAX = 6;
        PIVOTVALUE_SUMMARIZEFUNCTION_MIN = 7;
        PIVOTVALUE_SUMMARIZEFUNCTION_MEDIAN = 8;
        PIVOTVALUE_SUMMARIZEFUNCTION_PRODUCT = 9;
        PIVOTVALUE_SUMMARIZEFUNCTION_STDEV = 10;
        PIVOTVALUE_SUMMARIZEFUNCTION_STDEVP = 11;
        PIVOTVALUE_SUMMARIZEFUNCTION_VAR = 12;
        PIVOTVALUE_SUMMARIZEFUNCTION_VARP = 13;
        PIVOTVALUE_SUMMARIZEFUNCTION_CUSTOM = 14;
    }
    PivotValue_SummarizeFunction summarizeFunction = 4;
}

message ProtectedRange {
    // The description of this protected range.
    string description = 1;
    // The users and groups with edit access to the protected range.
    // This field is only visible to users with edit access to the protected
    // range and the document.
    // Editors are not supported with warning_only protection.
    Editors editors = 2;
    // The named range this protected range is backed by, if any.
    // 
    // When writing, only one of range or named_range_id
    // may be set.
    string namedRangeId = 3;
    // The ID of the protected range.
    // This field is read-only.
    int32 protectedRangeId = 4;
    // The range that is being protected.
    // The range may be fully unbounded, in which case this is considered
    // a protected sheet.
    // 
    // When writing, only one of range or named_range_id
    // may be set.
    GridRange range = 5;
    // True if the user who requested this protected range can edit the
    // protected area.
    // This field is read-only.
    bool requestingUserCanEdit = 6;
    // The list of unprotected ranges within a protected sheet.
    // Unprotected ranges are only supported on protected sheets.
    repeated GridRange unprotectedRanges = 7;
    // True if this protected range will show a warning when editing.
    // Warning-based protection means that every user can edit data in the
    // protected range, except editing will prompt a warning asking the user
    // to confirm the edit.
    // 
    // When writing: if this field is true, then editors is ignored.
    // Additionally, if this field is changed from true to false and the
    // `editors` field is not set (nor included in the field mask), then
    // the editors will be set to all the editors in the document.
    bool warningOnly = 8;
}

message RandomizeRangeRequest {
    // The range to randomize.
    GridRange range = 1;
}

message RepeatCellRequest {
    // The data to write.
    CellData cell = 1;
    // The fields that should be updated.  At least one field must be specified.
    // The root `cell` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 2;
    // The range to repeat the cell in.
    GridRange range = 3;
}

message Request {
    // Adds a new banded range
    AddBandingRequest addBanding = 1;
    // Adds a chart.
    AddChartRequest addChart = 2;
    // Adds a new conditional format rule.
    AddConditionalFormatRuleRequest addConditionalFormatRule = 3;
    // Adds a filter view.
    AddFilterViewRequest addFilterView = 4;
    // Adds a named range.
    AddNamedRangeRequest addNamedRange = 5;
    // Adds a protected range.
    AddProtectedRangeRequest addProtectedRange = 6;
    // Adds a sheet.
    AddSheetRequest addSheet = 7;
    // Appends cells after the last row with data in a sheet.
    AppendCellsRequest appendCells = 8;
    // Appends dimensions to the end of a sheet.
    AppendDimensionRequest appendDimension = 9;
    // Automatically fills in more data based on existing data.
    AutoFillRequest autoFill = 10;
    // Automatically resizes one or more dimensions based on the contents
    // of the cells in that dimension.
    AutoResizeDimensionsRequest autoResizeDimensions = 11;
    // Clears the basic filter on a sheet.
    ClearBasicFilterRequest clearBasicFilter = 12;
    // Copies data from one area and pastes it to another.
    CopyPasteRequest copyPaste = 13;
    // Creates new developer metadata
    CreateDeveloperMetadataRequest createDeveloperMetadata = 14;
    // Cuts data from one area and pastes it to another.
    CutPasteRequest cutPaste = 15;
    // Removes a banded range
    DeleteBandingRequest deleteBanding = 16;
    // Deletes an existing conditional format rule.
    DeleteConditionalFormatRuleRequest deleteConditionalFormatRule = 17;
    // Deletes developer metadata
    DeleteDeveloperMetadataRequest deleteDeveloperMetadata = 18;
    // Deletes rows or columns in a sheet.
    DeleteDimensionRequest deleteDimension = 19;
    // Deletes an embedded object (e.g, chart, image) in a sheet.
    DeleteEmbeddedObjectRequest deleteEmbeddedObject = 20;
    // Deletes a filter view from a sheet.
    DeleteFilterViewRequest deleteFilterView = 21;
    // Deletes a named range.
    DeleteNamedRangeRequest deleteNamedRange = 22;
    // Deletes a protected range.
    DeleteProtectedRangeRequest deleteProtectedRange = 23;
    // Deletes a range of cells from a sheet, shifting the remaining cells.
    DeleteRangeRequest deleteRange = 24;
    // Deletes a sheet.
    DeleteSheetRequest deleteSheet = 25;
    // Duplicates a filter view.
    DuplicateFilterViewRequest duplicateFilterView = 26;
    // Duplicates a sheet.
    DuplicateSheetRequest duplicateSheet = 27;
    // Finds and replaces occurrences of some text with other text.
    FindReplaceRequest findReplace = 28;
    // Inserts new rows or columns in a sheet.
    InsertDimensionRequest insertDimension = 29;
    // Inserts new cells in a sheet, shifting the existing cells.
    InsertRangeRequest insertRange = 30;
    // Merges cells together.
    MergeCellsRequest mergeCells = 31;
    // Moves rows or columns to another location in a sheet.
    MoveDimensionRequest moveDimension = 32;
    // Pastes data (HTML or delimited) into a sheet.
    PasteDataRequest pasteData = 33;
    // Randomizes the order of the rows in a range.
    RandomizeRangeRequest randomizeRange = 34;
    // Repeats a single cell across a range.
    RepeatCellRequest repeatCell = 35;
    // Sets the basic filter on a sheet.
    SetBasicFilterRequest setBasicFilter = 36;
    // Sets data validation for one or more cells.
    SetDataValidationRequest setDataValidation = 37;
    // Sorts data in a range.
    SortRangeRequest sortRange = 38;
    // Converts a column of text into many columns of text.
    TextToColumnsRequest textToColumns = 39;
    // Unmerges merged cells.
    UnmergeCellsRequest unmergeCells = 40;
    // Updates a banded range
    UpdateBandingRequest updateBanding = 41;
    // Updates the borders in a range of cells.
    UpdateBordersRequest updateBorders = 42;
    // Updates many cells at once.
    UpdateCellsRequest updateCells = 43;
    // Updates a chart's specifications.
    UpdateChartSpecRequest updateChartSpec = 44;
    // Updates an existing conditional format rule.
    UpdateConditionalFormatRuleRequest updateConditionalFormatRule = 45;
    // Updates an existing developer metadata entry
    UpdateDeveloperMetadataRequest updateDeveloperMetadata = 46;
    // Updates dimensions' properties.
    UpdateDimensionPropertiesRequest updateDimensionProperties = 47;
    // Updates an embedded object's (e.g. chart, image) position.
    UpdateEmbeddedObjectPositionRequest updateEmbeddedObjectPosition = 48;
    // Updates the properties of a filter view.
    UpdateFilterViewRequest updateFilterView = 49;
    // Updates a named range.
    UpdateNamedRangeRequest updateNamedRange = 50;
    // Updates a protected range.
    UpdateProtectedRangeRequest updateProtectedRange = 51;
    // Updates a sheet's properties.
    UpdateSheetPropertiesRequest updateSheetProperties = 52;
    // Updates the spreadsheet's properties.
    UpdateSpreadsheetPropertiesRequest updateSpreadsheetProperties = 53;
}

message Response {
    // A reply from adding a banded range.
    AddBandingResponse addBanding = 1;
    // A reply from adding a chart.
    AddChartResponse addChart = 2;
    // A reply from adding a filter view.
    AddFilterViewResponse addFilterView = 3;
    // A reply from adding a named range.
    AddNamedRangeResponse addNamedRange = 4;
    // A reply from adding a protected range.
    AddProtectedRangeResponse addProtectedRange = 5;
    // A reply from adding a sheet.
    AddSheetResponse addSheet = 6;
    // A reply from creating a developer metadata entry.
    CreateDeveloperMetadataResponse createDeveloperMetadata = 7;
    // A reply from deleting a conditional format rule.
    DeleteConditionalFormatRuleResponse deleteConditionalFormatRule = 8;
    // A reply from deleting a developer metadata entry.
    DeleteDeveloperMetadataResponse deleteDeveloperMetadata = 9;
    // A reply from duplicating a filter view.
    DuplicateFilterViewResponse duplicateFilterView = 10;
    // A reply from duplicating a sheet.
    DuplicateSheetResponse duplicateSheet = 11;
    // A reply from doing a find/replace.
    FindReplaceResponse findReplace = 12;
    // A reply from updating a conditional format rule.
    UpdateConditionalFormatRuleResponse updateConditionalFormatRule = 13;
    // A reply from updating a developer metadata entry.
    UpdateDeveloperMetadataResponse updateDeveloperMetadata = 14;
    // A reply from updating an embedded object's position.
    UpdateEmbeddedObjectPositionResponse updateEmbeddedObjectPosition = 15;
}

message RowData {
    // The values in the row, one per column.
    repeated CellData values = 1;
}

message SearchDeveloperMetadataRequest {
    // The data filters describing the criteria used to determine which
    // DeveloperMetadata entries to return.  DeveloperMetadata matching any of the
    // specified filters will be included in the response.
    repeated DataFilter dataFilters = 1;
}

message SearchDeveloperMetadataResponse {
    // The metadata matching the criteria of the search request.
    repeated MatchedDeveloperMetadata matchedDeveloperMetadata = 1;
}

message SetBasicFilterRequest {
    // The filter to set.
    BasicFilter filter = 1;
}

message SetDataValidationRequest {
    // The range the data validation rule should apply to.
    GridRange range = 1;
    // The data validation rule to set on each cell in the range,
    // or empty to clear the data validation in the range.
    DataValidationRule rule = 2;
}

message Sheet {
    // The banded (i.e. alternating colors) ranges on this sheet.
    repeated BandedRange bandedRanges = 1;
    // The filter on this sheet, if any.
    BasicFilter basicFilter = 2;
    // The specifications of every chart on this sheet.
    repeated EmbeddedChart charts = 3;
    // The conditional format rules in this sheet.
    repeated ConditionalFormatRule conditionalFormats = 4;
    // Data in the grid, if this is a grid sheet.
    // The number of GridData objects returned is dependent on the number of
    // ranges requested on this sheet. For example, if this is representing
    // `Sheet1`, and the spreadsheet was requested with ranges
    // `Sheet1!A1:C10` and `Sheet1!D15:E20`, then the first GridData will have a
    // startRow/startColumn of `0`,
    // while the second one will have `startRow 14` (zero-based row 15),
    // and `startColumn 3` (zero-based column D).
    repeated GridData data = 5;
    // The developer metadata associated with a sheet.
    repeated DeveloperMetadata developerMetadata = 6;
    // The filter views in this sheet.
    repeated FilterView filterViews = 7;
    // The ranges that are merged together.
    repeated GridRange merges = 8;
    // The properties of the sheet.
    SheetProperties properties = 9;
    // The protected ranges in this sheet.
    repeated ProtectedRange protectedRanges = 10;
}

message SheetProperties {
    // Additional properties of the sheet if this sheet is a grid.
    // (If the sheet is an object sheet, containing a chart or image, then
    // this field will be absent.)
    // When writing it is an error to set any grid properties on non-grid sheets.
    GridProperties gridProperties = 1;
    // True if the sheet is hidden in the UI, false if it's visible.
    bool hidden = 2;
    // The index of the sheet within the spreadsheet.
    // When adding or updating sheet properties, if this field
    // is excluded then the sheet will be added or moved to the end
    // of the sheet list. When updating sheet indices or inserting
    // sheets, movement is considered in "before the move" indexes.
    // For example, if there were 3 sheets (S1, S2, S3) in order to
    // move S1 ahead of S2 the index would have to be set to 2. A sheet
    // index update request will be ignored if the requested index is
    // identical to the sheets current index or if the requested new
    // index is equal to the current sheet index + 1.
    int32 index = 3;
    // True if the sheet is an RTL sheet instead of an LTR sheet.
    bool rightToLeft = 4;
    // The ID of the sheet. Must be non-negative.
    // This field cannot be changed once set.
    int32 sheetId = 5;
    // The type of sheet. Defaults to GRID.
    // This field cannot be changed once set.
    enum SheetProperties_SheetType {
        SHEETPROPERTIES_SHEETTYPE_SHEET_TYPE_UNSPECIFIED = 0;
        SHEETPROPERTIES_SHEETTYPE_GRID = 1;
        SHEETPROPERTIES_SHEETTYPE_OBJECT = 2;
    }
    SheetProperties_SheetType sheetType = 6;
    // The color of the tab in the UI.
    Color tabColor = 7;
    // The name of the sheet.
    string title = 8;
}

message SortRangeRequest {
    // The range to sort.
    GridRange range = 1;
    // The sort order per column. Later specifications are used when values
    // are equal in the earlier specifications.
    repeated SortSpec sortSpecs = 2;
}

message SortSpec {
    // The dimension the sort should be applied to.
    int32 dimensionIndex = 1;
    // The order data should be sorted.
    enum SortSpec_SortOrder {
        SORTSPEC_SORTORDER_SORT_ORDER_UNSPECIFIED = 0;
        SORTSPEC_SORTORDER_ASCENDING = 1;
        SORTSPEC_SORTORDER_DESCENDING = 2;
    }
    SortSpec_SortOrder sortOrder = 2;
}

message SourceAndDestination {
    // The dimension that data should be filled into.
    enum SourceAndDestination_Dimension {
        SOURCEANDDESTINATION_DIMENSION_DIMENSION_UNSPECIFIED = 0;
        SOURCEANDDESTINATION_DIMENSION_ROWS = 1;
        SOURCEANDDESTINATION_DIMENSION_COLUMNS = 2;
    }
    SourceAndDestination_Dimension dimension = 1;
    // The number of rows or columns that data should be filled into.
    // Positive numbers expand beyond the last row or last column
    // of the source.  Negative numbers expand before the first row
    // or first column of the source.
    int32 fillLength = 2;
    // The location of the data to use as the source of the autofill.
    GridRange source = 3;
}

message Spreadsheet {
    // The developer metadata associated with a spreadsheet.
    repeated DeveloperMetadata developerMetadata = 1;
    // The named ranges defined in a spreadsheet.
    repeated NamedRange namedRanges = 2;
    // Overall properties of a spreadsheet.
    SpreadsheetProperties properties = 3;
    // The sheets that are part of a spreadsheet.
    repeated Sheet sheets = 4;
    // The ID of the spreadsheet.
    // This field is read-only.
    string spreadsheetId = 5;
    // The url of the spreadsheet.
    // This field is read-only.
    string spreadsheetUrl = 6;
}

message SpreadsheetProperties {
    // The amount of time to wait before volatile functions are recalculated.
    enum SpreadsheetProperties_AutoRecalc {
        SPREADSHEETPROPERTIES_AUTORECALC_RECALCULATION_INTERVAL_UNSPECIFIED = 0;
        SPREADSHEETPROPERTIES_AUTORECALC_ON_CHANGE = 1;
        SPREADSHEETPROPERTIES_AUTORECALC_MINUTE = 2;
        SPREADSHEETPROPERTIES_AUTORECALC_HOUR = 3;
    }
    SpreadsheetProperties_AutoRecalc autoRecalc = 1;
    // The default format of all cells in the spreadsheet.
    // CellData.effectiveFormat will not be set if the
    // cell's format is equal to this default format.
    // This field is read-only.
    CellFormat defaultFormat = 2;
    // Determines whether and how circular references are resolved with iterative
    // calculation.  Absence of this field means that circular references will
    // result in calculation errors.
    IterativeCalculationSettings iterativeCalculationSettings = 3;
    // The locale of the spreadsheet in one of the following formats:
    // 
    // * an ISO 639-1 language code such as `en`
    // 
    // * an ISO 639-2 language code such as `fil`, if no 639-1 code exists
    // 
    // * a combination of the ISO language code and country code, such as `en_US`
    // 
    // Note: when updating this field, not all locales/languages are supported.
    string locale = 4;
    // The time zone of the spreadsheet, in CLDR format such as
    // `America/New_York`. If the time zone isn't recognized, this may
    // be a custom time zone such as `GMT-07:00`.
    string timeZone = 5;
    // The title of the spreadsheet.
    string title = 6;
}

message TextFormat {
    // True if the text is bold.
    bool bold = 1;
    // The font family.
    string fontFamily = 2;
    // The size of the font.
    int32 fontSize = 3;
    // The foreground color of the text.
    Color foregroundColor = 4;
    // True if the text is italicized.
    bool italic = 5;
    // True if the text has a strikethrough.
    bool strikethrough = 6;
    // True if the text is underlined.
    bool underline = 7;
}

message TextFormatRun {
    // The format of this run.  Absent values inherit the cell's format.
    TextFormat format = 1;
    // The character index where this run starts.
    int32 startIndex = 2;
}

message TextPosition {
    // Horizontal alignment setting for the piece of text.
    enum TextPosition_HorizontalAlignment {
        TEXTPOSITION_HORIZONTALALIGNMENT_HORIZONTAL_ALIGN_UNSPECIFIED = 0;
        TEXTPOSITION_HORIZONTALALIGNMENT_LEFT = 1;
        TEXTPOSITION_HORIZONTALALIGNMENT_CENTER = 2;
        TEXTPOSITION_HORIZONTALALIGNMENT_RIGHT = 3;
    }
    TextPosition_HorizontalAlignment horizontalAlignment = 1;
}

message TextRotation {
    // The angle between the standard orientation and the desired orientation.
    // Measured in degrees. Valid values are between -90 and 90. Positive
    // angles are angled upwards, negative are angled downwards.
    // 
    // Note: For LTR text direction positive angles are in the counterclockwise
    // direction, whereas for RTL they are in the clockwise direction
    int32 angle = 1;
    // If true, text reads top to bottom, but the orientation of individual
    // characters is unchanged.
    // For example:
    // 
    //     | V |
    //     | e |
    //     | r |
    //     | t |
    //     | i |
    //     | c |
    //     | a |
    //     | l |
    bool vertical = 2;
}

message TextToColumnsRequest {
    // The delimiter to use. Used only if delimiterType is
    // CUSTOM.
    string delimiter = 1;
    // The delimiter type to use.
    enum TextToColumnsRequest_DelimiterType {
        TEXTTOCOLUMNSREQUEST_DELIMITERTYPE_DELIMITER_TYPE_UNSPECIFIED = 0;
        TEXTTOCOLUMNSREQUEST_DELIMITERTYPE_COMMA = 1;
        TEXTTOCOLUMNSREQUEST_DELIMITERTYPE_SEMICOLON = 2;
        TEXTTOCOLUMNSREQUEST_DELIMITERTYPE_PERIOD = 3;
        TEXTTOCOLUMNSREQUEST_DELIMITERTYPE_SPACE = 4;
        TEXTTOCOLUMNSREQUEST_DELIMITERTYPE_CUSTOM = 5;
    }
    TextToColumnsRequest_DelimiterType delimiterType = 2;
    // The source data range.  This must span exactly one column.
    GridRange source = 3;
}

message UnmergeCellsRequest {
    // The range within which all cells should be unmerged.
    // If the range spans multiple merges, all will be unmerged.
    // The range must not partially span any merge.
    GridRange range = 1;
}

message UpdateBandingRequest {
    // The banded range to update with the new properties.
    BandedRange bandedRange = 1;
    // The fields that should be updated.  At least one field must be specified.
    // The root `bandedRange` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 2;
}

message UpdateBordersRequest {
    // The border to put at the bottom of the range.
    Border bottom = 1;
    // The horizontal border to put within the range.
    Border innerHorizontal = 2;
    // The vertical border to put within the range.
    Border innerVertical = 3;
    // The border to put at the left of the range.
    Border left = 4;
    // The range whose borders should be updated.
    GridRange range = 5;
    // The border to put at the right of the range.
    Border right = 6;
    // The border to put at the top of the range.
    Border top = 7;
}

message UpdateCellsRequest {
    // The fields of CellData that should be updated.
    // At least one field must be specified.
    // The root is the CellData; 'row.values.' should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The range to write data to.
    // 
    // If the data in rows does not cover the entire requested range,
    // the fields matching those set in fields will be cleared.
    GridRange range = 2;
    // The data to write.
    repeated RowData rows = 3;
    // The coordinate to start writing data at.
    // Any number of rows and columns (including a different number of
    // columns per row) may be written.
    GridCoordinate start = 4;
}

message UpdateChartSpecRequest {
    // The ID of the chart to update.
    int32 chartId = 1;
    // The specification to apply to the chart.
    ChartSpec spec = 2;
}

message UpdateConditionalFormatRuleRequest {
    // The zero-based index of the rule that should be replaced or moved.
    int32 index = 1;
    // The zero-based new index the rule should end up at.
    int32 newIndex = 2;
    // The rule that should replace the rule at the given index.
    ConditionalFormatRule rule = 3;
    // The sheet of the rule to move.  Required if new_index is set,
    // unused otherwise.
    int32 sheetId = 4;
}

message UpdateConditionalFormatRuleResponse {
    // The index of the new rule.
    int32 newIndex = 1;
    // The new rule that replaced the old rule (if replacing),
    // or the rule that was moved (if moved)
    ConditionalFormatRule newRule = 2;
    // The old index of the rule. Not set if a rule was replaced
    // (because it is the same as new_index).
    int32 oldIndex = 3;
    // The old (deleted) rule. Not set if a rule was moved
    // (because it is the same as new_rule).
    ConditionalFormatRule oldRule = 4;
}

message UpdateDeveloperMetadataRequest {
    // The filters matching the developer metadata entries to update.
    repeated DataFilter dataFilters = 1;
    // The value that all metadata matched by the data filters will be updated to.
    DeveloperMetadata developerMetadata = 2;
    // The fields that should be updated.  At least one field must be specified.
    // The root `developerMetadata` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 3;
}

message UpdateDeveloperMetadataResponse {
    // The updated developer metadata.
    repeated DeveloperMetadata developerMetadata = 1;
}

message UpdateDimensionPropertiesRequest {
    // The fields that should be updated.  At least one field must be specified.
    // The root `properties` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // Properties to update.
    DimensionProperties properties = 2;
    // The rows or columns to update.
    DimensionRange range = 3;
}

message UpdateEmbeddedObjectPositionRequest {
    // The fields of OverlayPosition
    // that should be updated when setting a new position. Used only if
    // newPosition.overlayPosition
    // is set, in which case at least one field must
    // be specified.  The root `newPosition.overlayPosition` is implied and
    // should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // An explicit position to move the embedded object to.
    // If newPosition.sheetId is set,
    // a new sheet with that ID will be created.
    // If newPosition.newSheet is set to true,
    // a new sheet will be created with an ID that will be chosen for you.
    EmbeddedObjectPosition newPosition = 2;
    // The ID of the object to moved.
    int32 objectId = 3;
}

message UpdateEmbeddedObjectPositionResponse {
    // The new position of the embedded object.
    EmbeddedObjectPosition position = 1;
}

message UpdateFilterViewRequest {
    // The fields that should be updated.  At least one field must be specified.
    // The root `filter` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The new properties of the filter view.
    FilterView filter = 2;
}

message UpdateNamedRangeRequest {
    // The fields that should be updated.  At least one field must be specified.
    // The root `namedRange` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The named range to update with the new properties.
    NamedRange namedRange = 2;
}

message UpdateProtectedRangeRequest {
    // The fields that should be updated.  At least one field must be specified.
    // The root `protectedRange` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The protected range to update with the new properties.
    ProtectedRange protectedRange = 2;
}

message UpdateSheetPropertiesRequest {
    // The fields that should be updated.  At least one field must be specified.
    // The root `properties` is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The properties to update.
    SheetProperties properties = 2;
}

message UpdateSpreadsheetPropertiesRequest {
    // The fields that should be updated.  At least one field must be specified.
    // The root 'properties' is implied and should not be specified.
    // A single `"*"` can be used as short-hand for listing every field.
    string fields = 1;
    // The properties to update.
    SpreadsheetProperties properties = 2;
}

message UpdateValuesByDataFilterResponse {
    // The data filter that selected the range that was updated.
    DataFilter dataFilter = 1;
    // The number of cells updated.
    int32 updatedCells = 2;
    // The number of columns where at least one cell in the column was updated.
    int32 updatedColumns = 3;
    // The values of the cells in the range matched by the dataFilter after all
    // updates were applied. This is only included if the request's
    // `includeValuesInResponse` field was `true`.
    ValueRange updatedData = 4;
    // The range (in A1 notation) that updates were applied to.
    string updatedRange = 5;
    // The number of rows where at least one cell in the row was updated.
    int32 updatedRows = 6;
}

message UpdateValuesResponse {
    // The spreadsheet the updates were applied to.
    string spreadsheetId = 1;
    // The number of cells updated.
    int32 updatedCells = 2;
    // The number of columns where at least one cell in the column was updated.
    int32 updatedColumns = 3;
    // The values of the cells after updates were applied.
    // This is only included if the request's `includeValuesInResponse` field
    // was `true`.
    ValueRange updatedData = 4;
    // The range (in A1 notation) that updates were applied to.
    string updatedRange = 5;
    // The number of rows where at least one cell in the row was updated.
    int32 updatedRows = 6;
}

message ValueRange {
    // The major dimension of the values.
    // 
    // For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`,
    // then requesting `range=A1:B2,majorDimension=ROWS` will return
    // `[[1,2],[3,4]]`,
    // whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return
    // `[[1,3],[2,4]]`.
    // 
    // For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]`
    // will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS`
    // then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`.
    // 
    // When writing, if this field is not set, it defaults to ROWS.
    enum ValueRange_MajorDimension {
        VALUERANGE_MAJORDIMENSION_DIMENSION_UNSPECIFIED = 0;
        VALUERANGE_MAJORDIMENSION_ROWS = 1;
        VALUERANGE_MAJORDIMENSION_COLUMNS = 2;
    }
    ValueRange_MajorDimension majorDimension = 1;
    // The range the values cover, in A1 notation.
    // For output, this range indicates the entire requested range,
    // even though the values will exclude trailing rows and columns.
    // When appending values, this field represents the range to search for a
    // table, after which values will be appended.
    string range = 2;
    // The data that was read or to be written.  This is an array of arrays,
    // the outer array representing all the data and each inner array
    // representing a major dimension. Each item in the inner array
    // corresponds with one cell.
    // 
    // For output, empty trailing rows and columns will not be included.
    // 
    // For input, supported value types are: bool, string, and double.
    // Null values will be skipped.
    // To set a cell to an empty value, set the string value to an empty string.
    message Value {
    }
    repeated Value values = 3;
}

enum Alt {
    JSON = 0;
    MEDIA = 1;
    PROTO = 2;
}

service GoogleSheetsService {
    // Creates a spreadsheet, returning the newly created spreadsheet.
    rpc PostV4Spreadsheets(PostV4SpreadsheetsRequest) returns (Spreadsheet) {
      option (google.api.http) = {
        post: "//v4/spreadsheets"
        body: "body"
      };
    }
    // Returns the spreadsheet at the given ID.
    // The caller must specify the spreadsheet ID.
    // 
    // By default, data within grids will not be returned.
    // You can include grid data one of two ways:
    // 
    // * Specify a field mask listing your desired fields using the `fields` URL
    // parameter in HTTP
    // 
    // * Set the includeGridData
    // URL parameter to true.  If a field mask is set, the `includeGridData`
    // parameter is ignored
    // 
    // For large spreadsheets, it is recommended to retrieve only the specific
    // fields of the spreadsheet that you want.
    // 
    // To retrieve only subsets of the spreadsheet, use the
    // ranges URL parameter.
    // Multiple ranges can be specified.  Limiting the range will
    // return only the portions of the spreadsheet that intersect the requested
    // ranges. Ranges are specified using A1 notation.
    rpc GetV4SpreadsheetsSpreadsheetId(GetV4SpreadsheetsSpreadsheetIdRequest) returns (Spreadsheet) {
      option (google.api.http) = {
        get: "//v4/spreadsheets/{spreadsheetId}"
      };
    }
    // Returns the developer metadata with the specified ID.
    // The caller must specify the spreadsheet ID and the developer metadata's
    // unique metadataId.
    rpc GetV4SpreadsheetsSpreadsheetIdDeveloperMetadataMetadataId(GetV4SpreadsheetsSpreadsheetIdDeveloperMetadataMetadataIdRequest) returns (DeveloperMetadata) {
      option (google.api.http) = {
        get: "//v4/spreadsheets/{spreadsheetId}/developerMetadata/{metadataId}"
      };
    }
    // Returns all developer metadata matching the specified DataFilter.
    // If the provided DataFilter represents a DeveloperMetadataLookup object,
    // this will return all DeveloperMetadata entries selected by it. If the
    // DataFilter represents a location in a spreadsheet, this will return all
    // developer metadata associated with locations intersecting that region.
    rpc PostV4SpreadsheetsSpreadsheetIdDeveloperMetadata:Search(PostV4SpreadsheetsSpreadsheetIdDeveloperMetadata:SearchRequest) returns (SearchDeveloperMetadataResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/developerMetadata:search"
        body: "body"
      };
    }
    // Copies a single sheet from a spreadsheet to another spreadsheet.
    // Returns the properties of the newly created sheet.
    rpc PostV4SpreadsheetsSpreadsheetIdSheetsSheetId:CopyTo(PostV4SpreadsheetsSpreadsheetIdSheetsSheetId:CopyToRequest) returns (SheetProperties) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/sheets/{sheetId}:copyTo"
        body: "body"
      };
    }
    // Returns a range of values from a spreadsheet.
    // The caller must specify the spreadsheet ID and a range.
    rpc GetV4SpreadsheetsSpreadsheetIdValuesRange(GetV4SpreadsheetsSpreadsheetIdValuesRangeRequest) returns (ValueRange) {
      option (google.api.http) = {
        get: "//v4/spreadsheets/{spreadsheetId}/values/{range}"
      };
    }
    // Sets values in a range of a spreadsheet.
    // The caller must specify the spreadsheet ID, range, and
    // a valueInputOption.
    rpc PutV4SpreadsheetsSpreadsheetIdValuesRange(PutV4SpreadsheetsSpreadsheetIdValuesRangeRequest) returns (UpdateValuesResponse) {
      option (google.api.http) = {
        put: "//v4/spreadsheets/{spreadsheetId}/values/{range}"
        body: "body"
      };
    }
    // Appends values to a spreadsheet. The input range is used to search for
    // existing data and find a "table" within that range. Values will be
    // appended to the next row of the table, starting with the first column of
    // the table. See the
    // [guide](/sheets/api/guides/values#appending_values)
    // and
    // [sample code](/sheets/api/samples/writing#append_values)
    // for specific details of how tables are detected and data is appended.
    // 
    // The caller must specify the spreadsheet ID, range, and
    // a valueInputOption.  The `valueInputOption` only
    // controls how the input data will be added to the sheet (column-wise or
    // row-wise), it does not influence what cell the data starts being written
    // to.
    rpc PostV4SpreadsheetsSpreadsheetIdValuesRange:Append(PostV4SpreadsheetsSpreadsheetIdValuesRange:AppendRequest) returns (AppendValuesResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values/{range}:append"
        body: "body"
      };
    }
    // Clears values from a spreadsheet.
    // The caller must specify the spreadsheet ID and range.
    // Only values are cleared -- all other properties of the cell (such as
    // formatting, data validation, etc..) are kept.
    rpc PostV4SpreadsheetsSpreadsheetIdValuesRange:Clear(PostV4SpreadsheetsSpreadsheetIdValuesRange:ClearRequest) returns (ClearValuesResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values/{range}:clear"
        body: "body"
      };
    }
    // Clears one or more ranges of values from a spreadsheet.
    // The caller must specify the spreadsheet ID and one or more ranges.
    // Only values are cleared -- all other properties of the cell (such as
    // formatting, data validation, etc..) are kept.
    rpc PostV4SpreadsheetsSpreadsheetIdValues:BatchClear(PostV4SpreadsheetsSpreadsheetIdValues:BatchClearRequest) returns (BatchClearValuesResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values:batchClear"
        body: "body"
      };
    }
    // Clears one or more ranges of values from a spreadsheet.
    // The caller must specify the spreadsheet ID and one or more
    // DataFilters. Ranges matching any of the specified data
    // filters will be cleared.  Only values are cleared -- all other properties
    // of the cell (such as formatting, data validation, etc..) are kept.
    rpc PostV4SpreadsheetsSpreadsheetIdValues:BatchClearByDataFilter(PostV4SpreadsheetsSpreadsheetIdValues:BatchClearByDataFilterRequest) returns (BatchClearValuesByDataFilterResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values:batchClearByDataFilter"
        body: "body"
      };
    }
    // Returns one or more ranges of values from a spreadsheet.
    // The caller must specify the spreadsheet ID and one or more ranges.
    rpc GetV4SpreadsheetsSpreadsheetIdValues:BatchGet(GetV4SpreadsheetsSpreadsheetIdValues:BatchGetRequest) returns (BatchGetValuesResponse) {
      option (google.api.http) = {
        get: "//v4/spreadsheets/{spreadsheetId}/values:batchGet"
      };
    }
    // Returns one or more ranges of values that match the specified data filters.
    // The caller must specify the spreadsheet ID and one or more
    // DataFilters.  Ranges that match any of the data filters in
    // the request will be returned.
    rpc PostV4SpreadsheetsSpreadsheetIdValues:BatchGetByDataFilter(PostV4SpreadsheetsSpreadsheetIdValues:BatchGetByDataFilterRequest) returns (BatchGetValuesByDataFilterResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values:batchGetByDataFilter"
        body: "body"
      };
    }
    // Sets values in one or more ranges of a spreadsheet.
    // The caller must specify the spreadsheet ID,
    // a valueInputOption, and one or more
    // ValueRanges.
    rpc PostV4SpreadsheetsSpreadsheetIdValues:BatchUpdate(PostV4SpreadsheetsSpreadsheetIdValues:BatchUpdateRequest) returns (BatchUpdateValuesResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values:batchUpdate"
        body: "body"
      };
    }
    // Sets values in one or more ranges of a spreadsheet.
    // The caller must specify the spreadsheet ID,
    // a valueInputOption, and one or more
    // DataFilterValueRanges.
    rpc PostV4SpreadsheetsSpreadsheetIdValues:BatchUpdateByDataFilter(PostV4SpreadsheetsSpreadsheetIdValues:BatchUpdateByDataFilterRequest) returns (BatchUpdateValuesByDataFilterResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}/values:batchUpdateByDataFilter"
        body: "body"
      };
    }
    // Applies one or more updates to the spreadsheet.
    // 
    // Each request is validated before
    // being applied. If any request is not valid then the entire request will
    // fail and nothing will be applied.
    // 
    // Some requests have replies to
    // give you some information about how
    // they are applied. The replies will mirror the requests.  For example,
    // if you applied 4 updates and the 3rd one had a reply, then the
    // response will have 2 empty replies, the actual reply, and another empty
    // reply, in that order.
    // 
    // Due to the collaborative nature of spreadsheets, it is not guaranteed that
    // the spreadsheet will reflect exactly your changes after this completes,
    // however it is guaranteed that the updates in the request will be
    // applied together atomically. Your changes may be altered with respect to
    // collaborator changes. If there are no collaborators, the spreadsheet
    // should reflect your changes.
    rpc PostV4SpreadsheetsSpreadsheetId:BatchUpdate(PostV4SpreadsheetsSpreadsheetId:BatchUpdateRequest) returns (BatchUpdateSpreadsheetResponse) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}:batchUpdate"
        body: "body"
      };
    }
    // Returns the spreadsheet at the given ID.
    // The caller must specify the spreadsheet ID.
    // 
    // This method differs from GetSpreadsheet in that it allows selecting
    // which subsets of spreadsheet data to return by specifying a
    // dataFilters parameter.
    // Multiple DataFilters can be specified.  Specifying one or
    // more data filters will return the portions of the spreadsheet that
    // intersect ranges matched by any of the filters.
    // 
    // By default, data within grids will not be returned.
    // You can include grid data one of two ways:
    // 
    // * Specify a field mask listing your desired fields using the `fields` URL
    // parameter in HTTP
    // 
    // * Set the includeGridData
    // parameter to true.  If a field mask is set, the `includeGridData`
    // parameter is ignored
    // 
    // For large spreadsheets, it is recommended to retrieve only the specific
    // fields of the spreadsheet that you want.
    rpc PostV4SpreadsheetsSpreadsheetId:GetByDataFilter(PostV4SpreadsheetsSpreadsheetId:GetByDataFilterRequest) returns (Spreadsheet) {
      option (google.api.http) = {
        post: "//v4/spreadsheets/{spreadsheetId}:getByDataFilter"
        body: "body"
      };
    }
}
