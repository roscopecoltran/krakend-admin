syntax = "proto3";

import "google/api/annotations.proto";

package googlecloudpub/sub;

message GetV1beta1aSubscriptionsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    // Maximum number of subscriptions to return.
    int32 maxResults = 8;
    string oauth_token = 9;
    // The value obtained in the last <code>ListSubscriptionsResponse</code>
    // for continuation.
    string pageToken = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    // A valid label query expression.
    string query = 13;
    string quotaUser = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message PostV1beta1aSubscriptionsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    Subscription body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aSubscriptionsAcknowledgeRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    AcknowledgeRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aSubscriptionsModifyAckDeadlineRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ModifyAckDeadlineRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aSubscriptionsModifyPushConfigRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ModifyPushConfigRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aSubscriptionsPullRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    PullRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aSubscriptionsPullBatchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    PullBatchRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1beta1aSubscriptionsSubscriptionRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The name of the subscription to get.
    string subscription = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message DeleteV1beta1aSubscriptionsSubscriptionRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The subscription to delete.
    string subscription = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1beta1aTopicsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    // Maximum number of topics to return.
    int32 maxResults = 8;
    string oauth_token = 9;
    // The value obtained in the last <code>ListTopicsResponse</code>
    // for continuation.
    string pageToken = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    // A valid label query expression.
    string query = 13;
    string quotaUser = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message PostV1beta1aTopicsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    Topic body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aTopicsPublishRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    PublishRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1beta1aTopicsPublishBatchRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    PublishBatchRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1beta1aTopicsTopicRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // The name of the topic to get.
    string topic = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message DeleteV1beta1aTopicsTopicRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    boolean pp = 9;
    boolean prettyPrint = 10;
    string quotaUser = 11;
    // Name of the topic to delete.
    string topic = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

enum $.Xgafv {
    $XGAFV_1 = 0;
    $XGAFV_2 = 1;
}

message AcknowledgeRequest {
    // The acknowledgment ID for the message being acknowledged. This was
    // returned by the Pub/Sub system in the Pull response.
    repeated string ackId = 1;
    // The subscription whose message is being acknowledged.
    string subscription = 2;
}

message Empty {
}

message Label {
    // The key of a label is a syntactically valid URL (as per RFC 1738) with
    // the "scheme" and initial slashes omitted and with the additional
    // restrictions noted below.  Each key should be globally unique.  The
    // "host" portion is called the "namespace" and is not necessarily
    // resolvable to a network endpoint.  Instead, the namespace indicates what
    // system or entity defines the semantics of the label.  Namespaces do not
    // restrict the set of objects to which a label may be associated.
    // 
    // Keys are defined by the following grammar:
    // 
    //   key          = hostname "/" kpath
    //   kpath        = ksegment *[ "/" ksegment ]
    //   ksegment     = alphadigit | *[ alphadigit | "-" | "_" | "." ]
    // 
    // where "hostname" and "alphadigit" are defined as in RFC 1738.
    // 
    // Example key:
    //   spanner.google.com/universe
    string key = 1;
    // An integer value.
    string numValue = 2;
    // A string value.
    string strValue = 3;
}

message ListSubscriptionsResponse {
    // If not empty, indicates that there are more subscriptions that match the
    // request and this value should be passed to the next
    // <code>ListSubscriptionsRequest</code> to continue.
    string nextPageToken = 1;
    // The subscriptions that match the request.
    repeated Subscription subscription = 2;
}

message ListTopicsResponse {
    // If not empty, indicates that there are more topics that match the request,
    // and this value should be passed to the next <code>ListTopicsRequest</code>
    // to continue.
    string nextPageToken = 1;
    // The resulting topics.
    repeated Topic topic = 2;
}

message ModifyAckDeadlineRequest {
    // The new ack deadline with respect to the time this request was sent to the
    // Pub/Sub system. Must be >= 0. For example, if the value is 10, the new ack
    // deadline will expire 10 seconds after the ModifyAckDeadline call was made.
    // Specifying zero may immediately make the message available for another pull
    // request.
    int32 ackDeadlineSeconds = 1;
    // The acknowledgment ID. Either this or ack_ids must be populated,
    // not both.
    string ackId = 2;
    // List of acknowledgment IDs. Either this field or ack_id
    // should be populated, not both.
    repeated string ackIds = 3;
    // Next Index: 5
    // The name of the subscription from which messages are being pulled.
    string subscription = 4;
}

message ModifyPushConfigRequest {
    // An empty <code>push_config</code> indicates that the Pub/Sub system should
    // pause pushing messages from the given subscription.
    PushConfig pushConfig = 1;
    // The name of the subscription.
    string subscription = 2;
}

message PublishBatchRequest {
    // The messages to publish.
    repeated PubsubMessage messages = 1;
    // The messages in the request will be published on this topic.
    string topic = 2;
}

message PublishBatchResponse {
    // The server-assigned ID of each published message, in the same order as
    // the messages in the request. IDs are guaranteed to be unique within
    // the topic.
    repeated string messageIds = 1;
}

message PublishRequest {
    // The message to publish.
    PubsubMessage message = 1;
    // The message in the request will be published on this topic.
    string topic = 2;
}

message PubsubEvent {
    // Indicates that this subscription has been deleted. (Note that pull
    // subscribers will always receive NOT_FOUND in response in their pull
    // request on the subscription, rather than seeing this boolean.)
    bool deleted = 1;
    // A received message.
    PubsubMessage message = 2;
    // The subscription that received the event.
    string subscription = 3;
    // Indicates that this subscription has been truncated.
    bool truncated = 4;
}

message PubsubMessage {
    // The message payload.
    string data = 1;
    // Optional list of labels for this message. Keys in this collection must
    // be unique.
    repeated Label label = 2;
    // ID of this message assigned by the server at publication time. Guaranteed
    // to be unique within the topic. This value may be read by a subscriber
    // that receives a PubsubMessage via a Pull call or a push delivery. It must
    // not be populated by a publisher in a Publish call.
    string messageId = 3;
    // The time at which the message was published.
    // The time is milliseconds since the UNIX epoch.
    string publishTime = 4;
}

message PullBatchRequest {
    // The maximum number of PubsubEvents returned for this request. The Pub/Sub
    // system may return fewer than the number of events specified.
    int32 maxEvents = 1;
    // If this is specified as true the system will respond immediately even if
    // it is not able to return a message in the Pull response. Otherwise the
    // system is allowed to wait until at least one message is available rather
    // than returning no messages. The client may cancel the request if it does
    // not wish to wait any longer for the response.
    bool returnImmediately = 2;
    // The subscription from which messages should be pulled.
    string subscription = 3;
}

message PullBatchResponse {
    // Received Pub/Sub messages or status events. The Pub/Sub system will return
    // zero messages if there are no more messages available in the backlog. The
    // Pub/Sub system may return fewer than the max_events requested even if
    // there are more messages available in the backlog.
    repeated PullResponse pullResponses = 1;
}

message PullRequest {
    // If this is specified as true the system will respond immediately even if
    // it is not able to return a message in the Pull response. Otherwise the
    // system is allowed to wait until at least one message is available rather
    // than returning FAILED_PRECONDITION. The client may cancel the request if
    // it does not wish to wait any longer for the response.
    bool returnImmediately = 1;
    // The subscription from which a message should be pulled.
    string subscription = 2;
}

message PullResponse {
    // This ID must be used to acknowledge the received event or message.
    string ackId = 1;
    // A pubsub message or truncation event.
    PubsubEvent pubsubEvent = 2;
}

message PushConfig {
    // A URL locating the endpoint to which messages should be pushed.
    // For example, a Webhook endpoint might use "https://example.com/push".
    string pushEndpoint = 1;
}

message Subscription {
    // For either push or pull delivery, the value is the maximum time after a
    // subscriber receives a message before the subscriber should acknowledge or
    // Nack the message. If the Ack deadline for a message passes without an
    // Ack or a Nack, the Pub/Sub system will eventually redeliver the message.
    // If a subscriber acknowledges after the deadline, the Pub/Sub system may
    // accept the Ack, but it is possible that the message has been already
    // delivered again. Multiple Acks to the message are allowed and will
    // succeed.
    // 
    // For push delivery, this value is used to set the request timeout for
    // the call to the push endpoint.
    // 
    // For pull delivery, this value is used as the initial value for the Ack
    // deadline. It may be overridden for each message using its corresponding
    // ack_id with <code>ModifyAckDeadline</code>.
    // While a message is outstanding (i.e. it has been delivered to a pull
    // subscriber and the subscriber has not yet Acked or Nacked), the Pub/Sub
    // system will not deliver that message to another pull subscriber
    // (on a best-effort basis).
    int32 ackDeadlineSeconds = 1;
    // Name of the subscription.
    string name = 2;
    // If push delivery is used with this subscription, this field is
    // used to configure it.
    PushConfig pushConfig = 3;
    // The name of the topic from which this subscription is receiving messages.
    string topic = 4;
}

message Topic {
    // Name of the topic.
    string name = 1;
}

enum Alt {
    JSON = 0;
    MEDIA = 1;
    PROTO = 2;
}

service GoogleCloudPub/SubService {
    // Lists matching subscriptions.
    rpc GetV1beta1aSubscriptions(GetV1beta1aSubscriptionsRequest) returns (ListSubscriptionsResponse) {
      option (google.api.http) = {
        get: "//v1beta1a/subscriptions"
      };
    }
    // Creates a subscription on a given topic for a given subscriber.
    // If the subscription already exists, returns ALREADY_EXISTS.
    // If the corresponding topic doesn't exist, returns NOT_FOUND.
    // 
    // If the name is not provided in the request, the server will assign a random
    // name for this subscription on the same project as the topic.
    rpc PostV1beta1aSubscriptions(PostV1beta1aSubscriptionsRequest) returns (Subscription) {
      option (google.api.http) = {
        post: "//v1beta1a/subscriptions"
        body: "body"
      };
    }
    // Acknowledges a particular received message: the Pub/Sub system can remove
    // the given message from the subscription. Acknowledging a message whose
    // Ack deadline has expired may succeed, but the message could have been
    // already redelivered. Acknowledging a message more than once will not
    // result in an error. This is only used for messages received via pull.
    rpc PostV1beta1aSubscriptionsAcknowledge(PostV1beta1aSubscriptionsAcknowledgeRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1beta1a/subscriptions/acknowledge"
        body: "body"
      };
    }
    // Modifies the Ack deadline for a message received from a pull request.
    rpc PostV1beta1aSubscriptionsModifyAckDeadline(PostV1beta1aSubscriptionsModifyAckDeadlineRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1beta1a/subscriptions/modifyAckDeadline"
        body: "body"
      };
    }
    // Modifies the <code>PushConfig</code> for a specified subscription.
    // This method can be used to suspend the flow of messages to an endpoint
    // by clearing the <code>PushConfig</code> field in the request. Messages
    // will be accumulated for delivery even if no push configuration is
    // defined or while the configuration is modified.
    rpc PostV1beta1aSubscriptionsModifyPushConfig(PostV1beta1aSubscriptionsModifyPushConfigRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1beta1a/subscriptions/modifyPushConfig"
        body: "body"
      };
    }
    // Pulls a single message from the server.
    // If return_immediately is true, and no messages are available in the
    // subscription, this method returns FAILED_PRECONDITION. The system is free
    // to return an UNAVAILABLE error if no messages are available in a
    // reasonable amount of time (to reduce system load).
    rpc PostV1beta1aSubscriptionsPull(PostV1beta1aSubscriptionsPullRequest) returns (PullResponse) {
      option (google.api.http) = {
        post: "//v1beta1a/subscriptions/pull"
        body: "body"
      };
    }
    // Pulls messages from the server. Returns an empty list if there are no
    // messages available in the backlog. The system is free to return UNAVAILABLE
    // if there are too many pull requests outstanding for the given subscription.
    rpc PostV1beta1aSubscriptionsPullBatch(PostV1beta1aSubscriptionsPullBatchRequest) returns (PullBatchResponse) {
      option (google.api.http) = {
        post: "//v1beta1a/subscriptions/pullBatch"
        body: "body"
      };
    }
    // Gets the configuration details of a subscription.
    rpc GetV1beta1aSubscriptionsSubscription(GetV1beta1aSubscriptionsSubscriptionRequest) returns (Subscription) {
      option (google.api.http) = {
        get: "//v1beta1a/subscriptions/{subscription}"
      };
    }
    // Deletes an existing subscription. All pending messages in the subscription
    // are immediately dropped. Calls to Pull after deletion will return
    // NOT_FOUND.
    rpc DeleteV1beta1aSubscriptionsSubscription(DeleteV1beta1aSubscriptionsSubscriptionRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1beta1a/subscriptions/{subscription}"
      };
    }
    // Lists matching topics.
    rpc GetV1beta1aTopics(GetV1beta1aTopicsRequest) returns (ListTopicsResponse) {
      option (google.api.http) = {
        get: "//v1beta1a/topics"
      };
    }
    // Creates the given topic with the given name.
    rpc PostV1beta1aTopics(PostV1beta1aTopicsRequest) returns (Topic) {
      option (google.api.http) = {
        post: "//v1beta1a/topics"
        body: "body"
      };
    }
    // Adds a message to the topic.  Returns NOT_FOUND if the topic does not
    // exist.
    rpc PostV1beta1aTopicsPublish(PostV1beta1aTopicsPublishRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1beta1a/topics/publish"
        body: "body"
      };
    }
    // Adds one or more messages to the topic. Returns NOT_FOUND if the topic does
    // not exist.
    rpc PostV1beta1aTopicsPublishBatch(PostV1beta1aTopicsPublishBatchRequest) returns (PublishBatchResponse) {
      option (google.api.http) = {
        post: "//v1beta1a/topics/publishBatch"
        body: "body"
      };
    }
    // Gets the configuration of a topic. Since the topic only has the name
    // attribute, this method is only useful to check the existence of a topic.
    // If other attributes are added in the future, they will be returned here.
    rpc GetV1beta1aTopicsTopic(GetV1beta1aTopicsTopicRequest) returns (Topic) {
      option (google.api.http) = {
        get: "//v1beta1a/topics/{topic}"
      };
    }
    // Deletes the topic with the given name. Returns NOT_FOUND if the topic does
    // not exist. After a topic is deleted, a new topic may be created with the
    // same name.
    rpc DeleteV1beta1aTopicsTopic(DeleteV1beta1aTopicsTopicRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1beta1a/topics/{topic}"
      };
    }
}
