syntax = "proto3";

import "google/protobuf/empty.proto";

import "google/api/annotations.proto";

package cloudspanner;

message DeleteV1DatabaseRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // Required. The database to be dropped.
    string database = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1DatabaseDdlRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // Required. The database whose schema we wish to get.
    string database = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1DatabaseSessionsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    // Required. The database in which to list sessions.
    string database = 6;
    string fields = 7;
    // An expression for filtering the results of the request. Filter rules are
    // case insensitive. The fields eligible for filtering are:
    // 
    //   * labels.key where key is the name of a label
    // 
    // Some examples of using filters are:
    // 
    //   * labels.env:* --> The session has the label "env".
    //   * labels.env:dev --> The session has the label "env" and the value of
    //                        the label contains the string "dev".
    string filter = 8;
    string key = 9;
    string oauth_token = 10;
    // Number of sessions to be returned in the response. If 0 or less, defaults
    // to the server's maximum allowed page size.
    int32 pageSize = 11;
    // If non-empty, `page_token` should contain a
    // next_page_token from a previous
    // ListSessionsResponse.
    string pageToken = 12;
    boolean pp = 13;
    boolean prettyPrint = 14;
    string quotaUser = 15;
    string uploadType = 16;
    string upload_protocol = 17;
}

message PostV1DatabaseSessionsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CreateSessionRequest body = 5;
    string callback = 6;
    // Required. The database in which the new session is created.
    string database = 7;
    string fields = 8;
    string key = 9;
    string oauth_token = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message GetV1NameRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    // Required. The name of the session to retrieve.
    string name = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message DeleteV1NameRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    // Required. The name of the session to delete.
    string name = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message PostV1Name:CancelRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    // The name of the operation resource to be cancelled.
    string name = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    string uploadType = 13;
    string upload_protocol = 14;
}

message GetV1ParentDatabasesRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    // Number of databases to be returned in the response. If 0 or less,
    // defaults to the server's maximum allowed page size.
    int32 pageSize = 9;
    // If non-empty, `page_token` should contain a
    // next_page_token from a
    // previous ListDatabasesResponse.
    string pageToken = 10;
    // Required. The instance whose databases should be listed.
    // Values are of the form `projects/<project>/instances/<instance>`.
    string parent = 11;
    boolean pp = 12;
    boolean prettyPrint = 13;
    string quotaUser = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message PostV1ParentDatabasesRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CreateDatabaseRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    // Required. The name of the instance that will serve the new database.
    // Values are of the form `projects/<project>/instances/<instance>`.
    string parent = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message GetV1ParentInstanceConfigsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    string key = 7;
    string oauth_token = 8;
    // Number of instance configurations to be returned in the response. If 0 or
    // less, defaults to the server's maximum allowed page size.
    int32 pageSize = 9;
    // If non-empty, `page_token` should contain a
    // next_page_token
    // from a previous ListInstanceConfigsResponse.
    string pageToken = 10;
    // Required. The name of the project for which a list of supported instance
    // configurations is requested. Values are of the form
    // `projects/<project>`.
    string parent = 11;
    boolean pp = 12;
    boolean prettyPrint = 13;
    string quotaUser = 14;
    string uploadType = 15;
    string upload_protocol = 16;
}

message GetV1ParentInstancesRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    string callback = 5;
    string fields = 6;
    // An expression for filtering the results of the request. Filter rules are
    // case insensitive. The fields eligible for filtering are:
    // 
    //   * name
    //   * display_name
    //   * labels.key where key is the name of a label
    // 
    // Some examples of using filters are:
    // 
    //   * name:* --> The instance has a name.
    //   * name:Howl --> The instance's name contains the string "howl".
    //   * name:HOWL --> Equivalent to above.
    //   * NAME:howl --> Equivalent to above.
    //   * labels.env:* --> The instance has the label "env".
    //   * labels.env:dev --> The instance has the label "env" and the value of
    //                        the label contains the string "dev".
    //   * name:howl labels.env:dev --> The instance's name contains "howl" and
    //                                  it has the label "env" with its value
    //                                  containing "dev".
    string filter = 7;
    string key = 8;
    string oauth_token = 9;
    // Number of instances to be returned in the response. If 0 or less, defaults
    // to the server's maximum allowed page size.
    int32 pageSize = 10;
    // If non-empty, `page_token` should contain a
    // next_page_token from a
    // previous ListInstancesResponse.
    string pageToken = 11;
    // Required. The name of the project for which a list of instances is
    // requested. Values are of the form `projects/<project>`.
    string parent = 12;
    boolean pp = 13;
    boolean prettyPrint = 14;
    string quotaUser = 15;
    string uploadType = 16;
    string upload_protocol = 17;
}

message PostV1ParentInstancesRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CreateInstanceRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    // Required. The name of the project in which to create the instance. Values
    // are of the form `projects/<project>`.
    string parent = 10;
    boolean pp = 11;
    boolean prettyPrint = 12;
    string quotaUser = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Resource:GetIamPolicyRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    GetIamPolicyRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // REQUIRED: The Cloud Spanner resource for which the policy is being retrieved. The format is `projects/<project ID>/instances/<instance ID>` for instance resources and `projects/<project ID>/instances/<instance ID>/databases/<database ID>` for database resources.
    string resource = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Resource:SetIamPolicyRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    SetIamPolicyRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // REQUIRED: The Cloud Spanner resource for which the policy is being set. The format is `projects/<project ID>/instances/<instance ID>` for instance resources and `projects/<project ID>/instances/<instance ID>/databases/<database ID>` for databases resources.
    string resource = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Resource:TestIamPermissionsRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    TestIamPermissionsRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // REQUIRED: The Cloud Spanner resource for which permissions are being tested. The format is `projects/<project ID>/instances/<instance ID>` for instance resources and `projects/<project ID>/instances/<instance ID>/databases/<database ID>` for database resources.
    string resource = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:BeginTransactionRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    BeginTransactionRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the transaction runs.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:CommitRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    CommitRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the transaction to be committed is running.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:ExecuteSqlRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ExecuteSqlRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the SQL query should be performed.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:ExecuteStreamingSqlRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ExecuteSqlRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the SQL query should be performed.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:ReadRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ReadRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the read should be performed.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:RollbackRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    RollbackRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the transaction to roll back is running.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

message PostV1Session:StreamingReadRequest {
    $.xgafv $.xgafv = 1;
    string access_token = 2;
    alt alt = 3;
    string bearer_token = 4;
    ReadRequest body = 5;
    string callback = 6;
    string fields = 7;
    string key = 8;
    string oauth_token = 9;
    boolean pp = 10;
    boolean prettyPrint = 11;
    string quotaUser = 12;
    // Required. The session in which the read should be performed.
    string session = 13;
    string uploadType = 14;
    string upload_protocol = 15;
}

enum $.Xgafv {
    $XGAFV_1 = 0;
    $XGAFV_2 = 1;
}

message BeginTransactionRequest {
    // Required. Options for the new transaction.
    TransactionOptions options = 1;
}

message Binding {
    // Specifies the identities requesting access for a Cloud Platform resource.
    // `members` can have the following values:
    // 
    // * `allUsers`: A special identifier that represents anyone who is
    //    on the internet; with or without a Google account.
    // 
    // * `allAuthenticatedUsers`: A special identifier that represents anyone
    //    who is authenticated with a Google account or a service account.
    // 
    // * `user:{emailid}`: An email address that represents a specific Google
    //    account. For example, `alice@gmail.com` or `joe@example.com`.
    // 
    // 
    // * `serviceAccount:{emailid}`: An email address that represents a service
    //    account. For example, `my-other-app@appspot.gserviceaccount.com`.
    // 
    // * `group:{emailid}`: An email address that represents a Google group.
    //    For example, `admins@example.com`.
    // 
    // 
    // * `domain:{domain}`: A Google Apps domain name that represents all the
    //    users of that domain. For example, `google.com` or `example.com`.
    // 
    repeated string members = 1;
    // Role that is assigned to `members`.
    // For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
    // Required
    string role = 2;
}

message ChildLink {
    // The node to which the link points.
    int32 childIndex = 1;
    // The type of the link. For example, in Hash Joins this could be used to
    // distinguish between the build child and the probe child, or in the case
    // of the child being an output variable, to represent the tag associated
    // with the output variable.
    string type = 2;
    // Only present if the child node is SCALAR and corresponds
    // to an output variable of the parent node. The field carries the name of
    // the output variable.
    // For example, a `TableScan` operator that reads rows from a table will
    // have child links to the `SCALAR` nodes representing the output variables
    // created for each column that is read by the operator. The corresponding
    // `variable` fields will be set to the variable names assigned to the
    // columns.
    string variable = 3;
}

message CommitRequest {
    // The mutations to be executed when this transaction commits. All
    // mutations are applied atomically, in the order they appear in
    // this list.
    repeated Mutation mutations = 1;
    // Execute mutations in a temporary transaction. Note that unlike
    // commit of a previously-started transaction, commit with a
    // temporary transaction is non-idempotent. That is, if the
    // `CommitRequest` is sent to Cloud Spanner more than once (for
    // instance, due to retries in the application, or in the
    // transport library), it is possible that the mutations are
    // executed more than once. If this is undesirable, use
    // BeginTransaction and
    // Commit instead.
    TransactionOptions singleUseTransaction = 2;
    // Commit a previously-started transaction.
    string transactionId = 3;
}

message CommitResponse {
    // The Cloud Spanner timestamp at which the transaction committed.
    string commitTimestamp = 1;
}

message CreateDatabaseMetadata {
    // The database being created.
    string database = 1;
}

message CreateDatabaseRequest {
    // Required. A `CREATE DATABASE` statement, which specifies the ID of the
    // new database.  The database ID must conform to the regular expression
    // `a-z*[a-z0-9]` and be between 2 and 30 characters in length.
    // If the database ID is a reserved word or if it contains a hyphen, the
    // database ID must be enclosed in backticks (`` ` ``).
    string createStatement = 1;
    // An optional list of DDL statements to run inside the newly created
    // database. Statements can create tables, indexes, etc. These
    // statements execute atomically with the creation of the database:
    // if there is an error in any statement, the database is not created.
    repeated string extraStatements = 2;
}

message CreateInstanceMetadata {
    // The time at which this operation was cancelled. If set, this operation is
    // in the process of undoing itself (which is guaranteed to succeed) and
    // cannot be cancelled again.
    string cancelTime = 1;
    // The time at which this operation failed or was completed successfully.
    string endTime = 2;
    // The instance being created.
    Instance instance = 3;
    // The time at which the
    // CreateInstance request was
    // received.
    string startTime = 4;
}

message CreateInstanceRequest {
    // Required. The instance to create.  The name may be omitted, but if
    // specified must be `<parent>/instances/<instance_id>`.
    Instance instance = 1;
    // Required. The ID of the instance to create.  Valid identifiers are of the
    // form `a-z*[a-z0-9]` and must be between 6 and 30 characters in
    // length.
    string instanceId = 2;
}

message CreateSessionRequest {
    // The session to create.
    Session session = 1;
}

message Database {
    // Required. The name of the database. Values are of the form
    // `projects/<project>/instances/<instance>/databases/<database>`,
    // where `<database>` is as specified in the `CREATE DATABASE`
    // statement. This name can be passed to other API methods to
    // identify the database.
    string name = 1;
    // Output only. The current database state.
    enum Database_State {
        DATABASE_STATE_STATE_UNSPECIFIED = 0;
        DATABASE_STATE_CREATING = 1;
        DATABASE_STATE_READY = 2;
    }
    Database_State state = 2;
}

message Delete {
    // Required. The primary keys of the rows within table to delete.
    KeySet keySet = 1;
    // Required. The table whose rows will be deleted.
    string table = 2;
}

message Empty {
}

message ExecuteSqlRequest {
    // It is not always possible for Cloud Spanner to infer the right SQL type
    // from a JSON value.  For example, values of type `BYTES` and values
    // of type `STRING` both appear in params as JSON strings.
    // 
    // In these cases, `param_types` can be used to specify the exact
    // SQL type for some or all of the SQL query parameters. See the
    // definition of Type for more information
    // about SQL types.
    map<string, Type> paramTypes = 1;
    // The SQL query string can contain parameter placeholders. A parameter
    // placeholder consists of `'@'` followed by the parameter
    // name. Parameter names consist of any combination of letters,
    // numbers, and underscores.
    // 
    // Parameters can appear anywhere that a literal value is expected.  The same
    // parameter name can be used more than once, for example:
    //   `"WHERE id > @msg_id AND id < @msg_id + 100"`
    // 
    // It is an error to execute an SQL query with unbound parameters.
    // 
    // Parameter values are specified using `params`, which is a JSON
    // object whose keys are parameter names, and whose values are the
    // corresponding parameter values.
    map<string, > params = 2;
    // Used to control the amount of debugging information returned in
    // ResultSetStats.
    enum ExecuteSqlRequest_QueryMode {
        EXECUTESQLREQUEST_QUERYMODE_NORMAL = 0;
        EXECUTESQLREQUEST_QUERYMODE_PLAN = 1;
        EXECUTESQLREQUEST_QUERYMODE_PROFILE = 2;
    }
    ExecuteSqlRequest_QueryMode queryMode = 3;
    // If this request is resuming a previously interrupted SQL query
    // execution, `resume_token` should be copied from the last
    // PartialResultSet yielded before the interruption. Doing this
    // enables the new SQL query execution to resume where the last one left
    // off. The rest of the request parameters must exactly match the
    // request that yielded this token.
    string resumeToken = 4;
    // Required. The SQL query string.
    string sql = 5;
    // The transaction to use. If none is provided, the default is a
    // temporary read-only transaction with strong concurrency.
    TransactionSelector transaction = 6;
}

message Field {
    // The name of the field. For reads, this is the column name. For
    // SQL queries, it is the column alias (e.g., `"Word"` in the
    // query `"SELECT 'hello' AS Word"`), or the column name (e.g.,
    // `"ColName"` in the query `"SELECT ColName FROM Table"`). Some
    // columns might have an empty name (e.g., !"SELECT
    // UPPER(ColName)"`). Note that a query result can contain
    // multiple fields with the same name.
    string name = 1;
    // The type of the field.
    Type type = 2;
}

message GetDatabaseDdlResponse {
    // A list of formatted DDL statements defining the schema of the database
    // specified in the request.
    repeated string statements = 1;
}

message GetIamPolicyRequest {
}

message Instance {
    // Required. The name of the instance's configuration. Values are of the form
    // `projects/<project>/instanceConfigs/<configuration>`. See
    // also InstanceConfig and
    // ListInstanceConfigs.
    string config = 1;
    // Required. The descriptive name for this instance as it appears in UIs.
    // Must be unique per project and between 4 and 30 characters in length.
    string displayName = 2;
    // Cloud Labels are a flexible and lightweight mechanism for organizing cloud
    // resources into groups that reflect a customer's organizational needs and
    // deployment strategies. Cloud Labels can be used to filter collections of
    // resources. They can be used to control how resource metrics are aggregated.
    // And they can be used as arguments to policy management rules (e.g. route,
    // firewall, load balancing, etc.).
    // 
    //  * Label keys must be between 1 and 63 characters long and must conform to
    //    the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    //  * Label values must be between 0 and 63 characters long and must conform
    //    to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    //  * No more than 64 labels can be associated with a given resource.
    // 
    // See https://goo.gl/xmQnxf for more information on and examples of labels.
    // 
    // If you plan to use labels in your own code, please note that additional
    // characters may be allowed in the future. And so you are advised to use an
    // internal label representation, such as JSON, which doesn't rely upon
    // specific characters being disallowed.  For example, representing labels
    // as the string:  name + "_" + value  would prove problematic if we were to
    // allow "_" in a future release.
    map<string, string> labels = 3;
    // Required. A unique identifier for the instance, which cannot be changed
    // after the instance is created. Values are of the form
    // `projects/<project>/instances/a-z*[a-z0-9]`. The final
    // segment of the name must be between 6 and 30 characters in length.
    string name = 4;
    // Required. The number of nodes allocated to this instance. This may be zero
    // in API responses for instances that are not yet in state `READY`.
    // 
    // Each Spanner node can provide up to 10,000 QPS of reads or 2000 QPS of
    // writes (writing single rows at 1KB data per row), and 2 TiB storage.
    // 
    // For optimal performance, we recommend provisioning enough nodes to keep
    // overall CPU utilization under 75%.
    // 
    // A minimum of 3 nodes is recommended for production environments.  This
    // minimum is required for SLAs to apply to your instance.
    // 
    // Note that Cloud Spanner performance is highly dependent on workload, schema
    // design, and dataset characteristics. The performance numbers above are
    // estimates, and assume [best practices](https://cloud.google.com/spanner/docs/bulk-loading)
    // are followed.
    int32 nodeCount = 5;
    // Output only. The current instance state. For
    // CreateInstance, the state must be
    // either omitted or set to `CREATING`. For
    // UpdateInstance, the state must be
    // either omitted or set to `READY`.
    enum Instance_State {
        INSTANCE_STATE_STATE_UNSPECIFIED = 0;
        INSTANCE_STATE_CREATING = 1;
        INSTANCE_STATE_READY = 2;
    }
    Instance_State state = 6;
}

message InstanceConfig {
    // The name of this instance configuration as it appears in UIs.
    string displayName = 1;
    // A unique identifier for the instance configuration.  Values
    // are of the form
    // `projects/<project>/instanceConfigs/a-z*`
    string name = 2;
}

message KeyRange {
    // If the end is closed, then the range includes all rows whose
    // first `len(end_closed)` key columns exactly match `end_closed`.
    message EndClosed {
    }
    repeated EndClosed endClosed = 1;
    // If the end is open, then the range excludes rows whose first
    // `len(end_open)` key columns exactly match `end_open`.
    message EndOpen {
    }
    repeated EndOpen endOpen = 2;
    // If the start is closed, then the range includes all rows whose
    // first `len(start_closed)` key columns exactly match `start_closed`.
    message StartClosed {
    }
    repeated StartClosed startClosed = 3;
    // If the start is open, then the range excludes rows whose first
    // `len(start_open)` key columns exactly match `start_open`.
    message StartOpen {
    }
    repeated StartOpen startOpen = 4;
}

message KeySet {
    // For convenience `all` can be set to `true` to indicate that this
    // `KeySet` matches all keys in the table or index. Note that any keys
    // specified in `keys` or `ranges` are only yielded once.
    bool all = 1;
    // A list of specific keys. Entries in `keys` should have exactly as
    // many elements as there are columns in the primary or index key
    // with which this `KeySet` is used.  Individual key values are
    // encoded as described here.
    message Key {
    }
    repeated Key keys = 2;
    // A list of key ranges. See KeyRange for more information about
    // key range specifications.
    repeated KeyRange ranges = 3;
}

message ListDatabasesResponse {
    // Databases that matched the request.
    repeated Database databases = 1;
    // `next_page_token` can be sent in a subsequent
    // ListDatabases call to fetch more
    // of the matching databases.
    string nextPageToken = 2;
}

message ListInstanceConfigsResponse {
    // The list of requested instance configurations.
    repeated InstanceConfig instanceConfigs = 1;
    // `next_page_token` can be sent in a subsequent
    // ListInstanceConfigs call to
    // fetch more of the matching instance configurations.
    string nextPageToken = 2;
}

message ListInstancesResponse {
    // The list of requested instances.
    repeated Instance instances = 1;
    // `next_page_token` can be sent in a subsequent
    // ListInstances call to fetch more
    // of the matching instances.
    string nextPageToken = 2;
}

message ListOperationsResponse {
    // The standard List next-page token.
    string nextPageToken = 1;
    // A list of operations that matches the specified filter in the request.
    repeated Operation operations = 2;
}

message ListSessionsResponse {
    // `next_page_token` can be sent in a subsequent
    // ListSessions call to fetch more of the matching
    // sessions.
    string nextPageToken = 1;
    // The list of requested sessions.
    repeated Session sessions = 2;
}

message Mutation {
    // Delete rows from a table. Succeeds whether or not the named
    // rows were present.
    Delete delete = 1;
    // Insert new rows in a table. If any of the rows already exist,
    // the write or transaction fails with error `ALREADY_EXISTS`.
    Write insert = 2;
    // Like insert, except that if the row already exists, then
    // its column values are overwritten with the ones provided. Any
    // column values not explicitly written are preserved.
    Write insertOrUpdate = 3;
    // Like insert, except that if the row already exists, it is
    // deleted, and the column values provided are inserted
    // instead. Unlike insert_or_update, this means any values not
    // explicitly written become `NULL`.
    Write replace = 4;
    // Update existing rows in a table. If any of the rows does not
    // already exist, the transaction fails with error `NOT_FOUND`.
    Write update = 5;
}

message Operation {
    // If the value is `false`, it means the operation is still in progress.
    // If `true`, the operation is completed, and either `error` or `response` is
    // available.
    bool done = 1;
    // The error result of the operation in case of failure or cancellation.
    Status error = 2;
    // Service-specific metadata associated with the operation.  It typically
    // contains progress information and common metadata such as create time.
    // Some services might not provide such metadata.  Any method that returns a
    // long-running operation should document the metadata type, if any.
    map<string, > metadata = 3;
    // The server-assigned name, which is only unique within the same service that
    // originally returns it. If you use the default HTTP mapping, the
    // `name` should have the format of `operations/some/unique/name`.
    string name = 4;
    // The normal response of the operation in case of success.  If the original
    // method returns no data on success, such as `Delete`, the response is
    // `google.protobuf.Empty`.  If the original method is standard
    // `Get`/`Create`/`Update`, the response should be the resource.  For other
    // methods, the response should have the type `XxxResponse`, where `Xxx`
    // is the original method name.  For example, if the original method name
    // is `TakeSnapshot()`, the inferred response type is
    // `TakeSnapshotResponse`.
    map<string, > response = 5;
}

message PartialResultSet {
    // If true, then the final value in values is chunked, and must
    // be combined with more values from subsequent `PartialResultSet`s
    // to obtain a complete field value.
    bool chunkedValue = 1;
    // Metadata about the result set, such as row type information.
    // Only present in the first response.
    ResultSetMetadata metadata = 2;
    // Streaming calls might be interrupted for a variety of reasons, such
    // as TCP connection loss. If this occurs, the stream of results can
    // be resumed by re-sending the original request and including
    // `resume_token`. Note that executing any other transaction in the
    // same session invalidates the token.
    string resumeToken = 3;
    // Query plan and execution statistics for the query that produced this
    // streaming result set. These can be requested by setting
    // ExecuteSqlRequest.query_mode and are sent
    // only once with the last response in the stream.
    ResultSetStats stats = 4;
    // A streamed result set consists of a stream of values, which might
    // be split into many `PartialResultSet` messages to accommodate
    // large rows and/or large values. Every N complete values defines a
    // row, where N is equal to the number of entries in
    // metadata.row_type.fields.
    // 
    // Most values are encoded based on type as described
    // here.
    // 
    // It is possible that the last value in values is "chunked",
    // meaning that the rest of the value is sent in subsequent
    // `PartialResultSet`(s). This is denoted by the chunked_value
    // field. Two or more chunked values can be merged to form a
    // complete value as follows:
    // 
    //   * `bool/number/null`: cannot be chunked
    //   * `string`: concatenate the strings
    //   * `list`: concatenate the lists. If the last element in a list is a
    //     `string`, `list`, or `object`, merge it with the first element in
    //     the next list by applying these rules recursively.
    //   * `object`: concatenate the (field name, field value) pairs. If a
    //     field name is duplicated, then apply these rules recursively
    //     to merge the field values.
    // 
    // Some examples of merging:
    // 
    //     # Strings are concatenated.
    //     "foo", "bar" => "foobar"
    // 
    //     # Lists of non-strings are concatenated.
    //     [2, 3], [4] => [2, 3, 4]
    // 
    //     # Lists are concatenated, but the last and first elements are merged
    //     # because they are strings.
    //     ["a", "b"], ["c", "d"] => ["a", "bc", "d"]
    // 
    //     # Lists are concatenated, but the last and first elements are merged
    //     # because they are lists. Recursively, the last and first elements
    //     # of the inner lists are merged because they are strings.
    //     ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"]
    // 
    //     # Non-overlapping object fields are combined.
    //     {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"}
    // 
    //     # Overlapping object fields are merged.
    //     {"a": "1"}, {"a": "2"} => {"a": "12"}
    // 
    //     # Examples of merging objects containing lists of strings.
    //     {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]}
    // 
    // For a more complete example, suppose a streaming SQL query is
    // yielding a result set whose rows contain a single string
    // field. The following `PartialResultSet`s might be yielded:
    // 
    //     {
    //       "metadata": { ... }
    //       "values": ["Hello", "W"]
    //       "chunked_value": true
    //       "resume_token": "Af65..."
    //     }
    //     {
    //       "values": ["orl"]
    //       "chunked_value": true
    //       "resume_token": "Bqp2..."
    //     }
    //     {
    //       "values": ["d"]
    //       "resume_token": "Zx1B..."
    //     }
    // 
    // This sequence of `PartialResultSet`s encodes two rows, one
    // containing the field value `"Hello"`, and a second containing the
    // field value `"World" = "W" + "orl" + "d"`.
    message Value {
    }
    repeated Value values = 5;
}

message PlanNode {
    // List of child node `index`es and their relationship to this parent.
    repeated ChildLink childLinks = 1;
    // The display name for the node.
    string displayName = 2;
    // The execution statistics associated with the node, contained in a group of
    // key-value pairs. Only present if the plan was returned as a result of a
    // profile query. For example, number of executions, number of rows/time per
    // execution etc.
    map<string, > executionStats = 3;
    // The `PlanNode`'s index in node list.
    int32 index = 4;
    // Used to determine the type of node. May be needed for visualizing
    // different kinds of nodes differently. For example, If the node is a
    // SCALAR node, it will have a condensed representation
    // which can be used to directly embed a description of the node in its
    // parent.
    enum PlanNode_Kind {
        PLANNODE_KIND_KIND_UNSPECIFIED = 0;
        PLANNODE_KIND_RELATIONAL = 1;
        PLANNODE_KIND_SCALAR = 2;
    }
    PlanNode_Kind kind = 5;
    // Attributes relevant to the node contained in a group of key-value pairs.
    // For example, a Parameter Reference node could have the following
    // information in its metadata:
    // 
    //     {
    //       "parameter_reference": "param1",
    //       "parameter_type": "array"
    //     }
    map<string, > metadata = 6;
    // Condensed representation for SCALAR nodes.
    ShortRepresentation shortRepresentation = 7;
}

message Policy {
    // Associates a list of `members` to a `role`.
    // `bindings` with no members will result in an error.
    repeated Binding bindings = 1;
    // `etag` is used for optimistic concurrency control as a way to help
    // prevent simultaneous updates of a policy from overwriting each other.
    // It is strongly suggested that systems make use of the `etag` in the
    // read-modify-write cycle to perform policy updates in order to avoid race
    // conditions: An `etag` is returned in the response to `getIamPolicy`, and
    // systems are expected to put that etag in the request to `setIamPolicy` to
    // ensure that their change will be applied to the same version of the policy.
    // 
    // If no `etag` is provided in the call to `setIamPolicy`, then the existing
    // policy is overwritten blindly.
    string etag = 2;
    // Version of the `Policy`. The default version is 0.
    int32 version = 3;
}

message QueryPlan {
    // The nodes in the query plan. Plan nodes are returned in pre-order starting
    // with the plan root. Each PlanNode's `id` corresponds to its index in
    // `plan_nodes`.
    repeated PlanNode planNodes = 1;
}

message ReadOnly {
    // Executes all reads at a timestamp that is `exact_staleness`
    // old. The timestamp is chosen soon after the read is started.
    // 
    // Guarantees that all writes that have committed more than the
    // specified number of seconds ago are visible. Because Cloud Spanner
    // chooses the exact timestamp, this mode works even if the client's
    // local clock is substantially skewed from Cloud Spanner commit
    // timestamps.
    // 
    // Useful for reading at nearby replicas without the distributed
    // timestamp negotiation overhead of `max_staleness`.
    string exactStaleness = 1;
    // Read data at a timestamp >= `NOW - max_staleness`
    // seconds. Guarantees that all writes that have committed more
    // than the specified number of seconds ago are visible. Because
    // Cloud Spanner chooses the exact timestamp, this mode works even if
    // the client's local clock is substantially skewed from Cloud Spanner
    // commit timestamps.
    // 
    // Useful for reading the freshest data available at a nearby
    // replica, while bounding the possible staleness if the local
    // replica has fallen behind.
    // 
    // Note that this option can only be used in single-use
    // transactions.
    string maxStaleness = 2;
    // Executes all reads at a timestamp >= `min_read_timestamp`.
    // 
    // This is useful for requesting fresher data than some previous
    // read, or data that is fresh enough to observe the effects of some
    // previously committed transaction whose timestamp is known.
    // 
    // Note that this option can only be used in single-use transactions.
    string minReadTimestamp = 3;
    // Executes all reads at the given timestamp. Unlike other modes,
    // reads at a specific timestamp are repeatable; the same read at
    // the same timestamp always returns the same data. If the
    // timestamp is in the future, the read will block until the
    // specified timestamp, modulo the read's deadline.
    // 
    // Useful for large scale consistent reads such as mapreduces, or
    // for coordinating many reads against a consistent snapshot of the
    // data.
    string readTimestamp = 4;
    // If true, the Cloud Spanner-selected read timestamp is included in
    // the Transaction message that describes the transaction.
    bool returnReadTimestamp = 5;
    // Read at a timestamp where all previously committed transactions
    // are visible.
    bool strong = 6;
}

message ReadRequest {
    // The columns of table to be returned for each row matching
    // this request.
    repeated string columns = 1;
    // If non-empty, the name of an index on table. This index is
    // used instead of the table primary key when interpreting key_set
    // and sorting result rows. See key_set for further information.
    string index = 2;
    // Required. `key_set` identifies the rows to be yielded. `key_set` names the
    // primary keys of the rows in table to be yielded, unless index
    // is present. If index is present, then key_set instead names
    // index keys in index.
    // 
    // Rows are yielded in table primary key order (if index is empty)
    // or index key order (if index is non-empty).
    // 
    // It is not an error for the `key_set` to name rows that do not
    // exist in the database. Read yields nothing for nonexistent rows.
    KeySet keySet = 3;
    // If greater than zero, only the first `limit` rows are yielded. If `limit`
    // is zero, the default is no limit.
    // A limit cannot be specified if partition_token is set.
    string limit = 4;
    // If this request is resuming a previously interrupted read,
    // `resume_token` should be copied from the last
    // PartialResultSet yielded before the interruption. Doing this
    // enables the new read to resume where the last read left off. The
    // rest of the request parameters must exactly match the request
    // that yielded this token.
    string resumeToken = 5;
    // Required. The name of the table in the database to be read.
    string table = 6;
    // The transaction to use. If none is provided, the default is a
    // temporary read-only transaction with strong concurrency.
    TransactionSelector transaction = 7;
}

message ReadWrite {
}

message ResultSet {
    // Metadata about the result set, such as row type information.
    ResultSetMetadata metadata = 1;
    // Each element in `rows` is a row whose format is defined by
    // metadata.row_type. The ith element
    // in each row matches the ith field in
    // metadata.row_type. Elements are
    // encoded based on type as described
    // here.
    message Row {
    }
    repeated Row rows = 2;
    // Query plan and execution statistics for the query that produced this
    // result set. These can be requested by setting
    // ExecuteSqlRequest.query_mode.
    ResultSetStats stats = 3;
}

message ResultSetMetadata {
    // Indicates the field names and types for the rows in the result
    // set.  For example, a SQL query like `"SELECT UserId, UserName FROM
    // Users"` could return a `row_type` value like:
    // 
    //     "fields": [
    //       { "name": "UserId", "type": { "code": "INT64" } },
    //       { "name": "UserName", "type": { "code": "STRING" } },
    //     ]
    StructType rowType = 1;
    // If the read or SQL query began a transaction as a side-effect, the
    // information about the new transaction is yielded here.
    Transaction transaction = 2;
}

message ResultSetStats {
    // QueryPlan for the query associated with this result.
    QueryPlan queryPlan = 1;
    // Aggregated statistics from the execution of the query. Only present when
    // the query is profiled. For example, a query could return the statistics as
    // follows:
    // 
    //     {
    //       "rows_returned": "3",
    //       "elapsed_time": "1.22 secs",
    //       "cpu_time": "1.19 secs"
    //     }
    map<string, > queryStats = 2;
}

message RollbackRequest {
    // Required. The transaction to roll back.
    string transactionId = 1;
}

message Session {
    // Output only. The approximate timestamp when the session is last used. It is
    // typically earlier than the actual last use time.
    string approximateLastUseTime = 1;
    // Output only. The timestamp when the session is created.
    string createTime = 2;
    // The labels for the session.
    // 
    //  * Label keys must be between 1 and 63 characters long and must conform to
    //    the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
    //  * Label values must be between 0 and 63 characters long and must conform
    //    to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
    //  * No more than 20 labels can be associated with a given session.
    map<string, string> labels = 3;
    // The name of the session.
    string name = 4;
}

message SetIamPolicyRequest {
    // REQUIRED: The complete policy to be applied to the `resource`. The size of
    // the policy is limited to a few 10s of KB. An empty policy is a
    // valid policy but certain Cloud Platform services (such as Projects)
    // might reject them.
    Policy policy = 1;
}

message ShortRepresentation {
    // A string representation of the expression subtree rooted at this node.
    string description = 1;
    // A mapping of (subquery variable name) -> (subquery node id) for cases
    // where the `description` string of this node references a `SCALAR`
    // subquery contained in the expression subtree rooted at this node. The
    // referenced `SCALAR` subquery may not necessarily be a direct child of
    // this node.
    map<string, integer> subqueries = 2;
}

message Status {
    // The status code, which should be an enum value of google.rpc.Code.
    int32 code = 1;
    // A list of messages that carry the error details.  There is a common set of
    // message types for APIs to use.
    message Detail {
    }
    repeated Detail details = 2;
    // A developer-facing error message, which should be in English. Any
    // user-facing error message should be localized and sent in the
    // google.rpc.Status.details field, or localized by the client.
    string message = 3;
}

message StructType {
    // The list of fields that make up this struct. Order is
    // significant, because values of this struct type are represented as
    // lists, where the order of field values matches the order of
    // fields in the StructType. In turn, the order of fields
    // matches the order of columns in a read request, or the order of
    // fields in the `SELECT` clause of a query.
    repeated Field fields = 1;
}

message TestIamPermissionsRequest {
    // REQUIRED: The set of permissions to check for 'resource'.
    // Permissions with wildcards (such as '*', 'spanner.*', 'spanner.instances.*') are not allowed.
    repeated string permissions = 1;
}

message TestIamPermissionsResponse {
    // A subset of `TestPermissionsRequest.permissions` that the caller is
    // allowed.
    repeated string permissions = 1;
}

message Transaction {
    // `id` may be used to identify the transaction in subsequent
    // Read,
    // ExecuteSql,
    // Commit, or
    // Rollback calls.
    // 
    // Single-use read-only transactions do not have IDs, because
    // single-use transactions do not support multiple requests.
    string id = 1;
    // For snapshot read-only transactions, the read timestamp chosen
    // for the transaction. Not returned by default: see
    // TransactionOptions.ReadOnly.return_read_timestamp.
    string readTimestamp = 2;
}

message TransactionOptions {
    // Transaction will not write.
    // 
    // Authorization to begin a read-only transaction requires
    // `spanner.databases.beginReadOnlyTransaction` permission
    // on the `session` resource.
    ReadOnly readOnly = 1;
    // Transaction may write.
    // 
    // Authorization to begin a read-write transaction requires
    // `spanner.databases.beginOrRollbackReadWriteTransaction` permission
    // on the `session` resource.
    ReadWrite readWrite = 2;
}

message TransactionSelector {
    // Begin a new transaction and execute this read or SQL query in
    // it. The transaction ID of the new transaction is returned in
    // ResultSetMetadata.transaction, which is a Transaction.
    TransactionOptions begin = 1;
    // Execute the read or SQL query in a previously-started transaction.
    string id = 2;
    // Execute the read or SQL query in a temporary transaction.
    // This is the most efficient way to execute a transaction that
    // consists of a single SQL query.
    TransactionOptions singleUse = 3;
}

message Type {
    // If code == ARRAY, then `array_element_type`
    // is the type of the array elements.
    Type arrayElementType = 1;
    // Required. The TypeCode for this type.
    enum Type_Code {
        TYPE_CODE_TYPE_CODE_UNSPECIFIED = 0;
        TYPE_CODE_BOOL = 1;
        TYPE_CODE_INT64 = 2;
        TYPE_CODE_FLOAT64 = 3;
        TYPE_CODE_TIMESTAMP = 4;
        TYPE_CODE_DATE = 5;
        TYPE_CODE_STRING = 6;
        TYPE_CODE_BYTES = 7;
        TYPE_CODE_ARRAY = 8;
        TYPE_CODE_STRUCT = 9;
    }
    Type_Code code = 2;
    // If code == STRUCT, then `struct_type`
    // provides type information for the struct's fields.
    StructType structType = 3;
}

message UpdateDatabaseDdlMetadata {
    // Reports the commit timestamps of all statements that have
    // succeeded so far, where `commit_timestamps[i]` is the commit
    // timestamp for the statement `statements[i]`.
    repeated string commitTimestamps = 1;
    // The database being modified.
    string database = 2;
    // For an update this list contains all the statements. For an
    // individual statement, this list contains only that statement.
    repeated string statements = 3;
}

message UpdateDatabaseDdlRequest {
    // If empty, the new update request is assigned an
    // automatically-generated operation ID. Otherwise, `operation_id`
    // is used to construct the name of the resulting
    // Operation.
    // 
    // Specifying an explicit operation ID simplifies determining
    // whether the statements were executed in the event that the
    // UpdateDatabaseDdl call is replayed,
    // or the return value is otherwise lost: the database and
    // `operation_id` fields can be combined to form the
    // name of the resulting
    // longrunning.Operation: `<database>/operations/<operation_id>`.
    // 
    // `operation_id` should be unique within the database, and must be
    // a valid identifier: `a-z*`. Note that
    // automatically-generated operation IDs always begin with an
    // underscore. If the named operation already exists,
    // UpdateDatabaseDdl returns
    // `ALREADY_EXISTS`.
    string operationId = 1;
    // DDL statements to be applied to the database.
    repeated string statements = 2;
}

message UpdateInstanceMetadata {
    // The time at which this operation was cancelled. If set, this operation is
    // in the process of undoing itself (which is guaranteed to succeed) and
    // cannot be cancelled again.
    string cancelTime = 1;
    // The time at which this operation failed or was completed successfully.
    string endTime = 2;
    // The desired end state of the update.
    Instance instance = 3;
    // The time at which UpdateInstance
    // request was received.
    string startTime = 4;
}

message UpdateInstanceRequest {
    // Required. A mask specifying which fields in [][google.spanner.admin.instance.v1.UpdateInstanceRequest.instance] should be updated.
    // The field mask must always be specified; this prevents any future fields in
    // [][google.spanner.admin.instance.v1.Instance] from being erased accidentally by clients that do not know
    // about them.
    string fieldMask = 1;
    // Required. The instance to update, which must always include the instance
    // name.  Otherwise, only fields mentioned in [][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask] need be included.
    Instance instance = 2;
}

message Write {
    // The names of the columns in table to be written.
    // 
    // The list of columns must contain enough columns to allow
    // Cloud Spanner to derive values for all primary key columns in the
    // row(s) to be modified.
    repeated string columns = 1;
    // Required. The table whose rows will be written.
    string table = 2;
    // The values to be written. `values` can contain more than one
    // list of values. If it does, then multiple rows are written, one
    // for each entry in `values`. Each list in `values` must have
    // exactly as many entries as there are entries in columns
    // above. Sending multiple lists is equivalent to sending multiple
    // `Mutation`s, each containing one `values` entry and repeating
    // table and columns. Individual values in each list are
    // encoded as described here.
    message Value {
    }
    repeated Value values = 3;
}

enum Alt {
    JSON = 0;
    MEDIA = 1;
    PROTO = 2;
}

service CloudSpannerService {
    // Drops (aka deletes) a Cloud Spanner database.
    rpc DeleteV1Database(DeleteV1DatabaseRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/{database}"
      };
    }
    // Returns the schema of a Cloud Spanner database as a list of formatted
    // DDL statements. This method does not show pending schema updates, those may
    // be queried using the Operations API.
    rpc GetV1DatabaseDdl(GetV1DatabaseDdlRequest) returns (GetDatabaseDdlResponse) {
      option (google.api.http) = {
        get: "//v1/{database}/ddl"
      };
    }
    // Lists all sessions in a given database.
    rpc GetV1DatabaseSessions(GetV1DatabaseSessionsRequest) returns (ListSessionsResponse) {
      option (google.api.http) = {
        get: "//v1/{database}/sessions"
      };
    }
    // Creates a new session. A session can be used to perform
    // transactions that read and/or modify data in a Cloud Spanner database.
    // Sessions are meant to be reused for many consecutive
    // transactions.
    // 
    // Sessions can only execute one transaction at a time. To execute
    // multiple concurrent read-write/write-only transactions, create
    // multiple sessions. Note that standalone reads and queries use a
    // transaction internally, and count toward the one transaction
    // limit.
    // 
    // Cloud Spanner limits the number of sessions that can exist at any given
    // time; thus, it is a good idea to delete idle and/or unneeded sessions.
    // Aside from explicit deletes, Cloud Spanner can delete sessions for which no
    // operations are sent for more than an hour. If a session is deleted,
    // requests to it return `NOT_FOUND`.
    // 
    // Idle sessions can be kept alive by sending a trivial SQL query
    // periodically, e.g., `"SELECT 1"`.
    rpc PostV1DatabaseSessions(PostV1DatabaseSessionsRequest) returns (Session) {
      option (google.api.http) = {
        post: "//v1/{database}/sessions"
        body: "body"
      };
    }
    // Gets a session. Returns `NOT_FOUND` if the session does not exist.
    // This is mainly useful for determining whether a session is still
    // alive.
    rpc GetV1Name(GetV1NameRequest) returns (Session) {
      option (google.api.http) = {
        get: "//v1/{name}"
      };
    }
    // Ends a session, releasing server resources associated with it.
    rpc DeleteV1Name(DeleteV1NameRequest) returns (Empty) {
      option (google.api.http) = {
        delete: "//v1/{name}"
      };
    }
    // Starts asynchronous cancellation on a long-running operation.  The server
    // makes a best effort to cancel the operation, but success is not
    // guaranteed.  If the server doesn't support this method, it returns
    // `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
    // Operations.GetOperation or
    // other methods to check whether the cancellation succeeded or whether the
    // operation completed despite cancellation. On successful cancellation,
    // the operation is not deleted; instead, it becomes an operation with
    // an Operation.error value with a google.rpc.Status.code of 1,
    // corresponding to `Code.CANCELLED`.
    rpc PostV1Name:Cancel(PostV1Name:CancelRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1/{name}:cancel"
      };
    }
    // Lists Cloud Spanner databases.
    rpc GetV1ParentDatabases(GetV1ParentDatabasesRequest) returns (ListDatabasesResponse) {
      option (google.api.http) = {
        get: "//v1/{parent}/databases"
      };
    }
    // Creates a new Cloud Spanner database and starts to prepare it for serving.
    // The returned long-running operation will
    // have a name of the format `<database_name>/operations/<operation_id>` and
    // can be used to track preparation of the database. The
    // metadata field type is
    // CreateDatabaseMetadata. The
    // response field type is
    // Database, if successful.
    rpc PostV1ParentDatabases(PostV1ParentDatabasesRequest) returns (Operation) {
      option (google.api.http) = {
        post: "//v1/{parent}/databases"
        body: "body"
      };
    }
    // Lists the supported instance configurations for a given project.
    rpc GetV1ParentInstanceConfigs(GetV1ParentInstanceConfigsRequest) returns (ListInstanceConfigsResponse) {
      option (google.api.http) = {
        get: "//v1/{parent}/instanceConfigs"
      };
    }
    // Lists all instances in the given project.
    rpc GetV1ParentInstances(GetV1ParentInstancesRequest) returns (ListInstancesResponse) {
      option (google.api.http) = {
        get: "//v1/{parent}/instances"
      };
    }
    // Creates an instance and begins preparing it to begin serving. The
    // returned long-running operation
    // can be used to track the progress of preparing the new
    // instance. The instance name is assigned by the caller. If the
    // named instance already exists, `CreateInstance` returns
    // `ALREADY_EXISTS`.
    // 
    // Immediately upon completion of this request:
    // 
    //   * The instance is readable via the API, with all requested attributes
    //     but no allocated resources. Its state is `CREATING`.
    // 
    // Until completion of the returned operation:
    // 
    //   * Cancelling the operation renders the instance immediately unreadable
    //     via the API.
    //   * The instance can be deleted.
    //   * All other attempts to modify the instance are rejected.
    // 
    // Upon completion of the returned operation:
    // 
    //   * Billing for all successfully-allocated resources begins (some types
    //     may have lower than the requested levels).
    //   * Databases can be created in the instance.
    //   * The instance's allocated resource levels are readable via the API.
    //   * The instance's state becomes `READY`.
    // 
    // The returned long-running operation will
    // have a name of the format `<instance_name>/operations/<operation_id>` and
    // can be used to track creation of the instance.  The
    // metadata field type is
    // CreateInstanceMetadata.
    // The response field type is
    // Instance, if successful.
    rpc PostV1ParentInstances(PostV1ParentInstancesRequest) returns (Operation) {
      option (google.api.http) = {
        post: "//v1/{parent}/instances"
        body: "body"
      };
    }
    // Gets the access control policy for a database resource. Returns an empty
    // policy if a database exists but does not have a policy set.
    // 
    // Authorization requires `spanner.databases.getIamPolicy` permission on
    // resource.
    rpc PostV1Resource:GetIamPolicy(PostV1Resource:GetIamPolicyRequest) returns (Policy) {
      option (google.api.http) = {
        post: "//v1/{resource}:getIamPolicy"
        body: "body"
      };
    }
    // Sets the access control policy on a database resource. Replaces any
    // existing policy.
    // 
    // Authorization requires `spanner.databases.setIamPolicy` permission on
    // resource.
    rpc PostV1Resource:SetIamPolicy(PostV1Resource:SetIamPolicyRequest) returns (Policy) {
      option (google.api.http) = {
        post: "//v1/{resource}:setIamPolicy"
        body: "body"
      };
    }
    // Returns permissions that the caller has on the specified database resource.
    // 
    // Attempting this RPC on a non-existent Cloud Spanner database will result in
    // a NOT_FOUND error if the user has `spanner.databases.list` permission on
    // the containing Cloud Spanner instance. Otherwise returns an empty set of
    // permissions.
    rpc PostV1Resource:TestIamPermissions(PostV1Resource:TestIamPermissionsRequest) returns (TestIamPermissionsResponse) {
      option (google.api.http) = {
        post: "//v1/{resource}:testIamPermissions"
        body: "body"
      };
    }
    // Begins a new transaction. This step can often be skipped:
    // Read, ExecuteSql and
    // Commit can begin a new transaction as a
    // side-effect.
    rpc PostV1Session:BeginTransaction(PostV1Session:BeginTransactionRequest) returns (Transaction) {
      option (google.api.http) = {
        post: "//v1/{session}:beginTransaction"
        body: "body"
      };
    }
    // Commits a transaction. The request includes the mutations to be
    // applied to rows in the database.
    // 
    // `Commit` might return an `ABORTED` error. This can occur at any time;
    // commonly, the cause is conflicts with concurrent
    // transactions. However, it can also happen for a variety of other
    // reasons. If `Commit` returns `ABORTED`, the caller should re-attempt
    // the transaction from the beginning, re-using the same session.
    rpc PostV1Session:Commit(PostV1Session:CommitRequest) returns (CommitResponse) {
      option (google.api.http) = {
        post: "//v1/{session}:commit"
        body: "body"
      };
    }
    // Executes an SQL query, returning all rows in a single reply. This
    // method cannot be used to return a result set larger than 10 MiB;
    // if the query yields more data than that, the query fails with
    // a `FAILED_PRECONDITION` error.
    // 
    // Queries inside read-write transactions might return `ABORTED`. If
    // this occurs, the application should restart the transaction from
    // the beginning. See Transaction for more details.
    // 
    // Larger result sets can be fetched in streaming fashion by calling
    // ExecuteStreamingSql instead.
    rpc PostV1Session:ExecuteSql(PostV1Session:ExecuteSqlRequest) returns (ResultSet) {
      option (google.api.http) = {
        post: "//v1/{session}:executeSql"
        body: "body"
      };
    }
    // Like ExecuteSql, except returns the result
    // set as a stream. Unlike ExecuteSql, there
    // is no limit on the size of the returned result set. However, no
    // individual row in the result set can exceed 100 MiB, and no
    // column value can exceed 10 MiB.
    rpc PostV1Session:ExecuteStreamingSql(PostV1Session:ExecuteStreamingSqlRequest) returns (PartialResultSet) {
      option (google.api.http) = {
        post: "//v1/{session}:executeStreamingSql"
        body: "body"
      };
    }
    // Reads rows from the database using key lookups and scans, as a
    // simple key/value style alternative to
    // ExecuteSql.  This method cannot be used to
    // return a result set larger than 10 MiB; if the read matches more
    // data than that, the read fails with a `FAILED_PRECONDITION`
    // error.
    // 
    // Reads inside read-write transactions might return `ABORTED`. If
    // this occurs, the application should restart the transaction from
    // the beginning. See Transaction for more details.
    // 
    // Larger result sets can be yielded in streaming fashion by calling
    // StreamingRead instead.
    rpc PostV1Session:Read(PostV1Session:ReadRequest) returns (ResultSet) {
      option (google.api.http) = {
        post: "//v1/{session}:read"
        body: "body"
      };
    }
    // Rolls back a transaction, releasing any locks it holds. It is a good
    // idea to call this for any transaction that includes one or more
    // Read or ExecuteSql requests and
    // ultimately decides not to commit.
    // 
    // `Rollback` returns `OK` if it successfully aborts the transaction, the
    // transaction was already aborted, or the transaction is not
    // found. `Rollback` never returns `ABORTED`.
    rpc PostV1Session:Rollback(PostV1Session:RollbackRequest) returns (Empty) {
      option (google.api.http) = {
        post: "//v1/{session}:rollback"
        body: "body"
      };
    }
    // Like Read, except returns the result set as a
    // stream. Unlike Read, there is no limit on the
    // size of the returned result set. However, no individual row in
    // the result set can exceed 100 MiB, and no column value can exceed
    // 10 MiB.
    rpc PostV1Session:StreamingRead(PostV1Session:StreamingReadRequest) returns (PartialResultSet) {
      option (google.api.http) = {
        post: "//v1/{session}:streamingRead"
        body: "body"
      };
    }
}
